# DEPRECATED: Plan: Integrate Layered v15f Map Builder Layouts into the Parallax Area System

> **⚠️ DEPRECATED**: This page documents the legacy 2D parallax pipeline. Use the [3D map editor](../map-editor.html) and [3D Map Builder](../3Dmapbuilder.html) for current workflows. Visual maps are now stored in `/config/maps/visualsmaps`. See [DEPRECATED_PARALLAX_TO_3D_MIGRATION.md](../DEPRECATED_PARALLAX_TO_3D_MIGRATION.md) for migration guidance.

---

# Plan: Integrate Layered v15f Map Builder Layouts into the Parallax Area System

## Current State

- The runtime keeps a `PARALLAX` registry whose `areas` entries declare backgrounds (`layers`) and doors for each scene. Each layer record currently contains an image URL, parallax speed, `z` ordering, and repeat flag, and the helper `loadParallaxLayers` converts those into in-memory textures when an area is entered.【F:ancient code-monolith of truth V2.html†L763-L867】
- Foreground and gameplay props are hydrated via `loadParallaxProps`, which expects each area to expose a `props` array populated with image URLs, placement metadata, and optional keyframe bundles that match the rendering hooks patched around the core draw loop.【F:ancient code-monolith of truth V2.html†L5714-L5889】
- The layered v15f editor exports layouts that combine ordered layer definitions (with parallax, vertical offsets, spacing, and scale) plus prefab instances referencing structure JSON files that include screen-space keyframe data per part.【F:tools/parallax_map_builder_notes.md†L3-L49】

## Integration Options (3 proposals)

1. **Author-time conversion to `CONFIG.areas` JSON**  
   - *Idea:* Extend the builder export flow (or a companion CLI) to emit a top-level JSON blob that mirrors the runtime's `CONFIG.areas` shape. Each saved map becomes an area entry containing `layers` converted to background URLs and `props` generated by expanding prefab instances into baked sprite placements.  
   - *Pros:* Produces assets the engine already understands; minimal runtime overhead; easy to version control per area.  
   - *Cons:* Requires deterministic prefab expansion (must resolve every part into final `url`, `x/y`, parallax, and KF data); any future builder changes demand re-export; harder to support in-editor iteration without re-running the converter.

2. **Runtime adapter that consumes raw builder layouts**  
   - *Idea:* Store builder JSON verbatim and add a loader that, on area activation, transforms the `layers` and `instances` arrays into the legacy parallax structures in memory. Prefab definitions (structure JSON and images) would be pulled on demand, and instances would be expanded into `props` at load time.  
   - *Pros:* Keeps builder output as the single source of truth; enables hot-reload workflows; easier to preserve instance metadata such as `slot`, `nudgeX`, and per-instance scale/rotation adjustments.  
   - *Cons:* Needs a robust resolver for prefab assets and their keyframes; higher runtime cost during area swaps; more complex error handling when referenced prefab files are missing.

3. **Hybrid cache with incremental baking**  
   - *Idea:* Save builder layouts and introduce a build step that materializes `CONFIG.areas` caches (option 1) while preserving the raw layout for live editing (option 2). The runtime consumes the baked cache by default, but a debug flag can fall back to on-the-fly conversion for rapid iteration.  
   - *Pros:* Gives designers a fast authoring loop while shipping optimized data; allows QA to diff both the raw map and baked results; provides a clear migration path if runtime requirements change.  
   - *Cons:* Requires build tooling and cache invalidation; two artifact types to manage; slightly more upfront engineering.

## Recommended Direction

Adopt **Option 3 (Hybrid cache)**: it balances designer agility with runtime simplicity. The runtime keeps consuming a familiar `CONFIG.areas` document, while a small converter can regenerate that document from raw builder layouts whenever prefabs change.

## Implementation Steps

1. **Introduce a layout ingestion pipeline**  
   - Define a canonical storage location for builder exports (e.g., `docs/config/maps/<area>.layout.json`).  
   - Add a Node.js script under `tools/` that reads a layout file, resolves prefabs from `prefabs/structures/`, and emits an area entry containing converted `layers`, `props`, and door metadata (door editing can remain manual for the first iteration).  
   - Output a merged `CONFIG.areas` JSON shard suitable for loading through the existing remote-config path (`loaded.areas`).

2. **Map layer fields to runtime expectations**  
   - Convert builder `layers` into `{ url, parallaxSpeed, z, repeat }` records or define an extended format that carries `yOffset/scale` if the runtime needs them.  
   - Decide how to translate builder `parallax` and `scale` fields into the engine's `parallaxSpeed` and sprite scaling rules; document any assumptions inside the converter for future tuning.

3. **Expand prefab instances into prop placements**  
   - For each instance, iterate its prefab parts, compute world positions from `slot`, `nudgeX`, `offsetY`, and layer configuration, and generate prop records with baked `kf` objects in the same shape `loadParallaxProps` expects.  
   - Ensure per-part layers (`far/near`) map to runtime `behind/front` buckets, and include per-instance overrides (`scaleX`, `scaleY`, `rot`).

4. **Provide verification + iteration hooks**  
   - Add tests or a lint command that validates all referenced prefab assets and images exist.  
   - Document the workflow in `docs/` so designers know to rerun the converter after editing layouts or prefabs.  
   - Optionally add a debug flag to call the runtime adapter directly for live editing, falling back to baked data when absent.

