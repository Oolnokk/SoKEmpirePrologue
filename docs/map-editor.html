<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Grid Map Editor (Real 3D)</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --tower-color: #3b82f6;
      --road-color: #6b7280;
      --sidewalk-color: #9ca3af;
      --grid-border: #1f2937;
      --bg: #0f172a;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 16px; background: var(--bg); color: #e5e7eb; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .app { max-width: 1100px; margin: 0 auto; display: flex; flex-direction: column; gap: 12px; }
.toolbar {
  display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
  padding: 8px; border-radius: 8px;
  background: #020617; border: 1px solid #1e293b;
  box-shadow: 0 1px 3px rgba(0,0,0,0.35);
}
.toolbar-group {
  display: flex; align-items: flex-start; gap: 6px;
  padding-right: 8px; border-right: 1px solid #1f2937;
}
.toolbar-group:last-child { border-right: none; padding-right: 0; }
.toolbar label { font-size: 12px; font-weight: 600; text-transform: uppercase; color: #9ca3af; }
select, button, input, textarea { font: inherit; }
select {
  padding: 4px 6px; border-radius: 6px; border: 1px solid #334155;
  background: #020617; color: #e5e7eb; font-size: 13px;
}

.orientation-buttons { display: grid; grid-template-columns: repeat(4, auto); gap: 4px; }
.orientation-btn {
  width: 32px; height: 32px; border-radius: 6px;
  border: 1px solid #334155; background: #020617; color: #e5e7eb;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; font-size: 16px;
}
.orientation-btn.active { border-color: #2563eb; box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.7); }
.orientation-btn:active { transform: translateY(1px); }
.toolbar-note { font-size: 11px; color: #6b7280; margin-left: 4px; }

.toggle-arrows-wrapper { display: inline-flex; align-items: center; gap: 4px; font-size: 12px; color: #e5e7eb; }
.toggle-arrows-wrapper input { width: auto; }

.badge { display: inline-flex; align-items: center; gap: 4px; border-radius: 999px; padding: 2px 8px; font-size: 11px; background: #172554; color: #bfdbfe; }
.badge-dot { width: 6px; height: 6px; border-radius: 999px; background: #22c55e; }

.main { display: grid; grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr); gap: 12px; }
@media (max-width: 800px) { .main { grid-template-columns: 1fr; } }

.grid-wrapper {
  padding: 8px; border-radius: 8px; background: #020617;
  border: 1px solid #1f2937; box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}

.three-viewport {
  width: 100%; height: 260px; border-radius: 8px;
  border: 1px solid #1e293b; margin-bottom: 8px; overflow: hidden;
  background: #020617; position: relative;
}
.three-overlay {
  position: absolute; left: 8px; bottom: 6px;
  font-size: 11px; color: #cbd5f5;
  background: rgba(15, 23, 42, 0.85); padding: 3px 6px; border-radius: 4px;
  pointer-events: none; z-index: 5;
}

.grid-label { font-size: 12px; color: #9ca3af; margin-bottom: 4px; }

.grid {
  display: grid; grid-template-columns: repeat(20, 1fr);
  border: 1px solid var(--grid-border); background: #020617;
  user-select: none;
}
.cell {
  position: relative; border: 1px solid #1f2937; aspect-ratio: 1/1;
  background: #020617; cursor: pointer; overflow: visible;
}
.cell:hover { background: #0b1120; }
.cell.selected-primary { outline: 2px solid #f97316; outline-offset: -2px; }
.cell.selected-group { outline: 2px solid #22c55e; outline-offset: -2px; }

.triangle { position: absolute; left: 50%; top: 50%; width: 70%; height: 70%; transform-origin: 50% 50%; z-index: 1; pointer-events: none; }
.triangle-svg { width: 100%; height: 100%; overflow: visible; }

.y-label {
  position: absolute; left: 50%; top: -14px; transform: translateX(-50%);
  font-size: 10px; font-weight: 600; color: #f9fafb;
  background: rgba(15,23,42,0.9); padding: 0 3px; border-radius: 3px;
  border: 1px solid #334155; z-index: 2; pointer-events: none;
}

.side-panel { display: flex; flex-direction: column; gap: 8px; }
.card {
  background: #020617; border-radius: 8px; border: 1px solid #1f2937;
  padding: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.4);
  font-size: 13px;
}
.card h2 { margin: 0 0 4px; font-size: 14px; }
.info-row { display: flex; justify-content: space-between; gap: 8px; margin: 2px 0; }
.info-label { color: #9ca3af; }
.info-value { font-weight: 500; color: #e5e7eb; }

.field-group { margin-top: 6px; display: flex; flex-direction: column; gap: 2px; }
.field-group label { font-size: 11px; color: #9ca3af; }
.field-group input {
  padding: 3px 4px; border-radius: 4px; border: 1px solid #334155;
  font-size: 12px; width: 100%; background: #020617; color: #e5e7eb;
}

.scale-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-top: 4px; }
.scale-field { display: flex; flex-direction: column; gap: 2px; }

#selectionControls { display: none; }

.button-row { margin-top: 6px; display: flex; flex-wrap: wrap; gap: 6px; }
.button-row button {
  padding: 4px 8px; border-radius: 6px; border: 1px solid #334155;
  background: #020617; font-size: 12px; cursor: pointer; color: #e5e7eb;
}
.button-row button:hover:not(:disabled) { background: #0b1120; }
.button-row button:disabled { opacity: 0.5; cursor: default; }
.button-row button.primary { background: #2563eb; color: white; border-color: #1d4ed8; }
.button-row button.primary:hover:not(:disabled) { background: #1d4ed8; }

.camera-slider { display: flex; flex-direction: column; gap: 2px; margin-top: 4px; }
.camera-slider label { font-size: 11px; color: #9ca3af; }
.camera-slider input[type="range"] { width: 100%; }

.debug-log {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 11px; max-height: 160px; overflow: auto;
  padding: 6px; background: #020617; border-radius: 6px; border: 1px solid #1f2937;
  white-space: pre-line;
}
.debug-log-line { margin-bottom: 2px; }

.json-output {
  margin-top: 6px; width: 100%; height: 120px; border-radius: 6px; border: 1px solid #334155;
  padding: 4px 6px; font-size: 11px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  resize: vertical; background: #020617; color: #e5e7eb;
}

.asset-panel {
  display: inline-flex; flex-direction: column; gap: 2px;
  max-height: 110px; overflow-y: auto;
  padding: 4px; border-radius: 6px; border: 1px solid #1f2937; background: #020617;
  min-width: 210px;
}
.asset-row {
  display: grid;
  grid-template-columns: 1fr auto auto;
  grid-template-rows: auto auto;
  grid-template-areas: "name gltf cfg" "status status status";
  gap: 2px 4px;
  align-items: center;
  font-size: 11px;
  padding: 2px 0;
  border-bottom: 1px solid #0f172a;
}
.asset-row:last-child { border-bottom: none; }
.asset-name { grid-area: name; font-weight: 500; }
.asset-upload-btn, .asset-config-btn {
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid #334155;
  background: #020617;
  color: #e5e7eb;
  font-size: 11px;
  cursor: pointer;
  white-space: nowrap;
}
.asset-upload-btn:hover, .asset-config-btn:hover { background: #0b1120; }
.asset-upload-btn { grid-area: gltf; }
.asset-config-btn { grid-area: cfg; }

.asset-status {
  grid-area: status;
  font-size: 10px;
  color: #9ca3af;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 230px;
}
.asset-status.loaded { color: #22c55e; }
.asset-status.missing { color: #fbbf24; }
.asset-status.placeholder { color: #9ca3af; }

.toolbar-small-column { display: flex; flex-direction: column; gap: 4px; }
.toolbar-small-button { padding: 2px 6px !important; font-size: 11px !important; }
.chip-row { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
.chip { padding: 2px 6px; border-radius: 999px; border: 1px solid #1f2937; font-size: 11px; background: #020617; }

/* Gameplay path (side-scroller axis) */
.grid-container { position: relative; }
.path-svg {
  position: absolute; left: 0; top: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 4;
}
.path-line { stroke: #fbbf24; stroke-width: 3; stroke-linecap: round; stroke-dasharray: 6 6; }
.path-point { stroke: #0f172a; stroke-width: 2; }
.path-point.start { fill: #22c55e; }
.path-point.end { fill: #ef4444; }
.cell.path-start { outline: 2px solid #22c55e !important; outline-offset: -2px; }
.cell.path-end { outline: 2px solid #ef4444 !important; outline-offset: -2px; }
.path-hint { font-size: 11px; color: #cbd5f5; margin-left: 4px; }

  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Grid Map Editor (Real 3D)</h1>
    </header>

<section class="toolbar">
  <div class="toolbar-group">
    <div class="toolbar-small-column">
      <label for="layerSelect">Layer</label>
      <select id="layerSelect">
        <option value="ground">Ground Segments</option>
        <option value="structure" selected>Structures</option>
        <option value="decoration">Decorations</option>
      </select>

      <label for="tileTypeSelect">Tile Brush</label>
      <select id="tileTypeSelect"></select>
    </div>
  </div>

  <div class="toolbar-group">
    <label>Orientation</label>
    <div class="orientation-buttons" id="orientationButtons">
      <button class="orientation-btn" data-orientation="0"   title="Up (North)">↑</button>
      <button class="orientation-btn" data-orientation="90"  title="Right (East)">→</button>
      <button class="orientation-btn" data-orientation="180" title="Down (South)">↓</button>
      <button class="orientation-btn" data-orientation="270" title="Left (West)">←</button>
    </div>
    <span class="toolbar-note">Brush + selected rotation.</span>
  </div>

  <div class="toolbar-group">
    <label for="showArrowsCheckbox">Arrows</label>
    <div class="toggle-arrows-wrapper">
      <input type="checkbox" id="showArrowsCheckbox" checked />
      <span>Show direction arrows</span>
    </div>
  </div>

<div class="toolbar-group">
  <div class="toolbar-small-column">
    <label for="toolSelect">Tool</label>
    <select id="toolSelect">
      <option value="paint" selected>Paint / Select</option>
      <option value="pathStart">Set Path Start</option>
      <option value="pathEnd">Set Path End</option>
    </select>

    <label>Gameplay Path</label>
    <div style="display:flex; gap:6px; flex-wrap:wrap;">
      <button id="clearPathBtn" class="toolbar-small-button" type="button">Clear</button>
      <label class="toggle-arrows-wrapper" style="gap:6px;">
        <input type="checkbox" id="alignToPathCheckbox" checked />
        <span>Align world to path</span>
      </label>
    </div>
    <span class="toolbar-note">In tool mode, tap a cell to set start/end.</span>
  </div>
</div>

  <div class="toolbar-group">
    <div class="toolbar-small-column">
      <label>Layer Assets</label>
      <div id="assetPanel" class="asset-panel"></div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <button id="reload3DBtn" class="toolbar-small-button">Reload 3D</button>
        <button id="importJsonBtn" class="toolbar-small-button">Import Map JSON</button>
        <input id="importJsonInput" type="file" accept=".json" style="display:none;" />
      </div>
      <label style="margin-top:8px;">Load Preset Map</label>
      <select id="presetMapSelect" class="toolbar-small-button" style="width:100%; padding:4px;">
        <option value="">-- Select a preset --</option>
        <option value="config/maps/defaultdistrict.layout.json">Default District</option>
        <option value="config/maps/defaultdistrict-line.layout.json">Default District (Line)</option>
      </select>
    </div>
  </div>

  <div class="toolbar-group">
    <span class="badge">
      <span class="badge-dot"></span>
      Live Debug ON
    </span>
  </div>
</section>

<section class="main">
  <div class="grid-wrapper">
    <div id="threeViewport" class="three-viewport">
      <div id="threeOverlay" class="three-overlay">Loading 3D...</div>
    </div>
    <div class="grid-label">Logical Map Grid (20×20 editor)</div>
    <div id="gridContainer" class="grid-container">
      <svg id="pathSvg" class="path-svg"></svg>
      <div id="grid" class="grid"></div>
    </div>
  </div>

  <aside class="side-panel">
    <div class="card" id="selectionInfo">
      <h2>Selected Cell(s)</h2>

      <div class="info-row">
        <span class="info-label">Primary Coord:</span>
        <span class="info-value" id="coordValue">none</span>
      </div>
      <div class="info-row">
        <span class="info-label">Tile:</span>
        <span class="info-value" id="tileValue">—</span>
      </div>
      <div class="info-row">
        <span class="info-label">Rotation:</span>
        <span class="info-value" id="orientationValue">—</span>
      </div>
      <div class="info-row">
        <span class="info-label">Selected count:</span>
        <span class="info-value" id="selectionCountValue">0</span>
      </div>

      <div class="button-row">
        <button id="deleteTileBtn" title="Delete tile(s) in selection">Delete Tile(s)</button>
      </div>

      <div id="selectionControls">
        <div class="field-group">
          <label for="rotationInput">Rotation (0–359°)</label>
          <input type="number" id="rotationInput" min="0" max="359" step="1" />
        </div>

        <div class="scale-grid">
          <div class="scale-field">
            <label for="scaleXInput">Scale X</label>
            <input type="number" id="scaleXInput" step="0.1" />
          </div>
          <div class="scale-field">
            <label for="scaleYInput">Scale Y (height)</label>
            <input type="number" id="scaleYInput" step="0.1" />
          </div>
          <div class="scale-field">
            <label for="scaleZInput">Scale Z</label>
            <input type="number" id="scaleZInput" step="0.1" />
          </div>
        </div>

        <div class="scale-grid" style="margin-top:4px;">
          <div class="scale-field">
            <label for="offsetXInput">Offset X</label>
            <input type="number" id="offsetXInput" step="0.1" />
          </div>
          <div class="scale-field">
            <label for="offsetYInput">Offset Z</label>
            <input type="number" id="offsetYInput" step="0.1" />
          </div>
          <div class="scale-field">
            <label>&nbsp;</label>
            <input type="text" disabled value="Per-instance XY offsets (struct/deco)" />
          </div>
        </div>
      </div>

      <div class="chip-row">
        <span class="chip">Drag on grid to group-select. Edits apply to all selected cells (active layer).</span>
        <span class="chip">New placements inherit last edited instanceDefaults per tile type.</span>
        <span class="chip">Per-asset JSON: baseScale, yOffset, forwardOffsetDeg, instanceDefaults, extra.</span>
      </div>
    </div>

    <div class="card">
      <h2>Camera</h2>
      <div class="camera-slider">
        <label for="camRotX">Tilt X (pitch)</label>
        <input type="range" id="camRotX" min="5" max="85" step="1" value="55" />
      </div>
      <div class="camera-slider">
        <label for="camRotY">Rotate Y (yaw/orbit)</label>
        <input type="range" id="camRotY" min="-180" max="180" step="1" value="35" />
      </div>
      <div class="camera-slider">
        <label for="camDistance">Distance</label>
        <input type="range" id="camDistance" min="20" max="80" step="1" value="40" />
      </div>
    </div>

    <div class="card">
      <h2>Debug Log (inline)</h2>
      <div id="debugLog" class="debug-log"></div>
    </div>

    <div class="card">
      <h2>Export JSON</h2>
      <div class="button-row">
        <button id="generateJsonBtn" class="primary">Generate JSON</button>
        <button id="downloadJsonBtn">Download JSON</button>
      </div>
      <textarea id="jsonOutput" class="json-output" readonly></textarea>
    </div>
  </aside>
</section>

  </div>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.149.0";
    import { GLTFLoader } from "https://esm.sh/three@0.149.0/examples/jsm/loaders/GLTFLoader.js";

    window.THREE = THREE;

    const debugLines = [];
    function logDebug(msg) {
      const debugEl = document.getElementById("debugLog");
      const ts = new Date().toISOString().split("T")[1].split(".")[0];
      debugLines.unshift("[" + ts + "] " + msg);
      if (debugLines.length > 140) debugLines.pop();
      if (debugEl) {
        debugEl.innerHTML = debugLines.map(line => `<div class="debug-log-line">${line}</div>`).join("");
      }
    }

    window.addEventListener("error", (event) => {
      logDebug("JS ERROR: " + event.message);
      const overlay = document.getElementById("threeOverlay");
      if (overlay) overlay.textContent = "JS ERROR: " + event.message;
    });

    logDebug("Three ESM loaded: " + (THREE ? "YES" : "NO") + " | GLTFLoader: " + (GLTFLoader ? "YES" : "NO"));

    const threeContainer = document.getElementById("threeViewport");
    const gridEl = document.getElementById("grid");
    const overlay = document.getElementById("threeOverlay");

    const tileTypeSelect = document.getElementById("tileTypeSelect");
    const layerSelectEl = document.getElementById("layerSelect");
    const orientationButtonsEl = document.getElementById("orientationButtons");
    const showArrowsCheckbox = document.getElementById("showArrowsCheckbox");
    const assetPanelEl = document.getElementById("assetPanel");
    const reload3DBtn = document.getElementById("reload3DBtn");

    const toolSelectEl = document.getElementById("toolSelect");
    const clearPathBtn = document.getElementById("clearPathBtn");
    const alignToPathCheckbox = document.getElementById("alignToPathCheckbox");
    const gridContainerEl = document.getElementById("gridContainer");
    const pathSvgEl = document.getElementById("pathSvg");

    const importJsonBtn = document.getElementById("importJsonBtn");
    const importJsonInput = document.getElementById("importJsonInput");
    const presetMapSelect = document.getElementById("presetMapSelect");

    const coordValueEl = document.getElementById("coordValue");
    const tileValueEl = document.getElementById("tileValue");
    const orientationValueEl = document.getElementById("orientationValue");
    const selectionCountValueEl = document.getElementById("selectionCountValue");
    const selectionControlsEl = document.getElementById("selectionControls");

    const rotationInputEl = document.getElementById("rotationInput");
    const scaleXInputEl = document.getElementById("scaleXInput");
    const scaleYInputEl = document.getElementById("scaleYInput");
    const scaleZInputEl = document.getElementById("scaleZInput");
    const offsetXInputEl = document.getElementById("offsetXInput");
    const offsetYInputEl = document.getElementById("offsetYInput");
    const deleteTileBtn = document.getElementById("deleteTileBtn");

    const camRotXInput = document.getElementById("camRotX");
    const camRotYInput = document.getElementById("camRotY");
    const camDistanceInput = document.getElementById("camDistance");

    const generateJsonBtn = document.getElementById("generateJsonBtn");
    const downloadJsonBtn = document.getElementById("downloadJsonBtn");
    const jsonOutputEl = document.getElementById("jsonOutput");

    const ROWS = 20;
    const COLS = 20;
    const CELL_SIZE = 1;
    const HALF_ROWS = (ROWS - 1) / 2;
    const HALF_COLS = (COLS - 1) / 2;

    const LAYERS = { GROUND: "ground", STRUCTURE: "structure", DECORATION: "decoration" };
    const LAYER_ORDER = [LAYERS.GROUND, LAYERS.STRUCTURE, LAYERS.DECORATION];

    // --- ASSET DEFINITIONS (with forwardOffsetDeg + extraConfig) ---
    const SEGMENT_ASSETS = [
      {
        id: "road",
        label: "Road",
        layer: LAYERS.GROUND,
        colorVar: "--road-color",
        gltfPath: "assets/3D/ground_segments/roadsegment.gltf",
        baseScale: { x: 0.25, y: 0.25, z: 0.25 },
        yOffset: 0,
        forwardOffsetDeg: 0,
        gltfTemplate: null,
        gltfFileName: "roadsegment.gltf",
        instanceDefaults: { orientation: 0, scaleX: 1, scaleY: 1, scaleZ: 1, offsetX: 0, offsetY: 0 },
        extraConfig: { rotationX: -90 }
      },
      {
        id: "sidewalk",
        label: "Sidewalk",
        layer: LAYERS.GROUND,
        colorVar: "--sidewalk-color",
        gltfPath: "assets/3D/ground_segments/blocksegment.gltf",
        baseScale: { x: 0.25, y: 0.25, z: 0.25 },
        yOffset: 0.02,
        forwardOffsetDeg: 0,
        gltfTemplate: null,
        gltfFileName: "blocksegment.gltf",
        instanceDefaults: { orientation: 0, scaleX: 1, scaleY: 1, scaleZ: 1, offsetX: 0, offsetY: 0 },
        extraConfig: { rotationX: -90 }
      }
    ];

    const STRUCTURE_ASSETS = [
      {
        id: "tower",
        label: "Tower",
        layer: LAYERS.STRUCTURE,
        colorVar: "--tower-color",
        gltfPath: "assets/3D/structures/tower_commercial3D_t.gltf",
        baseScale: { x: 0.2, y: 0.2, z: 0.2 },
        yOffset: 0.12,          // vertical offset above ground segments
        forwardOffsetDeg: 0,    // per-asset yaw offset (deg)
        gltfTemplate: null,
        gltfFileName: "tower_commercial3D_t.gltf",
        instanceDefaults: { orientation: 0, scaleX: 1, scaleY: 1, scaleZ: 1, offsetX: 0, offsetY: 0 },
        extraConfig: { rotationX: 90 }
      }
    ];

    const DECORATION_ASSETS = [
      {
        id: "decor_pylon",
        label: "Decor: Pylon",
        layer: LAYERS.DECORATION,
        colorVar: "--tower-color",
        baseScale: { x: 0.4, y: 0.8, z: 0.4 },
        yOffset: 0.0,
        forwardOffsetDeg: 0,
        gltfTemplate: null,
        gltfFileName: null,
        instanceDefaults: { orientation: 0, scaleX: 1, scaleY: 1, scaleZ: 1, offsetX: 0, offsetY: 0 },
        extraConfig: {}
      }
    ];

    const ALL_ASSETS = [...SEGMENT_ASSETS, ...STRUCTURE_ASSETS, ...DECORATION_ASSETS];

    function getAssetsForLayer(layer) {
      if (layer === LAYERS.GROUND) return SEGMENT_ASSETS;
      if (layer === LAYERS.STRUCTURE) return STRUCTURE_ASSETS;
      if (layer === LAYERS.DECORATION) return DECORATION_ASSETS;
      return [];
    }
    function getAssetById(id) {
      return ALL_ASSETS.find(a => a.id === id) || null;
    }

    // --- GRID STATE PER LAYER ---
    const layerStates = {};
    for (const layer of LAYER_ORDER) {
      const rows = [];
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          row.push({
            type: null,
            orientation: 0,
            scaleX: 1,
            scaleY: 1,
            scaleZ: 1,
            offsetX: 0,
            offsetY: 0
          });
        }
        rows.push(row);
      }
      layerStates[layer] = rows;
    }

    let activeLayer = LAYERS.STRUCTURE;
    let currentTileType = STRUCTURE_ASSETS[0].id;
    let brushOrientationDeg = 0;
    let showArrows = true;

    // Gameplay path: defines the side-scroller axis your game uses for camera/sprite orientation.
    // start/end are grid coords; alignment rotates the 3D world so the path becomes +X.
    let activeTool = "paint"; // "paint" | "pathStart" | "pathEnd"
    let gameplayPath = { start: null, end: null }; // where used: export/import + 2D/3D overlays
    let alignWorldToPath = true; // where used: worldRoot rotation

    let selectedPrimary = { row: null, col: null };
    let selectionSet = new Set();
    let isDraggingSelection = false;
    let dragStart = null;

    let cameraRotX = Number(camRotXInput.value) || 55;
    let cameraRotY = Number(camRotYInput.value) || 35;
    let cameraDistance = Number(camDistanceInput.value) || 40;

    const gltfLoader = new GLTFLoader();

    function getActiveGridState() { return layerStates[activeLayer]; }
    function getCellState(row, col) { return getActiveGridState()[row][col]; }

    function normalizeAngle(deg) { let d = Number(deg) || 0; d %= 360; if (d < 0) d += 360; return d; }
    function sanitizeScale(value, fallback) { let v = Number(value); if (!isFinite(v)) return fallback; if (v === 0) v = 0.01; return v; }
    function sanitizeOffset(value) { let v = Number(value); if (!isFinite(v)) return 0; return v; }
    function cellToWorld(row, col) { return { x: (col - HALF_COLS) * CELL_SIZE, z: (row - HALF_ROWS) * CELL_SIZE }; }

    function clampCoord(v, max) { const n = Number(v); if (!isFinite(n)) return 0; return Math.min(Math.max(Math.round(n), 0), max - 1); }
    function isValidCoord(p) { return p && isFinite(p.row) && isFinite(p.col) && p.row >= 0 && p.row < ROWS && p.col >= 0 && p.col < COLS; }

    function getPathYawRad() {
      if (!gameplayPath.start || !gameplayPath.end) return 0;
      const a = cellToWorld(gameplayPath.start.row, gameplayPath.start.col);
      const b = cellToWorld(gameplayPath.end.row, gameplayPath.end.col);
      const dx = b.x - a.x;
      const dz = b.z - a.z;
      const len = Math.hypot(dx, dz);
      if (len < 1e-6) return 0;
      return Math.atan2(dz, dx); // yaw of path direction in XZ plane
    }

    function setActiveTool(tool) {
      activeTool = tool;
      if (toolSelectEl) toolSelectEl.value = tool;
      logDebug("Tool set: " + tool);
    }

    function setGameplayPathPoint(kind, row, col) {
      const p = { row: clampCoord(row, ROWS), col: clampCoord(col, COLS) };
      if (kind === "start") gameplayPath.start = p;
      if (kind === "end") gameplayPath.end = p;

      updateGameplayPath2D();
      rebuildGameplayPath3D();
      applyWorldAlignmentFromPath();

      const yawDeg = Math.round(THREE.MathUtils.radToDeg(getPathYawRad()));
      logDebug(`Gameplay path ${kind} set: (${p.row},${p.col}) | yaw≈${yawDeg}°`);
    }

    function clearGameplayPath() {
      gameplayPath = { start: null, end: null };
      updateGameplayPath2D();
      rebuildGameplayPath3D();
      applyWorldAlignmentFromPath();
      logDebug("Gameplay path cleared.");
    }

    function updateGameplayPath2D() {
      // Cell outlines
      gridEl.querySelectorAll(".cell.path-start").forEach(el => el.classList.remove("path-start"));
      gridEl.querySelectorAll(".cell.path-end").forEach(el => el.classList.remove("path-end"));

      if (gameplayPath.start) {
        const el = getCellElement(gameplayPath.start.row, gameplayPath.start.col);
        if (el) el.classList.add("path-start");
      }
      if (gameplayPath.end) {
        const el = getCellElement(gameplayPath.end.row, gameplayPath.end.col);
        if (el) el.classList.add("path-end");
      }

      // SVG line + endpoint dots
      if (!pathSvgEl || !gridContainerEl) return;

      const rect = gridContainerEl.getBoundingClientRect();
      const w = Math.max(rect.width, 1);
      const h = Math.max(rect.height, 1);
      pathSvgEl.setAttribute("viewBox", `0 0 ${w} ${h}`);
      pathSvgEl.setAttribute("width", String(w));
      pathSvgEl.setAttribute("height", String(h));

      // Clear existing
      while (pathSvgEl.firstChild) pathSvgEl.removeChild(pathSvgEl.firstChild);

      if (!gameplayPath.start && !gameplayPath.end) return;

      function cellCenterPx(p) {
        const cellEl = getCellElement(p.row, p.col);
        if (!cellEl) return null;
        const cr = cellEl.getBoundingClientRect();
        return {
          x: (cr.left - rect.left) + cr.width / 2,
          y: (cr.top - rect.top) + cr.height / 2
        };
      }

      const s = gameplayPath.start ? cellCenterPx(gameplayPath.start) : null;
      const e = gameplayPath.end ? cellCenterPx(gameplayPath.end) : null;

      if (s && e) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", String(s.x));
        line.setAttribute("y1", String(s.y));
        line.setAttribute("x2", String(e.x));
        line.setAttribute("y2", String(e.y));
        line.setAttribute("class", "path-line");
        pathSvgEl.appendChild(line);
      }

      function addDot(pt, cls) {
        if (!pt) return;
        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        dot.setAttribute("cx", String(pt.x));
        dot.setAttribute("cy", String(pt.y));
        dot.setAttribute("r", "7");
        dot.setAttribute("class", `path-point ${cls}`);
        pathSvgEl.appendChild(dot);
      }

      addDot(s, "start");
      addDot(e, "end");
    }

    function getColorForAsset(assetId) {
      const asset = getAssetById(assetId);
      if (!asset) return "#9ca3af";
      const cs = getComputedStyle(document.documentElement);
      return cs.getPropertyValue(asset.colorVar).trim() || "#9ca3af";
    }

    function getBrushDefaultsForAsset(assetId) {
      const a = getAssetById(assetId);
      return a ? a.instanceDefaults : null;
    }
    function setBrushDefaultsFromState(assetId, state) {
      const a = getAssetById(assetId);
      if (!a) return;
      a.instanceDefaults = {
        orientation: state.orientation,
        scaleX: state.scaleX,
        scaleY: state.scaleY,
        scaleZ: state.scaleZ,
        offsetX: state.offsetX,
        offsetY: state.offsetY
      };
      brushOrientationDeg = state.orientation;
    }

    // --- 2D GRID DOM ---
    function createGridDom() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = String(r);
          cell.dataset.col = String(c);
          cell.addEventListener("click", onCellClick);
          gridEl.appendChild(cell);
        }
      }
      logDebug("2D grid created: " + ROWS + " x " + COLS);
    }
    function getCellElement(row, col) {
      return gridEl.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }

    function clearSelectionVisuals() {
      gridEl.querySelectorAll(".cell.selected-primary").forEach(el => el.classList.remove("selected-primary"));
      gridEl.querySelectorAll(".cell.selected-group").forEach(el => el.classList.remove("selected-group"));
    }
    function applySelectionVisuals() {
      clearSelectionVisuals();
      selectionSet.forEach(key => {
        const [r, c] = key.split(",").map(Number);
        const el = getCellElement(r, c);
        if (el) el.classList.add("selected-group");
      });
      if (selectedPrimary.row !== null && selectedPrimary.col !== null) {
        const el = getCellElement(selectedPrimary.row, selectedPrimary.col);
        if (el) el.classList.add("selected-primary");
      }
    }
    function setSingleSelection(row, col) {
      selectionSet.clear();
      selectionSet.add(row + "," + col);
      selectedPrimary = { row, col };
      applySelectionVisuals();
      updateSelectionInfo();
    }
    function setRectSelection(sr, sc, er, ec) {
      selectionSet.clear();
      const minR = Math.min(sr, er), maxR = Math.max(sr, er);
      const minC = Math.min(sc, ec), maxC = Math.max(sc, ec);
      for (let r = minR; r <= maxR; r++) for (let c = minC; c <= maxC; c++) selectionSet.add(r + "," + c);
      selectedPrimary = { row: minR, col: minC };
      applySelectionVisuals();
      updateSelectionInfo();
    }

    function renderCell2D(row, col) {
      const state = getCellState(row, col);
      const el = getCellElement(row, col);
      if (!el) return;

      el.querySelector(".triangle")?.remove();
      el.querySelector(".y-label")?.remove();
      if (!state.type) return;

      const angle = normalizeAngle(state.orientation);
      const sx = sanitizeScale(state.scaleX, 1);
      const sz = sanitizeScale(state.scaleZ, 1);
      const color = getColorForAsset(state.type);

      if (showArrows) {
        const wrap = document.createElement("div");
        wrap.className = "triangle";
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("viewBox", "0 0 100 100");
        svg.setAttribute("class", "triangle-svg");
        const poly = document.createElementNS(svgNS, "polygon");
        poly.setAttribute("points", "50,0 0,100 100,100");
        poly.setAttribute("fill", color);
        poly.setAttribute("stroke", "black");
        poly.setAttribute("stroke-width", "4");
        poly.setAttribute("vector-effect", "non-scaling-stroke");
        svg.appendChild(poly);
        wrap.appendChild(svg);
        wrap.style.transform = `translate(-50%, -50%) rotate(${angle}deg) scale(${sx},${sz})`;
        el.appendChild(wrap);
      }

      const yLabel = document.createElement("div");
      yLabel.className = "y-label";
      yLabel.textContent = Number(state.scaleY).toFixed(2);
      el.appendChild(yLabel);
    }
    function renderAllCells2D() {
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) renderCell2D(r, c);
      applySelectionVisuals();
    }

    function updateSelectionInfo() {
      const count = selectionSet.size;
      selectionCountValueEl.textContent = String(count);

      if (!count) {
        coordValueEl.textContent = "none";
        tileValueEl.textContent = "—";
        orientationValueEl.textContent = "—";
        selectionControlsEl.style.display = "none";
        deleteTileBtn.disabled = true;
        return;
      }

      coordValueEl.textContent = `row ${selectedPrimary.row}, col ${selectedPrimary.col}`;

      const primaryState = getCellState(selectedPrimary.row, selectedPrimary.col);
      tileValueEl.textContent = primaryState.type || "empty";

      if (primaryState.type) {
        const angle = normalizeAngle(primaryState.orientation);
        orientationValueEl.textContent = angle + "°";
        selectionControlsEl.style.display = "block";
        deleteTileBtn.disabled = false;

        rotationInputEl.value = angle;
        scaleXInputEl.value = primaryState.scaleX;
        scaleYInputEl.value = primaryState.scaleY;
        scaleZInputEl.value = primaryState.scaleZ;
        offsetXInputEl.value = primaryState.offsetX;
        offsetYInputEl.value = primaryState.offsetY;
      } else {
        orientationValueEl.textContent = "—";
        selectionControlsEl.style.display = "none";
        deleteTileBtn.disabled = true;
      }
    }

    function populateTileSelectForLayer(layer) {
      const assets = getAssetsForLayer(layer);
      tileTypeSelect.innerHTML = "";
      for (const a of assets) {
        const opt = document.createElement("option");
        opt.value = a.id;
        opt.textContent = a.label;
        tileTypeSelect.appendChild(opt);
      }
      const erase = document.createElement("option");
      erase.value = "empty";
      erase.textContent = "Erase";
      tileTypeSelect.appendChild(erase);

      if (assets.some(a => a.id === currentTileType)) {
        tileTypeSelect.value = currentTileType;
      } else {
        currentTileType = assets[0]?.id || "empty";
        tileTypeSelect.value = currentTileType;
      }
    }

    function normalizeGltfSceneToUnit(scene, assetLabel) {
      const box = new THREE.Box3().setFromObject(scene);
      const size = new THREE.Vector3();
      box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim === 0) {
        logDebug("GLTF normalize: " + assetLabel + " zero-size; leaving as-is.");
        return;
      }
      const s = 1 / maxDim;
      scene.scale.multiplyScalar(s);

      const box2 = new THREE.Box3().setFromObject(scene);
      const center = new THREE.Vector3();
      box2.getCenter(center);
      scene.position.x -= center.x;
      scene.position.z -= center.z;
      scene.position.y -= box2.min.y;

      logDebug("GLTF normalized: " + assetLabel + " maxDim=" + maxDim.toFixed(3) + " scale=" + s.toFixed(3));
    }

    function loadGltfForAsset(asset, file) {
      const url = URL.createObjectURL(file);
      asset.gltfFileName = file.name;

      logDebug("Loading model for " + asset.label + ": " + file.name);

      gltfLoader.load(
        url,
        (gltf) => {
          const root = gltf.scene;
          normalizeGltfSceneToUnit(root, asset.label);
          root.traverse(n => {
            if (n.isMesh) {
              n.castShadow = true;
              n.receiveShadow = true;
            }
          });
          asset.gltfTemplate = root;
          logDebug("Model loaded OK for " + asset.label + " (template set).");
          rebuildAssetPanel();
          rebuild3DFromState();
        },
        undefined,
        (err) => {
          logDebug("Model load ERROR for " + asset.label + ": " + (err?.message || String(err)));
        }
      );
    }

    function loadGltfFromPath(asset, path) {
      logDebug("Auto-loading model for " + asset.label + ": " + path);

      gltfLoader.load(
        path,
        (gltf) => {
          const root = gltf.scene;
          normalizeGltfSceneToUnit(root, asset.label);

          // Apply X-axis rotation if specified in extraConfig
          if (asset.extraConfig && typeof asset.extraConfig.rotationX === "number") {
            const rotX = THREE.MathUtils.degToRad(asset.extraConfig.rotationX);
            root.rotation.x = rotX;
            logDebug("Applied X-rotation: " + asset.extraConfig.rotationX + "° for " + asset.label);
          }

          root.traverse(n => {
            if (n.isMesh) {
              n.castShadow = true;
              n.receiveShadow = true;
            }
          });
          asset.gltfTemplate = root;
          logDebug("Model auto-loaded OK for " + asset.label);
          rebuildAssetPanel();
          rebuild3DFromState();
        },
        undefined,
        (err) => {
          logDebug("Model auto-load ERROR for " + asset.label + ": " + (err?.message || String(err)));
        }
      );
    }

    function autoLoadAssetModels() {
      logDebug("Auto-loading asset models from paths...");
      ALL_ASSETS.forEach(asset => {
        if (asset.gltfPath) {
          loadGltfFromPath(asset, asset.gltfPath);
        }
      });
    }

    // Per-asset config JSON
    function applyAssetConfigFromJson(asset, cfg) {
      if (!cfg || typeof cfg !== "object") return;

      if (cfg.baseScale && typeof cfg.baseScale === "object") {
        const bs = cfg.baseScale;
        asset.baseScale = {
          x: Number(bs.x ?? asset.baseScale.x),
          y: Number(bs.y ?? asset.baseScale.y),
          z: Number(bs.z ?? asset.baseScale.z)
        };
      }

      if (typeof cfg.yOffset === "number") {
        asset.yOffset = cfg.yOffset;
      }

      if (typeof cfg.forwardOffsetDeg === "number") {
        asset.forwardOffsetDeg = cfg.forwardOffsetDeg;
      }

      if (cfg.instanceDefaults && typeof cfg.instanceDefaults === "object") {
        const d = cfg.instanceDefaults;
        asset.instanceDefaults = {
          orientation: Number(d.orientation ?? asset.instanceDefaults.orientation),
          scaleX: Number(d.scaleX ?? asset.instanceDefaults.scaleX),
          scaleY: Number(d.scaleY ?? asset.instanceDefaults.scaleY),
          scaleZ: Number(d.scaleZ ?? asset.instanceDefaults.scaleZ),
          offsetX: Number(d.offsetX ?? asset.instanceDefaults.offsetX),
          offsetY: Number(d.offsetY ?? asset.instanceDefaults.offsetY)
        };
      }

      if (cfg.extra && typeof cfg.extra === "object") {
        asset.extraConfig = cfg.extra;
      }

      logDebug("Asset config applied: " + asset.label);
    }

    function rebuildAssetPanel() {
      const assets = getAssetsForLayer(activeLayer);
      assetPanelEl.innerHTML = "";

      assets.forEach(asset => {
        const row = document.createElement("div");
        row.className = "asset-row";

        const nameSpan = document.createElement("span");
        nameSpan.className = "asset-name";
        nameSpan.textContent = asset.label;

        const uploadBtn = document.createElement("button");
        uploadBtn.className = "asset-upload-btn";
        uploadBtn.textContent = "GLTF/GLB";
        uploadBtn.type = "button";

        const configBtn = document.createElement("button");
        configBtn.className = "asset-config-btn";
        configBtn.textContent = "Config";
        configBtn.type = "button";

        const status = document.createElement("span");
        status.className = "asset-status";

        if (asset.gltfTemplate) {
          status.textContent = asset.gltfFileName || "Model loaded";
          status.classList.add("loaded");
        } else if (asset.gltfFileName) {
          status.textContent = asset.gltfFileName + " (re-upload needed)";
          status.classList.add("missing");
        } else {
          status.textContent = "Placeholder; use GLTF/GLB + JSON config if needed";
          status.classList.add("placeholder");
        }

        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".gltf,.glb";
        fileInput.style.display = "none";

        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          loadGltfForAsset(asset, file);
        });

        const configInput = document.createElement("input");
        configInput.type = "file";
        configInput.accept = ".json";
        configInput.style.display = "none";

        configBtn.addEventListener("click", () => configInput.click());
        configInput.addEventListener("change", (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const text = String(reader.result || "");
              const cfg = JSON.parse(text);
              applyAssetConfigFromJson(asset, cfg);
              rebuildAssetPanel();
              rebuild3DFromState();
            } catch (err) {
              logDebug("Config JSON ERROR for " + asset.label + ": " + (err?.message || String(err)));
            }
          };
          reader.readAsText(file);
        });

        row.appendChild(nameSpan);
        row.appendChild(uploadBtn);
        row.appendChild(configBtn);
        row.appendChild(status);
        row.appendChild(fileInput);
        row.appendChild(configInput);
        assetPanelEl.appendChild(row);
      });
    }

    // --- THREE SETUP ---
    let scene, camera, renderer;
    let worldRoot, pathGroup; // where used: rotate whole world to gameplayPath
    let groundGroup, structureGroup, decorationGroup;
    let roadMat, sidewalkMat, segmentFallbackMat, structureFallbackMat, decoFallbackMat;
    let boxGeom, decoGeom;

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);

      worldRoot = new THREE.Group();
      scene.add(worldRoot);

      const w = Math.max(threeContainer.clientWidth || 400, 200);
      const h = Math.max(threeContainer.clientHeight || 260, 150);

      camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 500);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(w, h);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      threeContainer.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x0b1120, 0.9);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.1);
      dir.position.set(25, 40, 15);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024, 1024);
      dir.shadow.camera.near = 5;
      dir.shadow.camera.far = 150;
      dir.shadow.camera.left = -50;
      dir.shadow.camera.right = 50;
      dir.shadow.camera.top = 50;
      dir.shadow.camera.bottom = -50;
      scene.add(dir);

      const groundSize = CELL_SIZE * Math.max(ROWS, COLS) + 4;
      const groundPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        new THREE.MeshStandardMaterial({ color: 0x020617, roughness: 1, metalness: 0 })
      );
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.receiveShadow = true;
      worldRoot.add(groundPlane);

      worldRoot.add(new THREE.GridHelper(CELL_SIZE * ROWS, ROWS, 0x94a3b8, 0x1f2937));
      const axes = new THREE.AxesHelper(5);
      axes.position.y = 0.05;
      scene.add(axes);

      groundGroup = new THREE.Group();
      structureGroup = new THREE.Group();
      decorationGroup = new THREE.Group();
      pathGroup = new THREE.Group();
      worldRoot.add(groundGroup, structureGroup, decorationGroup, pathGroup);

      roadMat = new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness: 0.7 });
      sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.8 });
      segmentFallbackMat = new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.9 });
      structureFallbackMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.45, metalness: 0.15, emissive: 0x1d4ed8, emissiveIntensity: 0.12 });
      decoFallbackMat = new THREE.MeshStandardMaterial({ color: 0xf97316, roughness: 0.7, emissive: 0x9a3412, emissiveIntensity: 0.35 });

      boxGeom = new THREE.BoxGeometry(1, 1, 1);
      decoGeom = new THREE.SphereGeometry(0.2 * CELL_SIZE, 16, 16);

      const test = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.5, 0.5),
        new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x16a34a, emissiveIntensity: 0.35 })
      );
      test.position.set(0, 0.25, 0);
      test.castShadow = true;
      scene.add(test);

      window.addEventListener("resize", () => {
        const ww = Math.max(threeContainer.clientWidth || 400, 200);
        const hh = Math.max(threeContainer.clientHeight || 260, 150);
        camera.aspect = ww / hh;
        camera.updateProjectionMatrix();
        renderer.setSize(ww, hh);
      });

      updateCameraFromState();
      animate();
      logDebug("3D initialized (renderer + lights + helpers).");
    }

    function updateCameraFromState() {
      const theta = THREE.MathUtils.degToRad(cameraRotY);
      const phi = THREE.MathUtils.degToRad(cameraRotX);
      const r = cameraDistance;

      const x = r * Math.cos(phi) * Math.sin(theta);
      const y = r * Math.sin(phi);
      const z = r * Math.cos(phi) * Math.cos(theta);

      camera.position.set(x, y, z);
      camera.lookAt(0, 0, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function clearGroup(group) { while (group.children.length) group.remove(group.children[0]); }

    function applyWorldAlignmentFromPath() {
      if (!worldRoot) return;
      if (!alignWorldToPath || !gameplayPath.start || !gameplayPath.end) {
        worldRoot.rotation.y = 0;
        return;
      }
      worldRoot.rotation.y = -getPathYawRad(); // rotate world so path aligns to +X
    }

    function rebuildGameplayPath3D() {
      if (!pathGroup) return;
      clearGroup(pathGroup);

      if (!gameplayPath.start && !gameplayPath.end) return;

      const mat = new THREE.LineBasicMaterial({ color: 0xfbbf24 });
      const startMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x16a34a, emissiveIntensity: 0.25 });
      const endMat = new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0xb91c1c, emissiveIntensity: 0.25 });
      const markerGeom = new THREE.SphereGeometry(0.12, 14, 14);

      function markerAt(p, material) {
        const { x, z } = cellToWorld(p.row, p.col);
        const m = new THREE.Mesh(markerGeom, material);
        m.position.set(x, 0.18, z);
        m.castShadow = false;
        m.receiveShadow = true;
        pathGroup.add(m);
        return { x, z };
      }

      let a = null, b = null;
      if (gameplayPath.start) a = markerAt(gameplayPath.start, startMat);
      if (gameplayPath.end) b = markerAt(gameplayPath.end, endMat);

      if (a && b) {
        const points = [new THREE.Vector3(a.x, 0.18, a.z), new THREE.Vector3(b.x, 0.18, b.z)];
        const geom = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geom, mat);
        pathGroup.add(line);
      }
    }

    function rebuild3DFromState() {
      clearGroup(groundGroup);
      clearGroup(structureGroup);
      clearGroup(decorationGroup);

      let groundCount = 0, structCount = 0, decoCount = 0;

      // Ground segments (3D volumes; thickness via baseScale.y)
      const groundState = layerStates[LAYERS.GROUND];
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
        const cell = groundState[r][c];
        if (!cell.type) continue;
        const asset = getAssetById(cell.type);
        if (!asset) continue;

        const { x, z } = cellToWorld(r, c);
        const mat = cell.type === "road" ? roadMat :
                    cell.type === "sidewalk" ? sidewalkMat :
                    segmentFallbackMat;

        let obj;
        if (asset.gltfTemplate) {
          obj = asset.gltfTemplate.clone(true);
          obj.traverse(n => { if (n.isMesh) { n.castShadow = false; n.receiveShadow = true; } });
        } else {
          obj = new THREE.Mesh(boxGeom, mat);
        }

        obj.position.set(x, asset.baseScale.y * 0.5 + asset.yOffset, z);
        obj.scale.set(asset.baseScale.x, asset.baseScale.y, asset.baseScale.z);
        obj.receiveShadow = true;
        groundGroup.add(obj);
        groundCount++;
      }

      // Structures (3D with per-instance scale/rotation/offset + per-asset vertical offset)
      const structState = layerStates[LAYERS.STRUCTURE];
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
        const cell = structState[r][c];
        if (!cell.type) continue;
        const asset = getAssetById(cell.type);
        if (!asset) continue;

        const { x, z } = cellToWorld(r, c);
        const sx = sanitizeScale(cell.scaleX, 1);
        const sy = sanitizeScale(cell.scaleY, 1);
        const sz = sanitizeScale(cell.scaleZ, 1);
        const offX = sanitizeOffset(cell.offsetX);
        const offZ = sanitizeOffset(cell.offsetY);

        const yawDeg = (cell.orientation || 0) + (asset.forwardOffsetDeg || 0);
        const angle = THREE.MathUtils.degToRad(yawDeg);

        let obj;
        if (asset.gltfTemplate) {
          obj = asset.gltfTemplate.clone(true);
          obj.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
        } else {
          obj = new THREE.Mesh(boxGeom, structureFallbackMat);
          obj.castShadow = true;
        }

        const baseX = asset.baseScale.x;
        const baseY = asset.baseScale.y;
        const baseZ = asset.baseScale.z;

        obj.scale.set(baseX * sx, baseY * sy, baseZ * sz);
        obj.rotation.y = angle;
        obj.position.set(
          x + offX,
          (baseY * sy) * 0.5 + asset.yOffset,
          z + offZ
        );

        structureGroup.add(obj);
        structCount++;
      }

      // Decorations (simple fallback spheres for now)
      const decoState = layerStates[LAYERS.DECORATION];
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
        const cell = decoState[r][c];
        if (!cell.type) continue;
        const { x, z } = cellToWorld(r, c);
        const sx = sanitizeScale(cell.scaleX, 0.8);
        const sy = sanitizeScale(cell.scaleY, 0.8);
        const sz = sanitizeScale(cell.scaleZ, 0.8);
        const offX = sanitizeOffset(cell.offsetX);
        const offZ = sanitizeOffset(cell.offsetY);

        const deco = new THREE.Mesh(decoGeom, decoFallbackMat);
        deco.position.set(x + offX, 0.2 * sy + 0.1, z + offZ);
        deco.scale.set(sx, sy, sz);
        deco.castShadow = true;
        decorationGroup.add(deco);
        decoCount++;
      }

      rebuildGameplayPath3D();
      applyWorldAlignmentFromPath();

      logDebug(`3D rebuilt: ground=${groundCount}, structures=${structCount}, decorations=${decoCount}`);
    }

    // --- PAINTING / CLICK ---
    function onCellClick(e) {
      const el = e.currentTarget;
      const row = Number(el.dataset.row);
      const col = Number(el.dataset.col);
      const state = getCellState(row, col);

      // Tool modes: define gameplay path without painting.
      if (activeTool === "pathStart") {
        setGameplayPathPoint("start", row, col);
        setSingleSelection(row, col);
        setActiveTool("paint");
        return;
      }
      if (activeTool === "pathEnd") {
        setGameplayPathPoint("end", row, col);
        setSingleSelection(row, col);
        setActiveTool("paint");
        return;
      }

      if (currentTileType === "empty") {
        state.type = null;
        renderCell2D(row, col);
        rebuild3DFromState();
        setSingleSelection(row, col);
        logDebug(`Erase (${row},${col}) layer=${activeLayer}`);
        return;
      }

      if (state.type === null) {
        const defaults = getBrushDefaultsForAsset(currentTileType);
        state.type = currentTileType;
        if (defaults) {
          Object.assign(state, defaults);
        } else {
          state.orientation = normalizeAngle(brushOrientationDeg);
          state.scaleX = state.scaleY = state.scaleZ = 1;
          state.offsetX = state.offsetY = 0;
        }
        renderCell2D(row, col);
        rebuild3DFromState();
        setSingleSelection(row, col);
        logDebug(`Paint ${state.type} at (${row},${col}) layer=${activeLayer}`);
      } else if (state.type !== currentTileType) {
        const prev = state.type;
        state.type = currentTileType;
        renderCell2D(row, col);
        rebuild3DFromState();
        setSingleSelection(row, col);
        logDebug(`Change ${prev} -> ${state.type} at (${row},${col}) layer=${activeLayer}`);
      } else {
        setSingleSelection(row, col);
        logDebug(`Select ${state.type} at (${row},${col}) layer=${activeLayer}`);
      }
    }

    function applySelectionControls() {
      if (!selectionSet.size) return;

      const primaryState = getCellState(selectedPrimary.row, selectedPrimary.col);
      const tileType = primaryState.type || null;

      selectionSet.forEach(key => {
        const [r, c] = key.split(",").map(Number);
        const st = getCellState(r, c);
        if (!st.type) return;

        st.orientation = normalizeAngle(rotationInputEl.value);
        st.scaleX = sanitizeScale(scaleXInputEl.value, 1);
        st.scaleY = sanitizeScale(scaleYInputEl.value, 1);
        st.scaleZ = sanitizeScale(scaleZInputEl.value, 1);
        st.offsetX = sanitizeOffset(offsetXInputEl.value);
        st.offsetY = sanitizeOffset(offsetYInputEl.value);

        renderCell2D(r, c);
      });

      if (tileType) {
        setBrushDefaultsFromState(tileType, getCellState(selectedPrimary.row, selectedPrimary.col));
      }

      rebuild3DFromState();
      updateSelectionInfo();
      logDebug("Updated selection (" + selectionSet.size + " cells).");
    }

    rotationInputEl.addEventListener("change", applySelectionControls);
    scaleXInputEl.addEventListener("change", applySelectionControls);
    scaleYInputEl.addEventListener("change", applySelectionControls);
    scaleZInputEl.addEventListener("change", applySelectionControls);
    offsetXInputEl.addEventListener("change", applySelectionControls);
    offsetYInputEl.addEventListener("change", applySelectionControls);

    deleteTileBtn.addEventListener("click", () => {
      if (!selectionSet.size) return;
      selectionSet.forEach(key => {
        const [r, c] = key.split(",").map(Number);
        const st = getCellState(r, c);
        st.type = null;
        renderCell2D(r, c);
      });
      rebuild3DFromState();
      updateSelectionInfo();
      logDebug("Deleted tiles in selection (" + selectionSet.size + ") layer=" + activeLayer);
    });

    gridEl.addEventListener("mousedown", (e) => {
      if (activeTool !== "paint") return;
      const cell = e.target.closest(".cell");
      if (!cell) return;
      const row = Number(cell.dataset.row);
      const col = Number(cell.dataset.col);
      isDraggingSelection = true;
      dragStart = { row, col };
      setRectSelection(row, col, row, col);
      e.preventDefault();
    });
    gridEl.addEventListener("mousemove", (e) => {
      if (activeTool !== "paint") return;
      if (!isDraggingSelection) return;
      const cell = e.target.closest(".cell");
      if (!cell) return;
      const row = Number(cell.dataset.row);
      const col = Number(cell.dataset.col);
      setRectSelection(dragStart.row, dragStart.col, row, col);
    });
    document.addEventListener("mouseup", () => { isDraggingSelection = false; dragStart = null; });

    function setBrushOrientation(deg) {
      brushOrientationDeg = deg;
      orientationButtonsEl.querySelectorAll(".orientation-btn").forEach(btn => {
        btn.classList.toggle("active", Number(btn.dataset.orientation) === deg);
      });

      if (selectedPrimary.row !== null && selectedPrimary.col !== null) {
        const st = getCellState(selectedPrimary.row, selectedPrimary.col);
        if (st.type) {
          rotationInputEl.value = deg;
          applySelectionControls();
        }
      }
      logDebug("Brush orientation " + deg + "°");
    }
    orientationButtonsEl.addEventListener("click", (e) => {
      const btn = e.target.closest(".orientation-btn");
      if (!btn) return;
      setBrushOrientation(Number(btn.dataset.orientation) || 0);
    });

    layerSelectEl.addEventListener("change", () => {
      activeLayer = layerSelectEl.value;
      populateTileSelectForLayer(activeLayer);
      rebuildAssetPanel();
      renderAllCells2D();
      updateSelectionInfo();
      rebuild3DFromState();
      logDebug("Active layer: " + activeLayer);
    });

    tileTypeSelect.addEventListener("change", () => {
      currentTileType = tileTypeSelect.value;
      logDebug("Tile brush: " + currentTileType);
    });

    showArrowsCheckbox.addEventListener("change", () => {
      showArrows = showArrowsCheckbox.checked;
      renderAllCells2D();
      logDebug("Arrows " + (showArrows ? "shown" : "hidden"));
    });

    if (toolSelectEl) {
      toolSelectEl.addEventListener("change", () => {
        setActiveTool(toolSelectEl.value);
      });
    }

    if (clearPathBtn) {
      clearPathBtn.addEventListener("click", () => {
        clearGameplayPath();
      });
    }

    if (alignToPathCheckbox) {
      alignToPathCheckbox.addEventListener("change", () => {
        alignWorldToPath = alignToPathCheckbox.checked;
        applyWorldAlignmentFromPath();
        logDebug("Align world to path: " + (alignWorldToPath ? "ON" : "OFF"));
      });
    }

    // Keep 2D overlay aligned on resize / layout changes.
    window.addEventListener("resize", () => {
      updateGameplayPath2D();
    });

    camRotXInput.addEventListener("input", () => { cameraRotX = Number(camRotXInput.value) || 55; updateCameraFromState(); });
    camRotYInput.addEventListener("input", () => { cameraRotY = Number(camRotYInput.value) || 35; updateCameraFromState(); });
    camDistanceInput.addEventListener("input", () => { cameraDistance = Number(camDistanceInput.value) || 40; updateCameraFromState(); });

    reload3DBtn.addEventListener("click", () => {
      logDebug("Manual 3D reload triggered. Reloading models from paths...");
      autoLoadAssetModels();
      rebuild3DFromState();
    });

    // --- MAP JSON EXPORT/IMPORT ---
    function exportSnapshot() {
      return {
        version: 4,
        rows: ROWS,
        cols: COLS,
        activeLayer,
        gameplayPath,
        alignWorldToPath,

        layerStates,
        assets: {
          segments: SEGMENT_ASSETS.map(a => ({
            id: a.id,
            label: a.label,
            baseScale: a.baseScale,
            yOffset: a.yOffset,
            forwardOffsetDeg: a.forwardOffsetDeg || 0,
            gltfFileName: a.gltfFileName || null,
            instanceDefaults: a.instanceDefaults,
            extraConfig: a.extraConfig || {}
          })),
          structures: STRUCTURE_ASSETS.map(a => ({
            id: a.id,
            label: a.label,
            baseScale: a.baseScale,
            yOffset: a.yOffset,
            forwardOffsetDeg: a.forwardOffsetDeg || 0,
            gltfFileName: a.gltfFileName || null,
            instanceDefaults: a.instanceDefaults,
            extraConfig: a.extraConfig || {}
          })),
          decorations: DECORATION_ASSETS.map(a => ({
            id: a.id,
            label: a.label,
            baseScale: a.baseScale,
            yOffset: a.yOffset,
            forwardOffsetDeg: a.forwardOffsetDeg || 0,
            gltfFileName: a.gltfFileName || null,
            instanceDefaults: a.instanceDefaults,
            extraConfig: a.extraConfig || {}
          }))
        }
      };
    }

    function generateJsonText() {
      return JSON.stringify(exportSnapshot(), null, 2);
    }

    generateJsonBtn.addEventListener("click", () => {
      const jsonStr = generateJsonText();
      jsonOutputEl.value = jsonStr;
      logDebug("JSON generated (" + jsonStr.length + " chars)");
    });

    downloadJsonBtn.addEventListener("click", () => {
      let jsonStr = jsonOutputEl.value;
      if (!jsonStr) {
        jsonStr = generateJsonText();
        jsonOutputEl.value = jsonStr;
        logDebug("JSON generated for download (" + jsonStr.length + " chars)");
      }
      const blob = new Blob([jsonStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "map.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      logDebug("JSON downloaded as map.json");
    });

    function applyImportedAssetData(importedAssets) {
      function applyTo(list, incomingList) {
        if (!Array.isArray(incomingList)) return;
        for (const inc of incomingList) {
          const local = list.find(a => a.id === inc.id);
          if (!local) continue;

          if (inc.baseScale) local.baseScale = inc.baseScale;
          if (typeof inc.yOffset === "number") local.yOffset = inc.yOffset;
          if (typeof inc.forwardOffsetDeg === "number") local.forwardOffsetDeg = inc.forwardOffsetDeg;
          if (inc.instanceDefaults) local.instanceDefaults = inc.instanceDefaults;
          if (inc.extraConfig) local.extraConfig = inc.extraConfig;
          if (inc.gltfFileName) local.gltfFileName = inc.gltfFileName;

          local.gltfTemplate = null; // must re-upload models
        }
      }
      applyTo(SEGMENT_ASSETS, importedAssets?.segments);
      applyTo(STRUCTURE_ASSETS, importedAssets?.structures);
      applyTo(DECORATION_ASSETS, importedAssets?.decorations);
    }

    function applyImportedState(data) {
      try {
        if (!data || typeof data !== "object") throw new Error("Invalid JSON root");

        if (data.layerStates && typeof data.layerStates === "object") {
          for (const layer of LAYER_ORDER) {
            if (Array.isArray(data.layerStates[layer])) {
              for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                const incoming = data.layerStates[layer]?.[r]?.[c];
                if (incoming && typeof incoming === "object") {
                  layerStates[layer][r][c] = {
                    type: incoming.type ?? null,
                    orientation: Number(incoming.orientation ?? 0),
                    scaleX: Number(incoming.scaleX ?? 1),
                    scaleY: Number(incoming.scaleY ?? 1),
                    scaleZ: Number(incoming.scaleZ ?? 1),
                    offsetX: Number(incoming.offsetX ?? 0),
                    offsetY: Number(incoming.offsetY ?? 0)
                  };
                } else {
                  layerStates[layer][r][c] = { type: null, orientation: 0, scaleX: 1, scaleY: 1, scaleZ: 1, offsetX: 0, offsetY: 0 };
                }
              }
            }
          }
        }

        if (data.assets) applyImportedAssetData(data.assets);

        if (data.activeLayer && LAYER_ORDER.includes(data.activeLayer)) {
          activeLayer = data.activeLayer;
          layerSelectEl.value = activeLayer;
        }

        // Gameplay path import
        if (data.gameplayPath && typeof data.gameplayPath === "object") {
          const s = data.gameplayPath.start;
          const e = data.gameplayPath.end;
          gameplayPath = {
            start: (s && isFinite(s.row) && isFinite(s.col)) ? { row: clampCoord(s.row, ROWS), col: clampCoord(s.col, COLS) } : null,
            end: (e && isFinite(e.row) && isFinite(e.col)) ? { row: clampCoord(e.row, ROWS), col: clampCoord(e.col, COLS) } : null
          };
        } else {
          gameplayPath = { start: null, end: null };
        }

        if (typeof data.alignWorldToPath === "boolean") {
          alignWorldToPath = data.alignWorldToPath;
          alignToPathCheckbox.checked = alignWorldToPath;
        }

        selectionSet.clear();
        selectedPrimary = { row: null, col: null };
        updateSelectionInfo();

        populateTileSelectForLayer(activeLayer);
        rebuildAssetPanel();
        renderAllCells2D();
        rebuild3DFromState();
        updateGameplayPath2D();
        rebuildGameplayPath3D();
        applyWorldAlignmentFromPath();

        // Auto-reload models from their gltfPath after import
        autoLoadAssetModels();

        logDebug("Map JSON import applied. Models auto-loading from asset paths...");
      } catch (err) {
        logDebug("Import ERROR: " + (err?.message || String(err)));
      }
    }

    importJsonBtn.addEventListener("click", () => importJsonInput.click());
    importJsonInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const text = String(reader.result || "");
          const data = JSON.parse(text);
          applyImportedState(data);
        } catch (err) {
          logDebug("Import ERROR: invalid JSON (" + (err?.message || String(err)) + ")");
        }
      };
      reader.readAsText(file);
    });

    // Preset map loader
    presetMapSelect.addEventListener("change", (e) => {
      const path = e.target.value;
      if (!path) return;

      logDebug("Loading preset map from: " + path);
      fetch(path)
        .then(res => {
          if (!res.ok) throw new Error("HTTP " + res.status);
          return res.json();
        })
        .then(data => {
          applyImportedState(data);
          presetMapSelect.value = ""; // Reset dropdown
        })
        .catch(err => {
          logDebug("Preset map load ERROR: " + (err?.message || String(err)));
          presetMapSelect.value = ""; // Reset dropdown
        });
    });

    function initUI() {
      showArrows = showArrowsCheckbox.checked;
      alignWorldToPath = alignToPathCheckbox ? alignToPathCheckbox.checked : true;
      setActiveTool(toolSelectEl ? (toolSelectEl.value || "paint") : "paint");
      populateTileSelectForLayer(activeLayer);
      rebuildAssetPanel();

      coordValueEl.textContent = "none";
      tileValueEl.textContent = "—";
      orientationValueEl.textContent = "—";
      selectionControlsEl.style.display = "none";
      deleteTileBtn.disabled = true;

      setBrushOrientation(brushOrientationDeg);
      logDebug("UI initialized.");
    }

    initUI();
    createGridDom();
    initThree();
    autoLoadAssetModels(); // Auto-load models from asset paths
    renderAllCells2D();
    rebuild3DFromState();
    updateGameplayPath2D();
    rebuildGameplayPath3D();
    applyWorldAlignmentFromPath();

    overlay.textContent = "3D ready. Models loading from assets folder...";
    logDebug("Editor ready.");
  </script>
</body>
</html>
