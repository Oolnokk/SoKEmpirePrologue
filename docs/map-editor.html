<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parallax Map Builder (Layered v15f)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <style>
    :root {
      --bg:#05070a; --panel:#10141a; --card:#151b22;
      --line:#27303c; --muted:#7f8ea3; --text:#e6edf3;
      --btn:#1a2330; --btnHi:#222d3c;
    }
    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      height:100%;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;
      padding-left:env(safe-area-inset-left);
      padding-right:env(safe-area-inset-right);
      padding-bottom:env(safe-area-inset-bottom);
    }

    #app {
      display:grid;
      grid-template-rows:40px auto 1fr;
      grid-template-columns:280px 1fr;
      grid-template-areas:
        "top top"
        "left bar"
        "left right";
      height:100vh;
      max-height:100vh;
      overflow:hidden;
    }

    header {
      grid-area:top;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 8px;
      background:var(--panel);
      border-bottom:1px solid var(--line);
      gap:6px;
      font-size:11px;
    }
    header h1 {
      margin:0;
      font-size:13px;
      font-weight:500;
      color:var(--muted);
    }

    button, select, input {
      background:var(--btn);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:10px;
      padding:4px 8px;
      font-size:16px; /* avoid mobile zoom */
    }
    button:hover { background:var(--btnHi); cursor:pointer; }
    .toolbar { display:flex; gap:6px; align-items:center; flex-wrap:wrap; justify-content:flex-end; position:relative; }
    .btn-primary { background:#2563eb; border-color:#1d4ed8; color:white; box-shadow:0 6px 20px rgba(37,99,235,0.25); }
    .btn-primary:hover { background:#1d4ed8; }
    .btn-secondary { background:transparent; border-color:var(--line); color:var(--text); box-shadow:none; }
    .split-group { display:flex; align-items:stretch; position:relative; }
    .split-group > button { border-radius:10px 0 0 10px; }
    .split-group .split-caret { width:34px; padding:4px; border-left:none; border-radius:0 10px 10px 0; display:grid; place-items:center; }
    .menu { position:absolute; top:calc(100% + 4px); right:0; background:var(--panel); border:1px solid var(--line); border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.35); min-width:200px; padding:6px; display:none; flex-direction:column; gap:4px; z-index:10; }
    .menu.open { display:flex; }
    .menu label { font-size:10px; color:var(--muted); display:flex; flex-direction:column; gap:2px; }
    .menu .menu-row { display:flex; gap:6px; align-items:center; }
    .menu button { width:100%; text-align:left; border-radius:8px; }
    .menu .menu-row button { width:auto; white-space:nowrap; }
    .menu .menu-inline-select { flex:1; }
    .kebab { width:32px; display:grid; place-items:center; border-radius:10px; }
    @media (max-width:540px) {
      header { flex-wrap:wrap; gap:8px; }
      .toolbar { width:100%; justify-content:flex-start; }
    }

    #bar {
      grid-area:bar;
      padding:4px 8px;
      display:flex;
      align-items:center;
      gap:8px;
      background:#111821;
      border-bottom:1px solid var(--line);
      font-size:11px;
      color:var(--muted);
      flex-wrap:wrap;
    }

    #left {
      grid-area:left;
      padding:6px;
      border-right:1px solid var(--line);
      background:var(--panel);
      overflow:auto;
      font-size:11px;
    }

    #right {
      grid-area:right;
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:hidden;
    }

    .card {
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:6px;
      margin-bottom:4px;
    }

    .row {
      display:flex;
      gap:6px;
      margin-top:4px;
    }
    .row label {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:10px;
    }
    label span {
      color:var(--muted);
      font-size:10px;
    }

    #sceneWrap {
      flex:1;
      border-radius:14px;
      border:1px solid var(--line);
      background:transparent;
      overflow:hidden;
      position:relative;
      min-height:0;
    }
    #sceneCanvas {
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }
    #sceneCanvas.spawn-mode,
    #sceneCanvas.collider-mode {
      cursor:crosshair;
    }

    #instList {
      max-height:160px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
    }
    #colliderList {
      max-height:140px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
      margin-top:4px;
    }
    .inst {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .inst span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .inst.active {
      background:rgba(120,150,255,0.16);
    }
    .collider {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .collider span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .collider.active {
      background:rgba(239, 68, 68, 0.16);
    }

    .pill {
      padding:1px 5px;
      border-radius:999px;
      background:#1c2330;
      color:var(--muted);
      font-size:9px;
    }
    .pill--spawn {
      margin-left:4px;
      background:#0f172a;
      color:#38bdf8;
    }
    .lock-pill {
      margin-left:4px;
      font-size:9px;
      color:#facc15;
    }

    #debugText {
      font-family:ui-monospace,Menlo,Consolas;
      font-size:9px;
      color:var(--muted);
      margin-top:4px;
      white-space:pre;
    }

    #exportStatus {
      font-size:9px;
      margin-top:2px;
    }
    #exportText {
      width:100%;
      height:80px;
      margin-top:4px;
      background:#020308;
      color:#9ca3af;
      border-radius:6px;
      border:1px solid #27303c;
      font-size:9px;
      padding:4px;
      font-family:ui-monospace,Menlo,Consolas;
      resize:vertical;
    }

    .hidden-select {
      display:none;
    }

    #instStretchLayer {
      display:inline-block;
      min-width:120px;
    }

    .layer-stack {
      display:flex;
      flex-direction:column-reverse; /* top tile = frontmost visually */
      gap:4px;
      margin-top:4px;
    }
    .layer-item {
      padding:4px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:#111823;
      font-size:9px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
    }
    .layer-item span { pointer-events:none; }
    .layer-item.active {
      background:#1f2933;
      border-color:#38bdf8;
      box-shadow:0 0 0 1px rgba(56,189,248,0.25);
    }
    .layer-item.dragging { opacity:0.4; }
    .layer-item-type {
      padding:1px 5px;
      border-radius:999px;
      font-size:8px;
      background:#0f172a;
      color:#9ca3af;
    }

    @media (max-width:900px) {
      #app {
        grid-template-rows:40px auto 40% 1fr;
        grid-template-columns:1fr;
        grid-template-areas:
          "top"
          "bar"
          "right"
          "left";
      }
      #left {
        border-right:none;
        border-top:1px solid var(--line);
      }
    }
  </style>
  <script src="./config/config.js"></script>
</head>
<body>
<div id="app">
  <header>
    <h1>Parallax Map Builder <span style="color:var(--muted)">· layered v15f</span></h1>
    <div class="toolbar" aria-label="Editor actions">
      <div class="split-group" aria-label="Import and load">
        <button id="btnLoadMap" aria-label="Load selected map">Load Map</button>
        <button id="importMenuToggle" class="split-caret" aria-haspopup="true" aria-expanded="false" aria-label="Open import menu">▾</button>
        <div id="importMenu" class="menu" role="menu" aria-label="Import menu">
          <button id="btnLoadPrefab" role="menuitem">Load Structure JSON</button>
          <button id="btnLoadImage" role="menuitem">Load Image</button>
          <div class="menu-row" role="menuitem">
            <label class="menu-inline-select">
              <span>Repository Map</span>
              <select id="mapRepoSelect" aria-label="Repository Map"></select>
            </label>
            <button id="btnLoadMapInline" aria-label="Load selected repository map">Load</button>
          </div>
        </div>
      </div>
      <button id="btnPreviewGameplay" class="btn-primary">Preview</button>
      <button id="btnExportMap" class="btn-secondary">Export</button>
      <button id="overflowMenuToggle" class="kebab" aria-label="More actions" aria-haspopup="true" aria-expanded="false">⋮</button>
      <div id="overflowMenu" class="menu" role="menu" aria-label="More actions">
        <button id="btnUndo" role="menuitem">Undo</button>
      </div>
    </div>
  </header>

  <div id="bar">
    <span>
      Cam:
      <input id="camSlider" type="range" min="-4000" max="4000" value="0" style="width:120px">
      <input id="camNum" type="number" value="0" style="width:70px">
    </span>
    <span>
      Zoom:
      <input id="zoomSlider" type="range" min="0.5" max="2.0" step="0.05" value="1" style="width:120px">
      <input id="zoomNum" type="number" min="0.5" max="2.0" step="0.05" value="1" style="width:60px">
    </span>
    <label style="display:flex;align-items:center;gap:4px">
      <input id="chkDebug" type="checkbox">
      <span>Debug</span>
    </label>
    <button id="btnAddParallaxLayer">+ Parallax Layer</button>
    <span class="pill">
      Tap layer tiles to select · drag to reorder (top = front).
    </span>
  </div>

  <aside id="left">
    <!-- Instances -->
    <div class="card">
      <strong>Instances (active layer only)</strong>
      <div id="instList"></div>
      <div style="display:flex;margin-top:6px">
        <button id="btnPlacePlayerSpawn" style="flex:1">Place Player Spawn</button>
      </div>
      <div class="row">
        <label><span>Spawn Height (px)</span><input id="spawnPosY" type="number" step="1"></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Positive values push the spawn below ground; negative lifts it above.
      </small>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Only instances on the active layer can be picked, dragged or jittered. Use the button above and then click the preview to set the spawn (snaps to the grid unit).
      </small>
    </div>

    <!-- Colliders -->
    <div class="card">
      <strong>Platform Colliders</strong>
      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
        <button id="btnAddCollider">Add collider</button>
        <button id="btnDeleteCollider">Remove selected</button>
        <span class="pill">Add then drag on the preview to place a collider (click again to cancel).</span>
      </div>
      <div id="colliderList"></div>
      <div class="row" style="margin-top:6px">
        <label><span>ID</span><input id="colliderId" readonly></label>
        <label><span>Label</span><input id="colliderLabel" type="text" placeholder="Ground segment"></label>
      </div>
      <div class="row">
        <label><span>Left (px)</span><input id="colliderLeft" type="number" step="1"></label>
        <label><span>Width (px)</span><input id="colliderWidth" type="number" step="1" min="1"></label>
      </div>
      <div class="row">
        <label><span>Top offset (px)</span><input id="colliderTopOffset" type="number" step="1"></label>
        <label><span>Height (px)</span><input id="colliderHeight" type="number" step="1" min="1"></label>
      </div>
      <div class="row">
        <label><span>Material type</span><input id="colliderMaterialType" type="text" list="materialTypePresets" placeholder="default"></label>
      </div>
      <datalist id="materialTypePresets">
        <option value="stone"></option>
        <option value="concrete"></option>
        <option value="wood"></option>
        <option value="metal"></option>
        <option value="ceramic"></option>
        <option value="glass"></option>
        <option value="dirt"></option>
        <option value="grass"></option>
        <option value="gravel"></option>
        <option value="sand"></option>
        <option value="snow"></option>
        <option value="ice"></option>
        <option value="water"></option>
      </datalist>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Offsets are relative to the ground line. Negative values lift the collider above the ground.
      </small>
    </div>

    <!-- Drum skin layers -->
    <div class="card">
      <strong>Drum Skin Layers</strong>
      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
        <button id="btnAddDrumSkin">Add drum skin</button>
        <span class="pill">Bridges between two parallax layers with a tiled image.</span>
      </div>
      <div id="drumSkinList" style="margin-top:6px;display:flex;flex-direction:column;gap:6px"></div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Configure geometry before selecting an image. Drum skins render above parallax backgrounds but below props.
      </small>
    </div>

    <!-- Selected instance -->
    <div class="card">
      <strong>Selected instance</strong>
      <div class="row">
        <label><span>ID</span><input id="instId" readonly></label>
        <label><span>Prefab</span><select id="instPrefab"></select></label>
      </div>
      <div class="row">
        <label>
          <span>Layer</span>
          <select id="instLayer" class="hidden-select"></select>
        </label>
        <label>
          <span>Display X (world)</span>
          <input id="instX" type="number">
        </label>
      </div>
      <div class="row">
        <label style="flex:none;display:flex;align-items:center;gap:4px">
          <input id="instLocked" type="checkbox">
          <span>Lock position</span>
        </label>
        <label><span>Grid (px)</span><input id="gridSize" type="number" value="10"></label>
        <label><span>Delete</span><button id="btnDeleteInst">Remove</button></label>
      </div>
      <div class="row">
        <label><span>Scale X</span><input id="instScaleX" type="number" step="0.05"></label>
        <label><span>Scale Y</span><input id="instScaleY" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>Position Y (from ground)</span><input id="instOffY" type="number" step="1"></label>
        <label><span>Rot (deg)</span><input id="instRot" type="number" step="1"></label>
      </div>
      <div class="row">
        <label style="flex:none;display:flex;align-items:center;gap:4px">
          <input id="instStretchEnabled" type="checkbox">
          <span>Stretch quad</span>
        </label>
        <label>
          <span>Target layer</span>
          <select id="instStretchLayer" class="hidden-select"></select>
        </label>
      </div>
      <div class="row">
        <label><span>Top height (px)</span><input id="instStretchHeight" type="number" step="1" min="1"></label>
        <label><span>Top offset (px)</span><input id="instStretchTopOffset" type="number" step="1"></label>
      </div>
      <div class="row">
        <label><span>Slices</span><input id="instStretchSlices" type="number" step="1" min="4" max="80"></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Stretch quads span the selected prefab toward another layer. Leave disabled to render normally.
      </small>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateInst">Duplicate</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Duplicate copies all settings; lock blocks drag/jitter, not manual edits.
      </small>
    </div>

    <!-- Prefab library -->
    <div class="card">
      <strong>Prefab Library</strong>
      <div class="row">
        <label>
          <span>Prefab</span>
          <select id="libPrefab"></select>
        </label>
        <label>
          <span>Count</span>
          <input id="libCount" type="number" min="1" max="50" value="8">
        </label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnPlaceRow">Place row on active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Structures & uploads land here; stamp rows onto the active layer.
      </small>
    </div>

    <!-- Layers -->
    <div class="card">
      <strong>Layers</strong>
      <select id="activeLayerSelect" class="hidden-select"></select>
      <div id="layerStack" class="layer-stack"></div>
      <div class="row">
        <label><span>parallax</span><input id="layerParallax" type="number" step="0.05"></label>
        <label><span>y offset (from ground)</span><input id="layerYOffset" type="number"></label>
      </div>
      <div class="row">
        <label><span>separation</span><input id="layerSep" type="number"></label>
        <label><span>scale</span><input id="layerScale" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateLayer">Duplicate active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Drag tiles to change draw order. Top tile renders in front.
      </small>
    </div>

    <!-- Jitter -->
    <div class="card">
      <strong>Jitter (active layer, unlocked only)</strong>
      <div class="row">
        <label><span>Pos range (px)</span><input id="jitterRange" type="number" value="40"></label>
        <label><span>Scale range (±)</span><input id="jitterScaleRange" type="number" step="0.05" value="0.15"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnJitter">Apply jitter</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Randomizes horizontal position (snapped to the grid) and scale for unlocked instances on the active layer.
      </small>
    </div>

    <!-- Global / Export -->
    <div class="card">
      <strong>Global & Export</strong>
      <div class="row">
        <label>
          <span>Ground from bottom (px)</span>
          <input id="groundOffset" type="number" value="140">
        </label>
      </div>
      <div id="exportStatus"></div>
      <textarea id="exportText" readonly
        placeholder="Layout JSON appears here when you export."></textarea>
      <small style="color:var(--muted);display:block;margin-top:4px">
        If the new tab is blocked, long-press here to copy the JSON.
      </small>
    </div>

    <div id="debugText"></div>
  </aside>

  <section id="right">
    <div class="card">
      <strong>Preview</strong>
      <span style="font-size:10px;color:var(--muted);margin-left:6px">
        Screen-space KF · select an instance & toggle Debug to see rays.
      </span>
    </div>
    <div id="sceneWrap"><canvas id="sceneCanvas"></canvas></div>
  </section>
</div>

<script type="module" src="./js/map-config-defaults.js"></script>
<script type="module">
const $ = s => document.querySelector(s);
const ROOT_CONFIG = window.CONFIG || {};
const MAP_CONFIG = ROOT_CONFIG.map || {};
const MAP_EDITOR_DEFAULTS = (() => {
  if (typeof window.resolveMapEditorDefaults === 'function') {
    return window.resolveMapEditorDefaults(MAP_CONFIG) || {};
  }
  const fallbackCanvasHeight = Number.isFinite(ROOT_CONFIG.canvas?.h) && ROOT_CONFIG.canvas.h > 0
    ? ROOT_CONFIG.canvas.h
    : 460;
  const fallbackGroundOffset = (() => {
    const configGround = ROOT_CONFIG.ground;
    const configuredOffset = configGround && typeof configGround === 'object' ? Number(configGround.offset) : NaN;
    if (Number.isFinite(configuredOffset)) {
      return Math.max(0, configuredOffset);
    }
    const ratio = Number(ROOT_CONFIG.groundRatio);
    if (Number.isFinite(ratio) && ratio > 0 && ratio < 1 && fallbackCanvasHeight > 0) {
      return Math.max(0, Math.round(fallbackCanvasHeight * (1 - ratio)));
    }
    return 140;
  })();
  const fallbackCustomArea = { id: 'custom_area', label: 'Empty Layout', path: null, areaName: 'Custom Area' };
  return {
    canvasHeight: fallbackCanvasHeight,
    groundOffset: fallbackGroundOffset,
    groundRatio: Number.isFinite(ROOT_CONFIG.groundRatio) ? ROOT_CONFIG.groundRatio : null,
    customArea: fallbackCustomArea,
  };
})();
const DEFAULT_LAYOUT_ID = typeof window.resolveDefaultLayoutId === 'function'
  ? window.resolveDefaultLayoutId(MAP_CONFIG)
  : ((typeof MAP_CONFIG.defaultLayoutId === 'string' && MAP_CONFIG.defaultLayoutId.trim())
    ? MAP_CONFIG.defaultLayoutId.trim()
    : 'defaultdistrict');
const PREVIEW_STORAGE_PREFIX = typeof window.resolvePreviewStoragePrefix === 'function'
  ? window.resolvePreviewStoragePrefix(MAP_CONFIG)
  : ((typeof MAP_CONFIG.previewStoragePrefix === 'string' && MAP_CONFIG.previewStoragePrefix.trim())
    ? MAP_CONFIG.previewStoragePrefix.trim()
    : 'sok-map-editor-preview:');
const pickDefaultLayoutEntry = typeof window.pickDefaultLayoutEntry === 'function'
  ? window.pickDefaultLayoutEntry
  : null;
const DEFAULT_CANVAS_HEIGHT = Number.isFinite(MAP_EDITOR_DEFAULTS.canvasHeight)
  && MAP_EDITOR_DEFAULTS.canvasHeight > 0
  ? MAP_EDITOR_DEFAULTS.canvasHeight
  : 460;
const DEFAULT_GROUND_OFFSET = Number.isFinite(MAP_EDITOR_DEFAULTS.groundOffset)
  ? Math.max(0, MAP_EDITOR_DEFAULTS.groundOffset)
  : 140;
const DEFAULT_CUSTOM_ENTRY = (() => {
  const custom = MAP_EDITOR_DEFAULTS.customArea || {};
  const id = (typeof custom.id === 'string' && custom.id.trim()) ? custom.id.trim() : 'custom_area';
  const label = (typeof custom.label === 'string' && custom.label.trim()) ? custom.label.trim() : 'Empty Layout';
  const areaName = (typeof custom.areaName === 'string' && custom.areaName.trim())
    ? custom.areaName.trim()
    : (label || 'Custom Area');
  const path = (typeof custom.path === 'string' && custom.path.trim()) ? custom.path.trim() : null;
  return { id, label: label || 'Empty Layout', path, areaName: areaName || 'Custom Area' };
})();
const REPOSITORY_LAYOUTS = (() => {
  const normalized = Array.isArray(MAP_CONFIG.layouts) && MAP_CONFIG.layouts.length
    ? MAP_CONFIG.layouts.map((entry) => ({
        id: entry.id || entry.areaId || entry.path || 'custom_area',
        label: entry.label || entry.areaName || entry.id || 'Map',
        path: entry.path || null,
        areaName: entry.areaName || entry.label || entry.id || 'Map',
      }))
    : [];
  const seen = new Set();
  const result = [];
  const add = (entry) => {
    if (entry && entry.id && !seen.has(entry.id)) {
      result.push(entry);
      seen.add(entry.id);
    }
  };
  add(DEFAULT_CUSTOM_ENTRY);
  normalized.forEach(add);
  return result;
})();
const DEFAULT_LAYOUT_META = (() => {
  const fallback = {
    areaId: DEFAULT_CUSTOM_ENTRY.id,
    areaName: DEFAULT_CUSTOM_ENTRY.areaName || DEFAULT_CUSTOM_ENTRY.label || 'Custom Area',
    sourcePath: DEFAULT_CUSTOM_ENTRY.path,
    repositoryId: DEFAULT_CUSTOM_ENTRY.id,
  };
  const findEntryById = (id) => REPOSITORY_LAYOUTS.find((entry) => entry.id === id) || null;
  const chosen = pickDefaultLayoutEntry
    ? pickDefaultLayoutEntry(REPOSITORY_LAYOUTS, MAP_CONFIG)
    : (findEntryById(DEFAULT_LAYOUT_ID)
      || findEntryById('defaultdistrict')
      || REPOSITORY_LAYOUTS.find((entry) => entry.id && entry.id !== DEFAULT_CUSTOM_ENTRY.id)
      || null);
  if (!chosen) return fallback;
  return {
    areaId: chosen.id || fallback.areaId,
    areaName: chosen.areaName || chosen.label || chosen.id || fallback.areaName,
    sourcePath: chosen.path || fallback.sourcePath,
    repositoryId: chosen.id || fallback.repositoryId,
  };
})();
const GRID_UNIT = (Number.isFinite(MAP_CONFIG.gridUnit) && MAP_CONFIG.gridUnit > 0) ? MAP_CONFIG.gridUnit : 10;
const SPAWN_LAYER_ID = MAP_CONFIG.spawnLayerId || 'gameplay';
const PREFAB_MANIFESTS = Array.isArray(MAP_CONFIG.prefabManifests)
  ? MAP_CONFIG.prefabManifests.filter((entry) => typeof entry === 'string' && entry.trim())
  : [];
let runtimeModulePromise = null;
let prefabBootstrapPromise = null;

$('#groundOffset').value = DEFAULT_GROUND_OFFSET;

function getRuntimeModule(){
  if (!runtimeModulePromise){
    runtimeModulePromise = import('./js/vendor/map-runtime.js');
  }
  return runtimeModulePromise;
}

function clamp(v,a,b){ return v<a?a:v>b?b:v; }
function lerp(a,b,t){ return a + (b-a)*t; }
function rad(d){ return d * Math.PI/180; }

/*** Undo history ***/
const historyStack = [];
const HISTORY_LIMIT = 50;
let isRestoring = false;
function snapshotState(){
  return JSON.parse(JSON.stringify({
    ...buildAreaDescriptor(),
    activeLayerId,
  }));
}
function pushHistory(){
  if(isRestoring) return;
  historyStack.push(snapshotState());
  if(historyStack.length > HISTORY_LIMIT) historyStack.shift();
}
function restoreState(state){
  if(!state) return;
  isRestoring = true;
  exitSpawnPlacement();
  exitColliderPlacement();

  const adopted = adoptAreaState(state, state.meta || {});
  layoutMeta = { ...DEFAULT_LAYOUT_META, ...(adopted.meta || {}) };

  layers = adopted.layers.map((layer, index) => normalizeLayer(layer, index));
  instances.length = 0;
  nextInstId = 1;
  for (const inst of adopted.instances){
    const normalized = normalizeInstance(inst, nextInstId);
    if (normalized.id == null){
      normalized.id = nextInstId++;
    } else {
      nextInstId = Math.max(nextInstId, normalized.id + 1);
    }
    normalized.tags = Array.isArray(normalized.tags) ? normalized.tags : [];
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    instances.push(normalized);
  }

  const spawn = ensurePlayerSpawn();
  if (spawn && spawn.id >= nextInstId){
    nextInstId = spawn.id + 1;
  }

  colliders.length = 0;
  nextColliderId = 1;
  if (Array.isArray(adopted.colliders)){
    for (const col of adopted.colliders){
      const normalized = normalizeCollider(col, nextColliderId);
      if (normalized.id == null){
        normalized.id = nextColliderId++;
      } else {
        nextColliderId = Math.max(nextColliderId, normalized.id + 1);
      }
      colliders.push(normalized);
    }
  }
  selectedColliderId = colliders[0]?.id ?? null;

  drumSkins.length = 0;
  nextDrumSkinId = 1;
  if (Array.isArray(adopted.drumSkins)) {
    for (const drum of adopted.drumSkins) {
      const normalized = normalizeDrumSkin(drum, nextDrumSkinId, layers);
      normalized.id ??= nextDrumSkinId;
      nextDrumSkinId = Math.max(nextDrumSkinId + 1, (normalized.id || 0) + 1);
      drumSkins.push(normalized);
    }
  }

  activeLayerId = adopted.activeLayerId || layoutMeta.activeLayerId || getDefaultSpawnLayerId();
  cameraX = toNumber(adopted.camera?.startX, 0);
  zoom = toNumber(adopted.camera?.startZoom, 1);
  $('#groundOffset').value = toNumber(adopted.ground?.offset, DEFAULT_GROUND_OFFSET);
  selectedInstId = getPlayerSpawnInstance()?.id || (instances[0]?.id ?? null);

  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
  refreshInstanceList();
  refreshColliderList();
  refreshDrumSkinList();
  syncColliderFields();
  setCameraX(cameraX);
  setZoom(zoom);

  isRestoring = false;
}
function undo(){
  const st = historyStack.pop();
  if(st) restoreState(st);
}

/*** Easing + unified screen-space KF ***/
function ease01(mode, x){
  x = clamp(x,0,1);
  if (mode === 'smoothstep') return x*x*(3 - 2*x);
  if (mode === 'quadInOut')  return x < 0.5
      ? 2*x*x
      : 1 - Math.pow(-2*x + 2, 2) / 2;
  return x; // linear
}

/*
  Step 1: computeTFromDx(kfMeta, dxScreen)

    reticleX = center of screen
    dxScreen = rootScreenX - reticleX    (screen pixels)

    radiusPx = kfMeta.radiusPx || kfMeta.radius || 600
    t        = clamp(-dxScreen / radiusPx, -1, 1)

  This is done ONCE per structure instance (root).
*/
function computeTFromDx(kfMeta, dxScreen){
  const baseRadius =
    (kfMeta && Number.isFinite(kfMeta.radiusPx) && kfMeta.radiusPx > 0) ? kfMeta.radiusPx :
    (kfMeta && Number.isFinite(kfMeta.radius)   && kfMeta.radius   > 0) ? kfMeta.radius   :
    600;
  const radiusPx = Math.max(1, baseRadius);
  const rawT = -dxScreen / radiusPx;
  return {
    t: clamp(rawT, -1, 1),
    radiusPx
  };
}

/*
  Step 2: evalKfPose(kf, t)

  Given a shared t in [-1,1], lerp between left/center/right for this part.
  This matches the "single t, many parts" mental model.
*/
function evalKfPose(kf, t){
  if(!kf){
    return {
      t,
      dx:0, dy:0,
      scaleX:1,
      rotZdeg:0,
      translateSpace:'screen',
      order:'scaleThenRotate'
    };
  }

  const ease = kf.ease || 'smoothstep';
  const L = kf.left   || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const C = kf.center || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const R = kf.right  || {dx:0,dy:0,scaleX:1,rotZdeg:0};

  let from, to, u;
  if(t <= 0){
    // -1..0 : LEFT -> CENTER
    u = ease01(ease, t + 1); // [-1,0] -> [0,1]
    from = L; to = C;
  }else{
    // 0..1 : CENTER -> RIGHT
    u = ease01(ease, t);     // [0,1] -> [0,1]
    from = C; to = R;
  }

  return {
    t,
    dx:      lerp(from.dx      || 0, to.dx      || 0, u),
    dy:      lerp(from.dy      || 0, to.dy      || 0, u),
    scaleX:  lerp(from.scaleX ?? 1, to.scaleX ?? 1, u),
    rotZdeg: lerp(from.rotZdeg || 0, to.rotZdeg || 0, u),
    translateSpace: kf.translateSpace || 'screen',
    order:          kf.transformOrder || 'scaleThenRotate'
  };
}

/*** Apply a pose into current ctx, respecting translateSpace/order */
function applyPose(ctx, pose){
  const dx = pose.dx || 0;
  const dy = pose.dy || 0;
  const sx = (pose.scaleX != null ? pose.scaleX : 1);
  const rot = pose.rotZdeg || 0;
  const space = pose.translateSpace || 'screen';
  const order = pose.order || 'scaleThenRotate';

  // "screen": offsets in current (screen) space, before local scaling/rot.
  if(space === 'screen'){
    ctx.translate(dx, dy);
  }

  if(order === 'scaleThenRotate'){
    if(sx !== 1) ctx.scale(sx, 1);
    if(rot) ctx.rotate(rad(rot));
  }else{
    if(rot) ctx.rotate(rad(rot));
    if(sx !== 1) ctx.scale(sx, 1);
  }

  // "local": offsets after local transform (move in the part's space)
  if(space === 'local'){
    ctx.translate(dx, dy);
  }
}

/*** Anchors ***/
function computeAnchor(t){
  const w = t.w || 100;
  const h = t.h || 100;
  if(t.pivot === 'bottom') return {ax:w*0.5, ay:h};
  if(t.pivot === 'top')    return {ax:w*0.5, ay:0};
  if(t.pivot === 'center') return {ax:w*0.5, ay:h*0.5};
  const ax = (Number.isFinite(t.anchorXPct)? t.anchorXPct : 50) * 0.01 * w;
  const ay = (Number.isFinite(t.anchorYPct)? t.anchorYPct : 100) * 0.01 * h;
  return {ax, ay};
}

/*** Layers ***/
function createDefaultLayers(){
  return [
    { id:"bg1",  name:"Parallax 1", type:"parallax",  parallaxSpeed:0.2, offsetY:-120, separation:220, scale:0.7, meta:{} },
    { id:"bg2",  name:"Parallax 2", type:"parallax",  parallaxSpeed:0.4, offsetY:-90,  separation:220, scale:0.8, meta:{} },
    { id:"gameplay", name:"Gameplay", type:"gameplay", parallaxSpeed:1.0, offsetY:-20, separation:180, scale:1.0, meta:{} },
    { id:"fg1",  name:"Foreground 1", type:"foreground", parallaxSpeed:1.1, offsetY:-10, separation:180, scale:1.05, meta:{} },
    { id:"fg2",  name:"Foreground 2", type:"foreground", parallaxSpeed:1.2, offsetY:0,   separation:180, scale:1.1, meta:{} }
  ];
}
let layers = createDefaultLayers();
let activeLayerId = SPAWN_LAYER_ID && layers.some((l) => l.id === SPAWN_LAYER_ID) ? SPAWN_LAYER_ID : 'gameplay';
let layoutMeta = { ...DEFAULT_LAYOUT_META };
let drumSkins = [];
let nextDrumSkinId = 1;
function getParallaxLayerCount(){ return layers.filter(l=>l.type==="parallax").length; }
function findLayer(id){ return layers.find(l=>l.id===id) || null; }
function getLayerGroundY(layerId){
  const layer = findLayer(layerId);
  const offsetY = toNumber(layer?.offsetY ?? layer?.yOffset, 0);
  const separation = toNumber(layer?.separation ?? layer?.sep, 0);
  return getGroundOffset() + offsetY + separation;
}

/*** Prefabs & Instances ***/
const imageCache = new Map();
const prefabs = {};
let selectedPrefabId = null;
let nextInstId = 1;
const instances = [];
let selectedInstId = null;
let playerSpawnInstId = null;
let spawnPlacementMode = false;
const colliders = [];
let nextColliderId = 1;
let selectedColliderId = null;
let colliderPlacementMode = false;
let activeColliderDrag = null;

function isPlayerSpawn(inst){
  return Array.isArray(inst?.tags) && inst.tags.includes('spawn:player');
}

function getDefaultSpawnLayerId(){
  if (findLayer(SPAWN_LAYER_ID)) return SPAWN_LAYER_ID;
  const gameplay = layers.find((layer) => layer.type === 'gameplay');
  return gameplay ? gameplay.id : (layers[0]?.id || 'gameplay');
}

function ensurePlayerSpawn(){
  let spawn = instances.find(isPlayerSpawn);
  const spawnLayerId = getDefaultSpawnLayerId();
  if (!spawn){
    spawn = {
      id: nextInstId++,
      prefabId: 'spawn_player',
      layerId: spawnLayerId,
      position: { x: 0, y: 0 },
      scale: { x: 1, y: 1 },
      rotationDeg: 0,
      locked: true,
      tags: ['spawn:player'],
      meta: {},
    };
    instances.push(spawn);
  } else {
    if (!Array.isArray(spawn.tags)) spawn.tags = [];
    if (!spawn.tags.includes('spawn:player')) spawn.tags.push('spawn:player');
    spawn.layerId = spawn.layerId || spawnLayerId;
    spawn.position = normalizePosition(spawn.position);
    spawn.scale = normalizeScale(spawn.scale);
    spawn.rotationDeg = Number.isFinite(spawn.rotationDeg) ? spawn.rotationDeg : 0;
    spawn.meta = spawn.meta && typeof spawn.meta === 'object' ? spawn.meta : {};
  }
  playerSpawnInstId = spawn.id;
  return spawn;
}

function getPlayerSpawnInstance(){
  if (playerSpawnInstId != null){
    const inst = instances.find((item) => item.id === playerSpawnInstId);
    if (inst) return inst;
  }
  const spawn = instances.find(isPlayerSpawn) || null;
  if (spawn) playerSpawnInstId = spawn.id;
  return spawn;
}

function exitSpawnPlacement(){
  spawnPlacementMode = false;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('spawn-mode');
}

function syncSpawnHeightField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = getPlayerSpawnInstance();
  if (!spawn){
    field.value = '';
    return;
  }
  const pos = normalizePosition(spawn.position);
  field.value = Number.isFinite(pos.y) ? pos.y : 0;
}

function updateSpawnHeightFromField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = ensurePlayerSpawn();
  if (!spawn) return;
  const val = parseFloat(field.value);
  if (!Number.isFinite(val)) {
    syncSpawnHeightField();
    return;
  }
  spawn.position = normalizePosition(spawn.position);
  if (spawn.position.y === val) return;
  pushHistory();
  spawn.position.y = val;
  refreshInstanceList();
}

function toNumber(value, fallback){
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function normalizePosition(position){
  if (!position || typeof position !== 'object'){
    return { x: 0, y: 0 };
  }
  const x = toNumber(position.x, 0);
  const y = toNumber(position.y, 0);
  return { x, y };
}

function normalizeScale(scale){
  if (!scale || typeof scale !== 'object'){
    return { x: 1, y: 1 };
  }
  const x = toNumber(scale.x, 1) || 1;
  const y = toNumber(scale.y, scale.x ?? 1) || 1;
  return { x, y };
}

function normalizeStretchQuadSpec(raw){
  if (!raw || typeof raw !== 'object') return null;
  const targetLayerId = typeof raw.targetLayerId === 'string' ? raw.targetLayerId.trim() : '';
  const height = toNumber(raw.height ?? raw.span ?? raw.topHeight ?? raw.topAboveGround, null);
  if (!targetLayerId || !Number.isFinite(height) || height <= 0) return null;

  const topOffset = toNumber(raw.topOffset ?? raw.topYOffset ?? raw.yOffset, 0) || 0;
  const slicesRaw = Math.round(toNumber(raw.slices ?? raw.strips ?? raw.steps, 24) || 24);
  const slices = clamp(slicesRaw, 4, 80);

  return { targetLayerId, height, topOffset, slices };
}

function normalizeDrumSkin(raw, index = 0, layerList = layers){
  const safe = raw && typeof raw === 'object' ? JSON.parse(JSON.stringify(raw)) : {};
  const parallaxLayers = Array.isArray(layerList)
    ? layerList.filter((layer) => layer?.type === 'parallax')
    : [];
  const fallbackA = parallaxLayers[0]?.id || 'bg1';
  const fallbackB = parallaxLayers[1]?.id || parallaxLayers[0]?.id || 'bg1';
  const layerA = typeof safe.layerA === 'string' && safe.layerA.trim() ? safe.layerA.trim() : fallbackA;
  const layerB = typeof safe.layerB === 'string' && safe.layerB.trim() ? safe.layerB.trim() : fallbackB;
  const heightA = toNumber(safe.heightA ?? safe.offsetA ?? safe.yOffsetA, 0) || 0;
  const heightB = toNumber(safe.heightB ?? safe.offsetB ?? safe.yOffsetB, 0) || 0;
  const prefabId = typeof safe.prefabId === 'string' ? safe.prefabId.trim() : '';
  const textureId = typeof safe.textureId === 'string' ? safe.textureId.trim() : '';
  const prefabRef = textureId || prefabId;
  const imageURL = typeof safe.imageURL === 'string' ? safe.imageURL.trim() : '';
  const tileScale = toNumber(safe.tileScale, 1) || 1;
  const visible = safe.visible !== false;
  const id = safe.id ?? safe.drumSkinId ?? index + 1;
  return {
    id,
    layerA,
    layerB,
    heightA,
    heightB,
    prefabId: prefabRef,
    textureId: prefabRef,
    imageURL,
    tileScale,
    visible,
  };
}

// Expanded/Refactored: 
// Now checks area-level drumSkin layer config before instance meta
function getStretchQuadMeta(inst, areaDrumSkins) {
  // Prefer area-level drumSkinLayers over legacy instance meta
  if (Array.isArray(areaDrumSkins)) {
    // Check if instance sits on a ground span drum skin
    for (const drum of areaDrumSkins) {
      // If instance is positioned within the drum skin quad (custom test as needed)
      // Example: check if inst.layerId is between drum.layerA and drum.layerB
      if (
        inst &&
        drum.visible &&
        (
          inst.layerId === drum.layerA ||
          inst.layerId === drum.layerB || 
          // Or custom geometric test for inside quad...
          false
        )
      ) {
        return {
          spec: {
            layerA: drum.layerA,
            layerB: drum.layerB,
            heightA: drum.heightA,
            heightB: drum.heightB,
            imageURL: drum.imageURL,
            tileScale: drum.tileScale || 1.0
          },
          key: "areaDrumSkin"
        };
      }
    }
  }
  // --- Legacy support: instance-level meta ---
  const meta = inst?.meta && typeof inst.meta === 'object' ? inst.meta : null;
  if (!meta) return { spec: null, key: null };
  if (meta.stretchQuad) return { spec: normalizeStretchQuadSpec(meta.stretchQuad), key: 'stretchQuad' };
  if (meta.groundSpan) return { spec: normalizeStretchQuadSpec(meta.groundSpan), key: 'groundSpan' };
  if (meta.drumSkin) return { spec: normalizeStretchQuadSpec(meta.drumSkin), key: 'drumSkin' };
  return { spec: null, key: null };
}

function normalizeLayer(layer, index = 0){
  const safe = layer && typeof layer === 'object' ? JSON.parse(JSON.stringify(layer)) : {};
  const id = safe.id || `layer_${index}`;
  const name = safe.name || `Layer ${index + 1}`;
  const type = safe.type || 'gameplay';
  const parallaxSpeed = toNumber(safe.parallaxSpeed ?? safe.parallax, 1);
  const offsetY = toNumber(safe.offsetY ?? safe.yOffset, 0);
  const separation = toNumber(safe.separation ?? safe.sep, 0);
  const scale = toNumber(safe.scale, 1);
  const source = safe.source ?? null;
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, name, type, parallaxSpeed, offsetY, separation, scale, source, meta };
}

function normalizeInstance(inst, fallbackId = 0){
  const safe = inst && typeof inst === 'object' ? JSON.parse(JSON.stringify(inst)) : {};
  const id = safe.id ?? safe.meta?.original?.id ?? fallbackId;
  const prefabId = safe.prefabId ?? safe.meta?.original?.prefabId ?? 'unknown_prefab';
  const layerId = safe.layerId ?? safe.meta?.original?.layerId ?? getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position ?? { x: safe.x, y: safe.y ?? (safe.offsetY != null ? -safe.offsetY : 0) });
  const scale = normalizeScale(safe.scale ?? { x: safe.scaleX, y: safe.scaleY });
  const rotationDeg = toNumber(safe.rotationDeg ?? safe.rot, 0);
  const locked = !!(safe.locked ?? safe.meta?.original?.locked);
  const tags = Array.isArray(safe.tags)
    ? safe.tags.map((tag) => String(tag))
    : Array.isArray(safe.meta?.original?.tags)
      ? safe.meta.original.tags.map((tag) => String(tag))
      : [];
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, prefabId, layerId, position, scale, rotationDeg, locked, tags, meta };
}

function normalizeCollider(raw, fallbackId = 1){
  const safe = raw && typeof raw === 'object' ? JSON.parse(JSON.stringify(raw)) : {};
  const id = safe.id ?? safe.meta?.original?.id ?? fallbackId;
  const labelRaw = typeof safe.label === 'string' ? safe.label.trim() : '';
  const type = (safe.type === 'box' || safe.shape === 'box') ? 'box' : 'box';
  const materialTypeRaw = typeof safe.materialType === 'string' ? safe.materialType.trim() : '';
  const metaMaterialType = typeof safe.meta?.materialType === 'string' ? safe.meta.materialType.trim() : '';
  const legacyStepSoundRaw = typeof safe.stepSound === 'string' ? safe.stepSound.trim() : '';
  const legacyMetaStepSound = typeof safe.meta?.stepSound === 'string' ? safe.meta.stepSound.trim() : '';
  const normalizedMaterialType = materialTypeRaw
    || metaMaterialType
    || legacyStepSoundRaw
    || legacyMetaStepSound
    || '';

  let left = toNumber(safe.left ?? safe.x ?? safe.position?.x, 0);
  const rightRaw = safe.right ?? safe.meta?.original?.right;
  let width = toNumber(safe.width ?? safe.w, null);
  if (!Number.isFinite(width) && Number.isFinite(rightRaw)){
    width = toNumber(rightRaw, left) - left;
  }
  if (!Number.isFinite(width)) width = 120;
  if (width < 0){
    left += width;
    width = Math.abs(width);
  }

  let topOffset = toNumber(safe.topOffset ?? safe.top ?? safe.y ?? safe.offsetY, 0);
  const bottomRaw = safe.bottomOffset ?? safe.bottom ?? safe.meta?.bottomOffset;
  let height = toNumber(safe.height ?? safe.h, null);
  if (!Number.isFinite(height) && Number.isFinite(bottomRaw)){
    height = toNumber(bottomRaw, 0) - topOffset;
  }
  if (!Number.isFinite(height)) height = 40;
  if (height < 0){
    topOffset += height;
    height = Math.abs(height);
  }

  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};

  return {
    id,
    label: labelRaw || `Collider ${id ?? fallbackId}`,
    type,
    left,
    width: Math.max(1, width),
    topOffset,
    height: Math.max(1, height),
    materialType: normalizedMaterialType || null,
    meta,
  };
}

function adoptAreaState(area, context = {}){
  const raw = area && typeof area === 'object' ? JSON.parse(JSON.stringify(area)) : {};
  const id = raw.id || raw.areaId || context.areaId || DEFAULT_LAYOUT_META.areaId;
  const name = raw.name || raw.areaName || context.areaName || DEFAULT_LAYOUT_META.areaName;
  const camera = {
    startX: toNumber(raw.camera?.startX ?? raw.cameraStartX, 0),
    startZoom: toNumber(raw.camera?.startZoom ?? raw.zoomStart, 1),
  };
  const ground = {
    offset: toNumber(raw.ground?.offset ?? raw.groundOffset, DEFAULT_GROUND_OFFSET),
  };
  const layersList = Array.isArray(raw.layers) && raw.layers.length
    ? raw.layers.map((layer, index) => normalizeLayer(layer, index))
    : createDefaultLayers();
  const instancesList = Array.isArray(raw.instances) ? raw.instances : [];
  const normalizedInstances = [];
  let fallbackId = 1;
  for (const inst of instancesList){
    const normalized = normalizeInstance(inst, fallbackId);
    if (normalized.id == null){
      normalized.id = fallbackId;
    }
    fallbackId = Math.max(fallbackId + 1, normalized.id + 1);
    normalizedInstances.push(normalized);
  }

  const collidersList = Array.isArray(raw.colliders) ? raw.colliders : [];
  const normalizedColliders = [];
  let fallbackColliderId = 1;
  for (const collider of collidersList){
    const normalized = normalizeCollider(collider, fallbackColliderId);
    if (normalized.id == null){
      normalized.id = fallbackColliderId;
    }
    fallbackColliderId = Math.max(fallbackColliderId + 1, normalized.id + 1);
    normalizedColliders.push(normalized);
  }

  const drumSkinList = Array.isArray(raw.drumSkins) ? raw.drumSkins : [];
  const normalizedDrumSkins = drumSkinList.map((drum, index) => normalizeDrumSkin(drum, index, layersList));
  const migratedFromInstances = [];
  for (const inst of normalizedInstances) {
    const legacy = inst?.meta?.drumSkin || inst?.meta?.groundSpan || inst?.meta?.stretchQuad || null;
    const normalizedLegacy = normalizeStretchQuadSpec(legacy);
    if (normalizedLegacy) {
      migratedFromInstances.push({
        layerA: inst.layerId,
        layerB: normalizedLegacy.targetLayerId,
        heightA: 0,
        heightB: -(normalizedLegacy.height || 0),
        prefabId: inst.prefabId || '',
        imageURL: inst?.prefab?.imageURL || inst?.prefab?.url || '',
        tileScale: 1,
        visible: true,
      });
      if (inst.meta) {
        delete inst.meta.drumSkin;
        delete inst.meta.groundSpan;
        delete inst.meta.stretchQuad;
      }
    }
  }
  const combinedDrumSkins = [...normalizedDrumSkins];
  migratedFromInstances.forEach((drum) => combinedDrumSkins.push(normalizeDrumSkin(drum, combinedDrumSkins.length, layersList)));

  const meta = raw.meta && typeof raw.meta === 'object' ? { ...raw.meta } : {};
  const activeLayerId = raw.activeLayerId
    || meta.activeLayerId
    || layersList[0]?.id
    || getDefaultSpawnLayerId();

  return {
    id,
    name,
    camera,
    ground,
    layers: layersList,
    instances: normalizedInstances,
    colliders: normalizedColliders,
    drumSkins: combinedDrumSkins,
    meta: {
      ...meta,
      areaId: id,
      areaName: name,
      sourcePath: context.sourcePath ?? meta.sourcePath ?? null,
      repositoryId: context.repositoryId ?? meta.repositoryId ?? null,
    },
    activeLayerId,
  };
}

function buildAreaDescriptor(){
  ensurePlayerSpawn();
  const clonedLayers = layers.map((layer, index) => {
    const normalized = normalizeLayer(layer, index);
    return {
      id: normalized.id,
      name: normalized.name,
      type: normalized.type,
      parallaxSpeed: normalized.parallaxSpeed,
      offsetY: normalized.offsetY,
      separation: normalized.separation,
      scale: normalized.scale,
      source: normalized.source ?? null,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedInstances = instances.map((inst, index) => {
    const normalized = normalizeInstance(inst, inst.id ?? index + 1);
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    return {
      id: normalized.id ?? index + 1,
      prefabId: normalized.prefabId,
      layerId: normalized.layerId,
      position: normalized.position,
      scale: normalized.scale,
      rotationDeg: toNumber(normalized.rotationDeg, 0),
      locked: !!normalized.locked,
      tags: Array.isArray(normalized.tags) ? normalized.tags.map((tag) => String(tag)) : [],
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedColliders = colliders.map((col, index) => {
    const normalized = normalizeCollider(col, col.id ?? index + 1);
    const materialType = typeof normalized.materialType === 'string' ? normalized.materialType.trim() : '';
    const descriptor = {
      id: normalized.id ?? index + 1,
      label: typeof normalized.label === 'string' && normalized.label.trim()
        ? normalized.label.trim()
        : `Collider ${index + 1}`,
      type: normalized.type || 'box',
      shape: normalized.type || 'box',
      left: toNumber(normalized.left, 0) || 0,
      width: Math.max(1, toNumber(normalized.width, 120) || 120),
      topOffset: toNumber(normalized.topOffset, 0) || 0,
      height: Math.max(1, toNumber(normalized.height, 40) || 40),
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
    if (materialType) {
      descriptor.materialType = materialType;
    }
    return descriptor;
  });

  const clonedDrumSkins = drumSkins.map((drum, index) => {
    const normalized = normalizeDrumSkin(drum, drum.id ?? index + 1, layers);
    return { ...normalized };
  });
  nextDrumSkinId = clonedDrumSkins.reduce((maxId, drum) => Math.max(maxId, (drum.id ?? 0) + 1), 1);

  const meta = {
    ...layoutMeta,
    activeLayerId,
  };

  return {
    id: meta.areaId || DEFAULT_LAYOUT_META.areaId,
    name: meta.areaName || DEFAULT_LAYOUT_META.areaName,
    source: 'map-editor',
    camera: {
      startX: cameraX,
      startZoom: zoom,
    },
    ground: {
      offset: getGroundOffset(),
    },
    layers: clonedLayers,
    instances: clonedInstances,
    colliders: clonedColliders,
    drumSkins: clonedDrumSkins,
    meta,
  };
}

async function convertDataToArea(data, context = {}){
  const runtime = await getRuntimeModule();
  return runtime.convertLayoutToArea(data || {}, {
    areaId: context.areaId || context.meta?.areaId || DEFAULT_LAYOUT_META.areaId,
    areaName: context.areaName || context.meta?.areaName || DEFAULT_LAYOUT_META.areaName,
    prefabResolver: (prefabId) => {
      const prefab = prefabs[prefabId];
      return prefab ? JSON.parse(JSON.stringify(prefab)) : null;
    },
  });
}

function getRepositoryEntry(mapId){
  return REPOSITORY_LAYOUTS.find((entry) => entry.id === mapId) || null;
}

async function loadRepositoryMapById(mapId){
  const entry = getRepositoryEntry(mapId) || getRepositoryEntry(DEFAULT_LAYOUT_META.areaId);
  const context = {
    areaId: entry?.id || DEFAULT_LAYOUT_META.areaId,
    areaName: entry?.areaName || entry?.label || DEFAULT_LAYOUT_META.areaName,
    sourcePath: entry?.path || null,
    repositoryId: entry?.id || null,
  };

  await ensureConfiguredPrefabsLoaded();

  try {
    const areaData = entry?.path
      ? await (async () => {
          const response = await fetch(entry.path, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const json = await response.json();
          return convertDataToArea(json, context);
        })()
      : await convertDataToArea({}, context);
    restoreState(areaData);
  } catch (error) {
    console.error('[map-editor] failed to load map from repository', error);
    const fallbackArea = await convertDataToArea({}, context);
    restoreState(fallbackArea);
    alert(`Failed to load map: ${error.message}. Loaded empty layout instead.`);
  }
  historyStack.length = 0;
  pushHistory();
  const select = $('#mapRepoSelect');
  if (select) select.value = context.repositoryId || select.value;
}

function populateRepositorySelect(){
  const select = $('#mapRepoSelect');
  if (!select) return;
  select.innerHTML = '';
  REPOSITORY_LAYOUTS.forEach((entry) => {
    const opt = document.createElement('option');
    opt.value = entry.id;
    opt.textContent = entry.label;
    select.appendChild(opt);
  });
  const targetId = layoutMeta.repositoryId || DEFAULT_LAYOUT_META.repositoryId;
  if (targetId) select.value = targetId;
}

let cameraX = 0;
let zoom = 1;
let debugOverlay = false;

function getGroundOffset(){
  return parseFloat($('#groundOffset').value) || DEFAULT_GROUND_OFFSET;
}

/*** Layer UI & stack ***/
function rebuildActiveLayerSelect(){
  const sel = $('#activeLayerSelect');
  const instLayerSel = $('#instLayer');
  const stretchLayerSel = $('#instStretchLayer');
  sel.innerHTML = '';
  instLayerSel.innerHTML = '';
  if (stretchLayerSel){
    stretchLayerSel.innerHTML = '';
    const noneOpt = document.createElement('option');
    noneOpt.value = '';
    noneOpt.textContent = '—';
    stretchLayerSel.appendChild(noneOpt);
  }
  layers.forEach(layer=>{
    const o = document.createElement('option');
    o.value = layer.id; o.textContent = layer.name;
    sel.appendChild(o);
    const o2 = document.createElement('option');
    o2.value = layer.id; o2.textContent = layer.name;
    instLayerSel.appendChild(o2);
    if (stretchLayerSel){
      const o3 = document.createElement('option');
      o3.value = layer.id; o3.textContent = layer.name;
      stretchLayerSel.appendChild(o3);
    }
  });
  if(!findLayer(activeLayerId) && layers.length){
    activeLayerId = layers[0].id;
  }
  sel.value = activeLayerId;
}
function rebuildLayerStack(){
  const stack = $('#layerStack');
  stack.innerHTML = '';
  layers.forEach(layer=>{
    const div = document.createElement('div');
    div.className = 'layer-item' + (layer.id===activeLayerId ? ' active' : '');
    div.draggable = true;
    div.dataset.layerId = layer.id;
    div.innerHTML = `
      <span>${layer.name}</span>
      <span class="layer-item-type">${layer.type}</span>
    `;
    div.addEventListener('click', () => setActiveLayer(layer.id));
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', layer.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
    });
    div.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    div.addEventListener('drop', e => {
      e.preventDefault();
      const srcId = e.dataTransfer.getData('text/plain');
      const dstId = layer.id;
      if(!srcId || srcId === dstId) return;
      pushHistory();
      const srcIndex = layers.findIndex(l=>l.id===srcId);
      const dstIndex = layers.findIndex(l=>l.id===dstId);
      if(srcIndex<0 || dstIndex<0) return;
      const [moved] = layers.splice(srcIndex,1);
      const insertIndex = srcIndex < dstIndex ? dstIndex-1 : dstIndex;
      layers.splice(insertIndex,0,moved);
      rebuildActiveLayerSelect();
      rebuildLayerStack();
    });
    stack.appendChild(div);
  });
}
function syncActiveLayerFields(){
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  $('#layerParallax').value = layer.parallaxSpeed;
  $('#layerYOffset').value = layer.offsetY;
  $('#layerSep').value = layer.separation;
  $('#layerScale').value = layer.scale;
  rebuildLayerStack();
}
function setActiveLayer(id){
  if(!findLayer(id)) return;
  activeLayerId = id;
  $('#activeLayerSelect').value = id;
  syncActiveLayerFields();
  const first = instances.find(i=>i.layerId === activeLayerId);
  selectedInstId = first ? first.id : null;
  refreshInstanceList();
}
['layerParallax','layerYOffset','layerSep','layerScale'].forEach(id=>{
  $(`#${id}`).addEventListener('input', e=>{
    const layer = findLayer(activeLayerId);
    if(!layer) return;
    const v = parseFloat(e.target.value);
    if(!Number.isFinite(v)) return;
    pushHistory();
    if(id==='layerParallax') layer.parallaxSpeed=v;
    if(id==='layerYOffset') layer.offsetY=v;
    if(id==='layerSep')      layer.separation=v;
    if(id==='layerScale')    layer.scale=v;
  });
});

/*** Duplicate layer ***/
$('#btnDuplicateLayer').addEventListener('click',()=>{
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  pushHistory();
  let baseId = layer.id + '_copy';
  let n = 1;
  while(findLayer(baseId)) baseId = layer.id + '_copy' + (n++);
  const newLayer = JSON.parse(JSON.stringify(layer));
  newLayer.id = baseId;
  newLayer.name = layer.name + ' copy';
  const idx = layers.indexOf(layer);
  layers.splice(idx+1,0,newLayer);
  const clones = instances
    .filter(inst=>inst.layerId===layer.id)
    .map(inst=>{
      const c = JSON.parse(JSON.stringify(inst));
      c.id = nextInstId++;
      c.layerId = newLayer.id;
      return c;
    });
  instances.push(...clones);
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  activeLayerId = newLayer.id;
  syncActiveLayerFields();
  refreshInstanceList();
});

/*** Image loading ***/
function loadImage(url){
  return new Promise(res=>{
    if(!url) return res(null);
    if(imageCache.has(url)) return res(imageCache.get(url));
    const img=new Image();
    img.crossOrigin='anonymous';
    img.onload=()=>{ imageCache.set(url,img); res(img); };
    img.onerror=()=>res(null);
    img.src=url;
  });
}

/*** Prefabs ***/
async function registerPrefab(obj, options = {}){
  const {
    select = true,
    autoPopulate = true,
    silent = false,
    deferRefresh = false,
    prefabId: explicitPrefabId = null,
  } = options;
  const prefab = obj && typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : null;
  if(!prefab || !prefab.structureId || !Array.isArray(prefab.parts)){
    const message = 'Invalid structure JSON';
    if(!silent) alert(message);
    throw new Error(message);
  }

  const candidateIds = [
    explicitPrefabId,
    prefab.id,
    prefab.prefabId,
    prefab.slug,
    prefab.structureId,
  ];
  const resolvedId = candidateIds
    .map((value) => (typeof value === 'string' ? value.trim() : ''))
    .find((value) => !!value);
  if(!resolvedId){
    const message = 'Prefab missing identifier';
    if(!silent) alert(message);
    throw new Error(message);
  }

  prefab.id = resolvedId;
  prefabs[resolvedId]=prefab;
  if(select && !selectedPrefabId) selectedPrefabId=resolvedId;

  for(const part of prefab.parts){
    const t=part.propTemplate||{};
    if(t.url) await loadImage(t.url);
  }

  if(!deferRefresh){
    rebuildPrefabSelect();
  }

  if(autoPopulate && !instances.length && activeLayerId){
    pushHistory();
    addRowOnLayer(activeLayerId,8,resolvedId);
    refreshInstanceList();
  }

  return resolvedId;
}

async function ensureConfiguredPrefabsLoaded(){
  if(prefabBootstrapPromise) return prefabBootstrapPromise;
  prefabBootstrapPromise = (async () => {
    if(!PREFAB_MANIFESTS.length) return { loaded: 0, registered: 0, errors: [] };
    try{
      const module = await import('./js/prefab-catalog.js');
      const loader = module.loadPrefabsFromManifests;
      if(typeof loader !== 'function'){
        throw new Error('Prefab catalog loader unavailable');
      }
      const { prefabs: prefabMap, errors } = await loader(PREFAB_MANIFESTS);
      let registered = 0;
      for(const [id, prefab] of prefabMap.entries()){
        const already = !!prefabs[id];
        await registerPrefab(prefab, {
          prefabId: id,
          select: !selectedPrefabId && !already,
          autoPopulate: false,
          silent: true,
          deferRefresh: true,
        });
        if(!already) registered++;
      }
      rebuildPrefabSelect();
      if(errors?.length){
        const summarize = typeof module.summarizeLoadErrors === 'function'
          ? module.summarizeLoadErrors(errors)
          : null;
        if(summarize){
          console.warn('[map-editor] Some prefabs failed to load\n' + summarize);
        }
      }
      return { loaded: prefabMap.size, registered, errors: errors || [] };
    }catch(error){
      console.error('[map-editor] Failed to load configured prefabs', error);
      return { loaded: 0, registered: 0, errors: [{ type: 'bootstrap', error }] };
    }
  })();
  return prefabBootstrapPromise;
}
async function importDrumSkinImagesFromAssetManifest(){
  let manifest = [];
  try {
    const response = await fetch('./assets/asset-manifest.json', { cache: 'no-cache' });
    manifest = await response.json();
  } catch (error) {
    console.warn('[map-editor] Failed to load asset manifest for drum skins', error);
    return;
  }

  const drumSkinUrls = Array.isArray(manifest)
    ? manifest.filter((entry) => typeof entry === 'string' && entry.startsWith('./assets/prefabs/images/'))
    : [];
  if (!drumSkinUrls.length) return;

  let registered = 0;
  for (const url of drumSkinUrls) {
    const baseName = url.split('/').pop() || '';
    const stem = baseName.replace(/\.[^/.]+$/, '') || 'drum_skin';
    let prefabId = stem;
    let suffix = 1;
    while (prefabs[prefabId]) {
      prefabId = `${stem}_${suffix++}`;
    }

    const img = await loadImage(url);
    if (!img) {
      console.warn('[map-editor] Skipping drum skin import; failed to load image', url);
      continue;
    }

    const prefab = {
      id: prefabId,
      structureId: prefabId,
      isImage: true,
      tags: ['drum-skin', 'drum', 'image'],
      parts: [{
        name: prefabId,
        layer: 'near',
        relX: 0,
        relY: 0,
        propTemplate: {
          id: prefabId,
          w: img.width || 1,
          h: img.height || 1,
          url,
          pivot: 'bottom',
          anchorXPct: 50,
          anchorYPct: 100,
          parallaxX: 1,
          parallaxClampPx: 0,
        },
      }],
      meta: {
        catalog: {
          id: prefabId,
          sourceUrl: url,
        },
        drumSkin: {
          imageURL: url,
        },
      },
    };

    try {
      await registerPrefab(prefab, {
        select: false,
        autoPopulate: false,
        silent: true,
        deferRefresh: true,
        prefabId,
      });
      registered++;
    } catch (error) {
      console.warn('[map-editor] Failed to register drum skin prefab from manifest', { url, error });
    }
  }

  if (registered) {
    rebuildPrefabSelect();
    refreshLibrarySelect();
    refreshDrumSkinList();
  }
}
function registerImagePrefab(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.onload=()=>{
    const base=(file.name||'img').replace(/\.[^/.]+$/,'')||'img';
    let id=`img_${base}`, c=1;
    while(prefabs[id]) id=`img_${base}_${c++}`;
    prefabs[id]={
      id,
      structureId:id,
      isImage:true,
      parts:[{
        name:id,
        layer:'near',
        relX:0,
        relY:0,
        propTemplate:{
          id,
          w:img.width,
          h:img.height,
          url:url,
          pivot:'bottom',
          anchorXPct:50,
          anchorYPct:100
        }
      }]
    };
    imageCache.set(url,img);
    selectedPrefabId=id;
    rebuildPrefabSelect();
    refreshLibrarySelect();
  };
  img.onerror=()=>alert('Failed to load image');
  img.src=url;
}
function rebuildPrefabSelect(){
  const instSel=$('#instPrefab');
  instSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    instSel.appendChild(o);
  });
  if(selectedPrefabId) instSel.value=selectedPrefabId;
  refreshLibrarySelect();
}
function refreshLibrarySelect(){
  const libSel=$('#libPrefab');
  libSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    libSel.appendChild(o);
  });
  if(selectedPrefabId) libSel.value=selectedPrefabId;
}

/*** Instances ***/
function allocSlot(layerId){
  const n=nextSlotByLayer[layerId] ?? 0;
  nextSlotByLayer[layerId]=n+1;
  return n;
}
function makeInstance(layerId,prefabId){
  const grid = GRID_UNIT || 0;
  const existing = instances.filter((inst) => inst.layerId === layerId);
  const baseX = existing.length ? Math.max(...existing.map((inst) => inst.position?.x ?? 0)) + (grid || 100) : 0;
  return {
    id:nextInstId++,
    prefabId,
    layerId,
    position:{ x: Number.isFinite(baseX) ? baseX : 0, y: 0 },
    scale:{ x:1, y:1 },
    rotationDeg:0,
    locked:false,
    tags:[],
    meta:{},
  };
}
function addInstance(layerId,prefabId){
  const layer=findLayer(layerId);
  if(!layer) return;
  const pid=prefabId || selectedPrefabId || Object.keys(prefabs)[0];
  if(!prefabs[pid]) return;
  const inst=makeInstance(layerId,pid);
  instances.push(inst);
  if(layerId===activeLayerId) selectedInstId=inst.id;
}
function addRowOnLayer(layerId,count,prefabId){
  for(let i=0;i<count;i++) addInstance(layerId,prefabId);
}
function getSelectedInstance(){
  return instances.find(i=>i.id===selectedInstId) || null;
}
function deleteSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be removed. Use the placement button to reposition it.');
    return;
  }
  pushHistory();
  const idx=instances.findIndex(i=>i.id===inst.id);
  if(idx>=0) instances.splice(idx,1);
  selectedInstId=null;
  refreshInstanceList();
}
function duplicateSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be duplicated.');
    return;
  }
  pushHistory();
  const dup = JSON.parse(JSON.stringify(inst));
  dup.id = nextInstId++;
  dup.position = normalizePosition(dup.position);
  const grid = GRID_UNIT || 0;
  dup.position.x += grid > 0 ? grid : 50;
  instances.push(dup);
  selectedInstId = dup.id;
  refreshInstanceList();
}
function refreshInstanceList(){
  const list=$('#instList');
  list.innerHTML='';
  const visible=instances.filter(i=>i.layerId===activeLayerId);
  for(const inst of visible){
    const layer=findLayer(inst.layerId);
    if(!layer) continue;
    const div=document.createElement('div');
    div.className='inst'+(inst.id===selectedInstId?' active':'');
    const span=document.createElement('span');
    const pos = normalizePosition(inst.position);
    span.textContent=`${inst.id} · ${inst.prefabId} · x=${pos.x.toFixed(1)}`;
    if(inst.locked){
      const lp=document.createElement('span');
      lp.className='lock-pill';
      lp.textContent='🔒';
      span.appendChild(lp);
    }
    if(isPlayerSpawn(inst)){
      const spawnPill=document.createElement('span');
      spawnPill.className='pill pill--spawn';
      spawnPill.textContent='Player Spawn';
      span.appendChild(spawnPill);
    }
    const pill=document.createElement('span');
    pill.className='pill';
    pill.textContent=layer.name;
    div.appendChild(span);
    div.appendChild(pill);
    div.onclick=()=>{ selectedInstId=inst.id; fillInstEditor(); refreshInstanceList(); };
    list.appendChild(div);
  }
  fillInstEditor();
  syncSpawnHeightField();
}
function fillInstEditor(){
  const inst=getSelectedInstance();
  if(!inst || inst.layerId!==activeLayerId){
    $('#instId').value='';
    $('#instX').value='';
    $('#instLayer').value=activeLayerId||'';
    $('#instLocked').checked=false;
    $('#instScaleX').value='';
    $('#instScaleY').value='';
    $('#instOffY').value='';
    $('#instRot').value='';
    $('#instStretchEnabled').checked = false;
    $('#instStretchLayer').value = '';
    $('#instStretchHeight').value = '';
    $('#instStretchTopOffset').value = '';
    $('#instStretchSlices').value = 24;
    return;
  }
  $('#instId').value=inst.id;
  $('#instPrefab').value=inst.prefabId;
  $('#instLayer').value=inst.layerId;
  const pos = normalizePosition(inst.position);
  $('#instX').value=pos.x.toFixed(1);
  $('#instLocked').checked=!!inst.locked;
  const scale = normalizeScale(inst.scale);
  $('#instScaleX').value=scale.x;
  $('#instScaleY').value=scale.y;
  $('#instOffY').value=pos.y;
  $('#instRot').value=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;
  const stretch = getStretchQuadMeta(inst).spec;
  $('#instStretchEnabled').checked = !!stretch;
  $('#instStretchLayer').value = stretch?.targetLayerId || '';
  $('#instStretchHeight').value = stretch?.height ?? '';
  $('#instStretchTopOffset').value = stretch?.topOffset ?? '';
  $('#instStretchSlices').value = stretch?.slices ?? 24;
}

function getSelectedCollider(){
  if (selectedColliderId == null) return null;
  return colliders.find((c) => c.id === selectedColliderId) || null;
}

function formatColliderNumber(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return '—';
  const fixed = Math.abs(num) >= 100 ? num.toFixed(0) : num.toFixed(1);
  return fixed.replace(/\.0$/, '');
}

function refreshColliderList(){
  const list = $('#colliderList');
  if (!list) return;
  list.innerHTML = '';
  for (const col of colliders){
    const div = document.createElement('div');
    div.className = 'collider' + (col.id === selectedColliderId ? ' active' : '');
    const label = typeof col.label === 'string' && col.label.trim()
      ? col.label.trim()
      : `Collider ${col.id}`;
    const title = document.createElement('span');
    title.textContent = `${col.id} · ${label}`;
    const left = toNumber(col.left, 0);
    const width = Math.max(0, toNumber(col.width, 0));
    const topOffset = toNumber(col.topOffset, 0);
    const height = Math.max(0, toNumber(col.height, 0));
    const meta = document.createElement('span');
    const materialType = typeof col.materialType === 'string' && col.materialType.trim() ? col.materialType.trim() : '';
    const stats = `x:${formatColliderNumber(left)} w:${formatColliderNumber(width)} y:${formatColliderNumber(topOffset)} h:${formatColliderNumber(height)}`;
    meta.textContent = materialType ? `${stats} · material:${materialType}` : stats;
    div.appendChild(title);
    div.appendChild(meta);
    div.onclick = () => {
      selectedColliderId = col.id;
      syncColliderFields();
      refreshColliderList();
    };
    list.appendChild(div);
  }
  syncColliderFields();
}

function syncColliderFields(){
  const collider = getSelectedCollider();
  const idField = $('#colliderId');
  if (idField) idField.value = collider?.id ?? '';
  const labelField = $('#colliderLabel');
  if (labelField) labelField.value = collider?.label ?? '';
  const leftField = $('#colliderLeft');
  if (leftField) leftField.value = collider ? String(toNumber(collider.left, 0)) : '';
  const widthField = $('#colliderWidth');
  if (widthField) widthField.value = collider ? String(Math.max(1, toNumber(collider.width, 0))) : '';
  const topField = $('#colliderTopOffset');
  if (topField) topField.value = collider ? String(toNumber(collider.topOffset, 0)) : '';
  const heightField = $('#colliderHeight');
  if (heightField) heightField.value = collider ? String(Math.max(1, toNumber(collider.height, 0))) : '';
  const materialField = $('#colliderMaterialType');
  if (materialField) materialField.value = collider && typeof collider.materialType === 'string' ? collider.materialType : '';
  const removeBtn = $('#btnDeleteCollider');
  if (removeBtn) removeBtn.disabled = !collider;
}

function resolveDrumSkinPrefabTexture(prefab) {
  if (!prefab || typeof prefab !== 'object') return '';
  const meta = typeof prefab.meta === 'object' && prefab.meta ? prefab.meta : {};
  const drumMeta = typeof meta.drumSkin === 'object' && meta.drumSkin ? meta.drumSkin : {};
  const candidates = [drumMeta.imageURL, drumMeta.url, prefab.imageURL, prefab.url];
  if (Array.isArray(prefab.parts)) {
    for (const part of prefab.parts) {
      if (part?.propTemplate?.url) {
        candidates.push(part.propTemplate.url);
        if (prefab.isImage) break;
      }
    }
  }
  return candidates.map((value) => (typeof value === 'string' ? value.trim() : '')).find(Boolean) || '';
}

function refreshDrumSkinList() {
  const list = $('#drumSkinList');
  if (!list) return;
  const parallaxLayers = layers.filter((layer) => layer.type === 'parallax');
  const drumSkinPrefabs = Object.entries(prefabs)
    .map(([id, prefab]) => ({ id, prefab }))
    .filter(({ prefab }) => {
      if (!prefab || typeof prefab !== 'object') return false;
      const tags = Array.isArray(prefab.tags) ? prefab.tags.map((tag) => String(tag).toLowerCase()) : [];
      const hasDrumTag = tags.includes('drum-skin') || tags.includes('drumskin') || tags.includes('drum');
      return prefab.isImage || hasDrumTag;
    })
    .sort((a, b) => a.id.localeCompare(b.id));
  list.innerHTML = '';
  if (!drumSkins.length) {
    const empty = document.createElement('div');
    empty.style.color = 'var(--muted)';
    empty.textContent = 'No drum skins yet – add one to span between parallax layers.';
    list.appendChild(empty);
    return;
  }

  for (const drum of drumSkins) {
    const card = document.createElement('div');
    card.style.border = '1px solid var(--line)';
    card.style.borderRadius = '8px';
    card.style.padding = '6px';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = '4px';

    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.gap = '6px';
    const title = document.createElement('strong');
    title.textContent = `Drum ${drum.id}`;
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => {
      pushHistory();
      drumSkins = drumSkins.filter((item) => item.id !== drum.id);
      refreshDrumSkinList();
    };
    header.appendChild(title);
    header.appendChild(removeBtn);
    card.appendChild(header);

    const row1 = document.createElement('div');
    row1.className = 'row';
    const layerAField = document.createElement('select');
    layerAField.value = drum.layerA || '';
    parallaxLayers.forEach((layer) => {
      const opt = document.createElement('option');
      opt.value = layer.id;
      opt.textContent = layer.name || layer.id;
      layerAField.appendChild(opt);
    });
    layerAField.onchange = () => {
      pushHistory();
      drum.layerA = layerAField.value;
      refreshDrumSkinList();
    };
    const layerBField = layerAField.cloneNode(true);
    layerBField.value = drum.layerB || '';
    layerBField.onchange = () => {
      pushHistory();
      drum.layerB = layerBField.value;
      refreshDrumSkinList();
    };
    const labelA = document.createElement('label');
    labelA.style.flex = '1';
    labelA.innerHTML = '<span>Layer A</span>';
    labelA.appendChild(layerAField);
    const labelB = document.createElement('label');
    labelB.style.flex = '1';
    labelB.innerHTML = '<span>Layer B</span>';
    labelB.appendChild(layerBField);
    row1.appendChild(labelA);
    row1.appendChild(labelB);
    card.appendChild(row1);

    const row2 = document.createElement('div');
    row2.className = 'row';
    const heightAField = document.createElement('input');
    heightAField.type = 'number';
    heightAField.step = '1';
    heightAField.value = drum.heightA ?? 0;
    heightAField.onchange = () => {
      const val = toNumber(heightAField.value, drum.heightA);
      if (val === drum.heightA) return;
      pushHistory();
      drum.heightA = val;
      refreshDrumSkinList();
    };
    const heightBField = document.createElement('input');
    heightBField.type = 'number';
    heightBField.step = '1';
    heightBField.value = drum.heightB ?? 0;
    heightBField.onchange = () => {
      const val = toNumber(heightBField.value, drum.heightB);
      if (val === drum.heightB) return;
      pushHistory();
      drum.heightB = val;
      refreshDrumSkinList();
    };
    const heightALabel = document.createElement('label');
    heightALabel.style.flex = '1';
    heightALabel.innerHTML = '<span>Height offset A</span>';
    heightALabel.appendChild(heightAField);
    const heightBLabel = document.createElement('label');
    heightBLabel.style.flex = '1';
    heightBLabel.innerHTML = '<span>Height offset B</span>';
    heightBLabel.appendChild(heightBField);
    row2.appendChild(heightALabel);
    row2.appendChild(heightBLabel);
    card.appendChild(row2);

    const row3 = document.createElement('div');
    row3.className = 'row';
    const prefabField = document.createElement('select');
    const blankOpt = document.createElement('option');
    blankOpt.value = '';
    blankOpt.textContent = 'Custom URL';
    prefabField.appendChild(blankOpt);
    for (const { id } of drumSkinPrefabs) {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = id;
      prefabField.appendChild(opt);
    }
    const selectedPrefabId = drum.prefabId || drum.textureId || '';
    prefabField.value = selectedPrefabId;
    prefabField.onchange = () => {
      pushHistory();
      drum.prefabId = prefabField.value;
      drum.textureId = prefabField.value;
      if (!drum.imageURL && drum.prefabId) {
        const chosen = prefabs[drum.prefabId];
        const resolved = resolveDrumSkinPrefabTexture(chosen);
        if (resolved) {
          drum.imageURL = resolved;
        }
      }
      refreshDrumSkinList();
    };

    const urlField = document.createElement('input');
    urlField.type = 'text';
    urlField.value = drum.imageURL || '';
    urlField.placeholder = 'Image URL (tiled)';
    urlField.onchange = () => {
      pushHistory();
      drum.imageURL = urlField.value.trim();
      refreshDrumSkinList();
    };
    const scaleField = document.createElement('input');
    scaleField.type = 'number';
    scaleField.step = '0.05';
    scaleField.min = '0.05';
    scaleField.value = drum.tileScale ?? 1;
    scaleField.onchange = () => {
      const val = toNumber(scaleField.value, drum.tileScale) || 1;
      if (val === drum.tileScale) return;
      pushHistory();
      drum.tileScale = val;
      refreshDrumSkinList();
    };
    const prefabLabel = document.createElement('label');
    prefabLabel.style.flex = '0.9';
    prefabLabel.innerHTML = '<span>Prefab</span>';
    prefabLabel.appendChild(prefabField);
    const urlLabel = document.createElement('label');
    urlLabel.style.flex = '1';
    urlLabel.innerHTML = '<span>Image URL</span>';
    urlLabel.appendChild(urlField);
    const scaleLabel = document.createElement('label');
    scaleLabel.style.flex = '0.8';
    scaleLabel.innerHTML = '<span>Tile scale</span>';
    scaleLabel.appendChild(scaleField);
    row3.appendChild(prefabLabel);
    row3.appendChild(urlLabel);
    row3.appendChild(scaleLabel);
    card.appendChild(row3);

    const missingTexture = !prefabField.value && !urlField.value;
    if (missingTexture) {
      const warning = document.createElement('div');
      warning.textContent = 'Select a drum skin prefab or provide an image URL.';
      warning.style.color = '#eab308';
      warning.style.fontSize = '10px';
      warning.style.marginTop = '2px';
      card.appendChild(warning);
    }
    prefabField.style.borderColor = missingTexture ? '#eab308' : 'var(--line)';
    urlField.style.borderColor = missingTexture ? '#eab308' : 'var(--line)';

    const row4 = document.createElement('div');
    row4.style.display = 'flex';
    row4.style.alignItems = 'center';
    row4.style.gap = '8px';
    const visibleField = document.createElement('input');
    visibleField.type = 'checkbox';
    visibleField.checked = drum.visible !== false;
    visibleField.onchange = () => {
      pushHistory();
      drum.visible = visibleField.checked;
    };
    const visibleLabel = document.createElement('label');
    visibleLabel.style.display = 'flex';
    visibleLabel.style.alignItems = 'center';
    visibleLabel.style.gap = '6px';
    visibleLabel.appendChild(visibleField);
    const text = document.createElement('span');
    text.textContent = 'Visible';
    text.style.color = 'var(--muted)';
    visibleLabel.appendChild(text);
    row4.appendChild(visibleLabel);
    card.appendChild(row4);

    list.appendChild(card);
  }
}

function addDrumSkin() {
  const parallaxLayers = layers.filter((layer) => layer.type === 'parallax');
  const layerA = parallaxLayers[0]?.id || 'bg1';
  const layerB = parallaxLayers[1]?.id || layerA;
  const drumSkinPrefabs = Object.entries(prefabs)
    .map(([id, prefab]) => ({ id, prefab }))
    .filter(({ prefab }) => {
      if (!prefab || typeof prefab !== 'object') return false;
      const tags = Array.isArray(prefab.tags) ? prefab.tags.map((tag) => String(tag).toLowerCase()) : [];
      const hasDrumTag = tags.includes('drum-skin') || tags.includes('drumskin') || tags.includes('drum');
      return prefab.isImage || hasDrumTag;
    })
    .sort((a, b) => a.id.localeCompare(b.id));
  const defaultPrefabId = drumSkinPrefabs[0]?.id || '';
  const defaultPrefabUrl = defaultPrefabId ? resolveDrumSkinPrefabTexture(prefabs[defaultPrefabId]) : '';
  pushHistory();
  drumSkins.push({
    id: nextDrumSkinId++,
    layerA,
    layerB,
    heightA: 0,
    heightB: 0,
    prefabId: defaultPrefabId,
    textureId: defaultPrefabId,
    imageURL: defaultPrefabUrl,
    tileScale: 1,
    visible: true,
  });
  refreshDrumSkinList();
}

function updateSelectedColliderFromFields(){
  const collider = getSelectedCollider();
  if (!collider) return;
  let changed = false;

  const labelField = $('#colliderLabel');
  if (labelField){
    const newLabel = labelField.value.trim();
    if (newLabel !== (collider.label ?? '')){
      if (!changed) pushHistory();
      changed = true;
      collider.label = newLabel;
    }
  }

  const leftField = $('#colliderLeft');
  if (leftField){
    const value = parseFloat(leftField.value);
    if (Number.isFinite(value) && value !== collider.left){
      if (!changed) pushHistory();
      changed = true;
      collider.left = value;
    }
  }

  const widthField = $('#colliderWidth');
  if (widthField){
    const value = parseFloat(widthField.value);
    if (Number.isFinite(value) && value > 0 && value !== collider.width){
      if (!changed) pushHistory();
      changed = true;
      collider.width = Math.max(1, value);
    }
  }

  const topField = $('#colliderTopOffset');
  if (topField){
    const value = parseFloat(topField.value);
    if (Number.isFinite(value) && value !== collider.topOffset){
      if (!changed) pushHistory();
      changed = true;
      collider.topOffset = value;
    }
  }

  const heightField = $('#colliderHeight');
  if (heightField){
    const value = parseFloat(heightField.value);
    if (Number.isFinite(value) && value > 0 && value !== collider.height){
      if (!changed) pushHistory();
      changed = true;
      collider.height = Math.max(1, value);
    }
  }

  const materialField = $('#colliderMaterialType');
  if (materialField){
    const raw = materialField.value.trim();
    const normalized = raw || null;
    const previous = typeof collider.materialType === 'string' ? collider.materialType : null;
    if (normalized !== previous){
      if (!changed) pushHistory();
      changed = true;
      collider.materialType = normalized;
    }
  }

  if (changed){
    refreshColliderList();
  }
}

function removeSelectedCollider(){
  const collider = getSelectedCollider();
  if (!collider) return;
  const idx = colliders.findIndex((c) => c.id === collider.id);
  if (idx === -1) return;
  pushHistory();
  colliders.splice(idx, 1);
  const fallback = colliders[idx] || colliders[idx - 1] || null;
  selectedColliderId = fallback?.id ?? null;
  refreshColliderList();
}

function enterColliderPlacement(){
  if (colliderPlacementMode){
    exitColliderPlacement();
    return;
  }
  exitSpawnPlacement();
  colliderPlacementMode = true;
  activeColliderDrag = null;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('collider-mode');
}

function exitColliderPlacement(){
  colliderPlacementMode = false;
  activeColliderDrag = null;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('collider-mode');
}

/*** Instance editor bindings ***/
function updateSelectedInstanceFromFields(){
  const inst = getSelectedInstance();
  if(!inst || inst.layerId !== activeLayerId) return;

  let changed = false;

  const pid = $('#instPrefab').value;
  if(prefabs[pid] && pid !== inst.prefabId){
    if(!changed) pushHistory();
    changed = true;
    inst.prefabId = pid;
  }

  const newLayerId = $('#instLayer').value;
  if(findLayer(newLayerId) && newLayerId !== inst.layerId){
    if(!changed) pushHistory();
    changed = true;
    inst.layerId = newLayerId;
  }

  const locked = $('#instLocked').checked;
  if(locked !== !!inst.locked){
    if(!changed) pushHistory();
    changed = true;
    inst.locked = locked;
  }

  inst.scale = normalizeScale(inst.scale);
  inst.position = normalizePosition(inst.position);

  const sx = parseFloat($('#instScaleX').value);
  if(Number.isFinite(sx) && sx !== inst.scale.x){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.x = Math.max(0.05, sx);
  }

  const sy = parseFloat($('#instScaleY').value);
  if(Number.isFinite(sy) && sy !== inst.scale.y){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.y = Math.max(0.05, sy);
  }

  const offY = parseFloat($('#instOffY').value);
  if(Number.isFinite(offY) && offY !== inst.position.y){
    if(!changed) pushHistory();
    changed = true;
    inst.position.y = offY;
  }

  const rot = parseFloat($('#instRot').value);
  if(Number.isFinite(rot) && rot !== inst.rotationDeg){
    if(!changed) pushHistory();
    changed = true;
    inst.rotationDeg = rot;
  }

  const xVal = parseFloat($('#instX').value);
  if(Number.isFinite(xVal)){
    const grid = GRID_UNIT || 0;
    let target = xVal;
    if(grid > 0){
      target = Math.round(target / grid) * grid;
      $('#instX').value = target.toFixed(1);
    }
    if(target !== inst.position.x){
      if(!changed) pushHistory();
      changed = true;
      inst.position.x = target;
    }
  }

  const stretchEnabled = $('#instStretchEnabled').checked;
  const stretchTarget = ($('#instStretchLayer').value || '').trim();
  const stretchHeight = parseFloat($('#instStretchHeight').value);
  const stretchTopOffset = parseFloat($('#instStretchTopOffset').value);
  const stretchSlices = parseInt($('#instStretchSlices').value, 10);

  const currentStretch = getStretchQuadMeta(inst);
  const nextStretch = (() => {
    if (!stretchEnabled) return null;
    const normalizedHeight = Number.isFinite(stretchHeight) ? stretchHeight : null;
    if (!stretchTarget || normalizedHeight === null || normalizedHeight <= 0){
      return null;
    }
    return {
      targetLayerId: stretchTarget,
      height: normalizedHeight,
      topOffset: Number.isFinite(stretchTopOffset) ? stretchTopOffset : 0,
      slices: Number.isFinite(stretchSlices) ? clamp(Math.round(stretchSlices), 4, 80) : 24,
    };
  })();

  const serializeSpec = (spec) => (spec ? JSON.stringify(spec) : null);
  if (serializeSpec(currentStretch.spec) !== serializeSpec(nextStretch)){
    if(!changed) pushHistory();
    changed = true;
    if(!inst.meta || typeof inst.meta !== 'object') inst.meta = {};
    if(nextStretch){
      inst.meta.stretchQuad = nextStretch;
      if (currentStretch.key && currentStretch.key !== 'stretchQuad'){
        delete inst.meta[currentStretch.key];
      }
    } else {
      delete inst.meta.stretchQuad;
      if (currentStretch.key){
        delete inst.meta[currentStretch.key];
      }
    }
  }

  if(changed){
    refreshInstanceList();
  }
}

['instPrefab','instLayer','instLocked',
 'instScaleX','instScaleY','instOffY','instRot','instX',
 'instStretchEnabled','instStretchLayer','instStretchHeight','instStretchTopOffset','instStretchSlices'
].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedInstanceFromFields);
  el.addEventListener('blur', updateSelectedInstanceFromFields);
});

['colliderLabel','colliderLeft','colliderWidth','colliderTopOffset','colliderHeight','colliderMaterialType'].forEach(id => {
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedColliderFromFields);
  el.addEventListener('blur', updateSelectedColliderFromFields);
});

const addColliderButton = document.getElementById('btnAddCollider');
if (addColliderButton){
  addColliderButton.addEventListener('click', () => {
    enterColliderPlacement();
  });
}
const removeColliderButton = document.getElementById('btnDeleteCollider');
if (removeColliderButton){
  removeColliderButton.addEventListener('click', () => {
    removeSelectedCollider();
  });
}

/*** Camera & Zoom ***/
function setCameraX(v){
  cameraX=clamp(v,-4000,4000);
  $('#camSlider').value=cameraX;
  $('#camNum').value=cameraX;
}
function setZoom(v){
  zoom=clamp(v,0.5,2.0);
  $('#zoomSlider').value=zoom;
  $('#zoomNum').value=zoom.toFixed(2);
}
$('#camSlider').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#camNum').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#zoomSlider').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));
$('#zoomNum').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));

/*** Canvas & Render ***/
const canvas=document.getElementById('sceneCanvas');
const ctx=canvas.getContext('2d',{alpha:true,desynchronized:true});

function resizeCanvas(){
  const rect=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const w=Math.max(1,rect.width*dpr);
  const h=Math.max(1,rect.height*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
  }
}
function layerDrawOrder(layer){
  return layers.indexOf(layer);
}
function partOrder(part){
  if(part.layer==='far') return 0;
  if(part.layer==='near') return 2;
  return 1;
}

function render(){
  resizeCanvas();
  const dpr=window.devicePixelRatio||1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  ctx.clearRect(0,0,W,H);

  // sky
  const sky=ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,"rgba(59,63,69,0.9)");
  sky.addColorStop(0.5,"rgba(80,89,96,0.5)");
  sky.addColorStop(1,"rgba(32,38,50,0.0)");
  ctx.fillStyle=sky;
  ctx.fillRect(0,0,W,H);

  // treeline
  ctx.save();
  ctx.translate(0,H*0.46);
  ctx.beginPath();
  ctx.moveTo(0,20);
  const steps=24, step=W/steps;
  for(let i=0;i<=steps;i++){
    const h=(i%2===0)?-28:-46;
    ctx.lineTo(i*step,h);
  }
  ctx.lineTo(W,20);
  ctx.closePath();
  ctx.fillStyle="rgba(22,51,33,0.9)";
  ctx.fill();
  ctx.restore();

  const dbg=[];
  const renderList=[];
  for(const inst of instances){
    const layer=findLayer(inst.layerId);
    const prefab=prefabs[inst.prefabId];
    if(!layer) continue;
    if(!prefab && !isPlayerSpawn(inst)) continue;
    renderList.push({inst,layer,prefab});
  }
  renderList.sort((a,b)=>layerDrawOrder(a.layer)-layerDrawOrder(b.layer));

  const retX=W/2;
  const retY=groundY - 8*zoom;

  for(const {inst,layer,prefab} of renderList){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const instRot=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;

    if(isPlayerSpawn(inst)){
      const baseOffset=(pos.x - cameraX*par)*zoom;
      const rootScreenX=W/2 + baseOffset;
      const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - 20*zoom);
      ctx.strokeStyle='#38bdf8';
      ctx.fillStyle='rgba(56,189,248,0.18)';
      ctx.lineWidth=1.2;
      const radius=10*zoom;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-radius,0);
      ctx.lineTo(radius,0);
      ctx.moveTo(0,-radius);
      ctx.lineTo(0,radius);
      ctx.stroke();
      ctx.fillStyle='#38bdf8';
      ctx.font=`${10*zoom}px ui-monospace,Menlo,Consolas`;
      ctx.textAlign='center';
      ctx.fillText('Player Spawn',0,-radius-6);
      ctx.restore();

      if(debugOverlay){
        dbg.push(`spawn @${layer.name} x=${pos.x.toFixed(1)}`);
      }
      continue;
    }

    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    const dxScreen = rootScreenX - retX;

    if(prefab.isImage){
      const part=prefab.parts[0];
      const t=part.propTemplate||{};
      const img=imageCache.get(t.url);
      if(!img) continue;
      const w=t.w || img.width;
      const h=t.h || img.height;
      const {ax,ay}=computeAnchor(t);
      ctx.save();
      ctx.translate(rootScreenX,rootScreenY);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));
      ctx.drawImage(img,-ax,-ay,w,h);
      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.2:0.7;
        ctx.strokeRect(-ax,-ay,w,h);
        dbg.push(`img ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)}`);
      }
      ctx.restore();
      continue;
    }

    // Structured prefab: compute shared t from root part
    const rootPart = prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!rootPart) continue;
    const rootT = rootPart.propTemplate || {};
    const rootRelY = rootPart.relY || 0;

    const {t: sharedT, radiusPx} = computeTFromDx(rootT.kf || {}, dxScreen);
    const rootPose = evalKfPose(rootT.kf || {}, sharedT);

    const parts=[...prefab.parts].sort((a,b)=>
      (partOrder(a)-partOrder(b)) || ((a.z||0)-(b.z||0))
    );

    for(const part of parts){
      const t = part.propTemplate || {};
      const img = imageCache.get(t.url);
      const relX = part.relX || 0;
      const relY = part.relY || 0;

      const partPose = evalKfPose(t.kf || {}, sharedT);

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - rootRelY*layerScale*zoom);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));

      // apply root pose
      applyPose(ctx, rootPose);

      // part local offset
      ctx.translate(relX, -relY);

      // apply part pose
      applyPose(ctx, partPose);

      const w = t.w || 100;
      const h = t.h || 100;
      const {ax,ay} = computeAnchor(t);

      if(img && img.complete && img.naturalWidth){
        ctx.drawImage(img,-ax,-ay,w,h);
      } else {
        ctx.fillStyle="rgba(148,163,253,0.18)";
        ctx.fillRect(-ax,-ay,w,h);
      }

      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.1:0.6;
        ctx.strokeRect(-ax,-ay,w,h);
        ctx.fillStyle="#e5e7eb";
        ctx.font="7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`${part.name}`, -ax, -ay-3);
      }

      ctx.restore();
    }

    if(debugOverlay){
      const isSel = inst.id === selectedInstId;
      dbg.push(
        `struct ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)} t=${sharedT.toFixed(3)} rPx=${radiusPx.toFixed(1)}${inst.locked?' 🔒':''}`
      );

      if (isSel && rootT.kf){
        const towerY = rootScreenY - rootRelY*layerScale*zoom;

        ctx.save();
        ctx.lineWidth = 0.8;

        // Ray from reticle to tower horizontally
        ctx.strokeStyle = "rgba(56,189,248,0.9)";
        ctx.beginPath();
        ctx.moveTo(retX, retY);
        ctx.lineTo(rootScreenX, retY);
        ctx.stroke();

        // Down to tower
        ctx.beginPath();
        ctx.moveTo(rootScreenX, retY);
        ctx.lineTo(rootScreenX, towerY);
        ctx.stroke();

        // Radius band around reticle in screen-space
        const r = radiusPx;
        ctx.strokeStyle = "rgba(148,163,253,0.35)";
        ctx.beginPath();
        ctx.moveTo(retX - r, retY);
        ctx.lineTo(retX + r, retY);
        ctx.stroke();

        // Labels
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`dx=${dxScreen.toFixed(1)}px`, rootScreenX+4, towerY-18);
        ctx.fillText(`t=${sharedT.toFixed(2)}`, rootScreenX+4, towerY-9);
        ctx.fillText(`rPx=${r.toFixed(1)}`, retX+4, retY+12);

        ctx.restore();
      }
    }
  }

  if(colliders.length){
    ctx.save();
    ctx.lineWidth = 1.5;
    for(const collider of colliders){
      const leftWorld = toNumber(collider.left, 0);
      const widthWorld = Math.max(0, toNumber(collider.width, 0));
      const topOffset = toNumber(collider.topOffset, 0);
      const heightWorld = Math.max(0, toNumber(collider.height, 0));
      if(widthWorld <= 0 || heightWorld <= 0) continue;
      const screenLeft = W/2 + (leftWorld - cameraX) * zoom;
      const screenTop = groundY + topOffset * zoom;
      const screenWidth = widthWorld * zoom;
      const screenHeight = heightWorld * zoom;
      if(screenWidth <= 0 || screenHeight <= 0) continue;
      const isSelected = collider.id === selectedColliderId;
      ctx.fillStyle = isSelected ? 'rgba(239,68,68,0.18)' : 'rgba(148,163,184,0.12)';
      ctx.strokeStyle = isSelected ? 'rgba(239,68,68,0.65)' : 'rgba(148,163,184,0.55)';
      ctx.fillRect(screenLeft, screenTop, screenWidth, screenHeight);
      ctx.strokeRect(screenLeft, screenTop, screenWidth, screenHeight);
      const label = typeof collider.label === 'string' ? collider.label.trim() : '';
      if(label){
        ctx.save();
        ctx.fillStyle = isSelected ? '#fecaca' : '#cbd5f5';
        const fontSize = Math.max(7, 9 * zoom);
        ctx.font = `${fontSize}px ui-monospace,Menlo,Consolas`;
        ctx.textBaseline = 'top';
        ctx.fillText(label, screenLeft + 4, screenTop + 2);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  // ground line
  ctx.save();
  ctx.strokeStyle="rgba(250,204,21,0.35)";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(0,groundY+0.5);
  ctx.lineTo(W,groundY+0.5);
  ctx.stroke();
  ctx.restore();

  // reticle
  const size=10*zoom;
  ctx.save();
  ctx.strokeStyle="#facc15";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(retX-size,retY);
  ctx.lineTo(retX+size,retY);
  ctx.moveTo(retX,retY-size);
  ctx.lineTo(retX,retY+size);
  ctx.stroke();
  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.arc(retX,retY,2.5,0,Math.PI*2);
  ctx.fill();
  ctx.font="8px ui-monospace,Menlo,Consolas";
  ctx.fillText("Cam/Player",retX+6,retY-6);
  ctx.restore();

  $('#debugText').textContent = debugOverlay
    ? `camX=${cameraX} zoom=${zoom.toFixed(2)} activeLayer=${activeLayerId} · instances=${instances.length}\n` + dbg.join('\n')
    : '';

  requestAnimationFrame(render);
}

/*** Picking & drag ***/
function pickInstanceAt(clientX,clientY){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const py=clientY-rect.top;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  const candidates=instances
    .filter(i=>i.layerId===activeLayerId)
    .map(inst=>{
      const layer=findLayer(inst.layerId);
      const prefab=prefabs[inst.prefabId];
      return layer && (prefab || isPlayerSpawn(inst)) ? {inst,layer,prefab}:null;
    })
    .filter(Boolean);

  candidates.sort((a,b)=>layerDrawOrder(b.layer)-layerDrawOrder(a.layer));

  for(const {inst,layer,prefab} of candidates){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    if(isPlayerSpawn(inst)){
      const radius = 12 * zoom;
      const centerX = rootScreenX;
      const centerY = rootScreenY - 20 * zoom;
      const left = centerX - radius;
      const right = centerX + radius;
      const top = centerY - radius;
      const bottom = centerY + radius;
      if(px>=left && px<=right && py>=top && py<=bottom) return inst;
      continue;
    }

    let part;
    if(prefab.isImage) part=prefab.parts[0];
    else part=prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!part) continue;
    const t=part.propTemplate||{};
    const w=t.w || 100;
    const h=t.h || 100;
    const {ax,ay}=computeAnchor(t);
    const sc=layerScale*zoom*scale.x;

    const left=rootScreenX - ax*sc;
    const top =rootScreenY - h*sc;
    const right=left + w*sc;
    const bottom=top + h*sc;
    if(px>=left && px<=right && py>=top && py<=bottom) return inst;
  }
  return null;
}

let draggingCamera=false;
let draggingInst=null;
let lastX=0;
let draggingInstOffset=0;

function pointerClientToWorldX(clientX, layer){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const par=layer?.parallax ?? 1;
  const baseOffset=(px - W/2)/zoom;
  return baseOffset + cameraX*par;
}

function pointerClientToGroundOffset(clientY){
  const rect = canvas.getBoundingClientRect();
  const py = clientY - rect.top;
  const dpr = window.devicePixelRatio || 1;
  const H = canvas.height / dpr;
  const groundY = H - getGroundOffset();
  const scale = zoom || 1;
  return (py - groundY) / scale;
}

function pickColliderAt(clientX, clientY){
  if (!colliders.length) return null;
  const worldX = pointerClientToWorldX(clientX, { parallax: 1 });
  const offsetY = pointerClientToGroundOffset(clientY);
  for (let i = colliders.length - 1; i >= 0; i--){
    const col = colliders[i];
    const left = toNumber(col.left, 0);
    const width = Math.max(0, toNumber(col.width, 0));
    const topOffset = toNumber(col.topOffset, 0);
    const height = Math.max(0, toNumber(col.height, 0));
    const right = left + width;
    const bottomOffset = topOffset + height;
    if (worldX >= left && worldX <= right && offsetY >= topOffset && offsetY <= bottomOffset){
      return col;
    }
  }
  return null;
}

function pointerDown(ev){
  const t=ev.touches?ev.touches[0]:ev;
  lastX=t.clientX;
  if(spawnPlacementMode){
    const spawn = ensurePlayerSpawn();
    const layer = findLayer(spawn.layerId) || findLayer(getDefaultSpawnLayerId());
    if(layer){
      pushHistory();
      const worldX = pointerClientToWorldX(t.clientX, layer);
      const grid = GRID_UNIT || 0;
      const snapped = grid > 0 ? Math.round(worldX / grid) * grid : worldX;
      spawn.position = normalizePosition(spawn.position);
      spawn.position.x = snapped;
      spawn.locked = true;
      selectedInstId = spawn.id;
    refreshInstanceList();
  }
    exitSpawnPlacement();
    return;
  }
  if(colliderPlacementMode){
    const worldX = pointerClientToWorldX(t.clientX, { parallax: 1 });
    const offsetY = pointerClientToGroundOffset(t.clientY);
    pushHistory();
    const id = nextColliderId++;
    const collider = {
      id,
      label: `Collider ${id}`,
      type: 'box',
      left: worldX,
      width: 8,
      topOffset: offsetY,
      height: 8,
      materialType: null,
      meta: {},
    };
    colliders.push(collider);
    selectedColliderId = collider.id;
    activeColliderDrag = { collider, startX: worldX, startOffset: offsetY, mode: 'new' };
    refreshColliderList();
    return;
  }
  const colliderHit = pickColliderAt(t.clientX, t.clientY);
  if (colliderHit){
    selectedColliderId = colliderHit.id;
    refreshColliderList();
    syncColliderFields();
    return;
  }
  const hit=pickInstanceAt(t.clientX,t.clientY);
  if(hit){
    selectedInstId=hit.id;
    const inst=getSelectedInstance();
    if(inst && !inst.locked){
      pushHistory();
      draggingInst=inst;
      const layerForDrag = findLayer(inst.layerId);
      if(layerForDrag){
        inst.position = normalizePosition(inst.position);
        draggingInstOffset = pointerClientToWorldX(t.clientX, layerForDrag) - inst.position.x;
      } else {
        draggingInstOffset = 0;
      }
    }
    refreshInstanceList();
  }else{
    pushHistory();
    draggingCamera=true;
  }
}
function pointerMove(ev){
  if(!draggingCamera && !draggingInst && !activeColliderDrag) return;
  const t=ev.touches?ev.touches[0]:ev;
  if(activeColliderDrag){
    const collider = activeColliderDrag.collider;
    if(!collider) { activeColliderDrag = null; return; }
    const worldX = pointerClientToWorldX(t.clientX, { parallax: 1 });
    const offsetY = pointerClientToGroundOffset(t.clientY);
    const minSize = 8;
    const left = Math.min(worldX, activeColliderDrag.startX);
    const width = Math.max(minSize, Math.abs(worldX - activeColliderDrag.startX));
    const topOffset = Math.min(offsetY, activeColliderDrag.startOffset);
    const height = Math.max(minSize, Math.abs(offsetY - activeColliderDrag.startOffset));
    collider.left = left;
    collider.width = width;
    collider.topOffset = topOffset;
    collider.height = height;
    refreshColliderList();
    return;
  }
  const dx=t.clientX-lastX;
  lastX=t.clientX;
  if(draggingInst){
    if(draggingInst.locked){ draggingInst=null; return; }
    const layer=findLayer(draggingInst.layerId);
    if(!layer) return;
    const worldX = pointerClientToWorldX(t.clientX, layer) - draggingInstOffset;
    const grid=GRID_UNIT||0;
    const snapped = grid>0 ? Math.round(worldX/grid)*grid : worldX;
    draggingInst.position = normalizePosition(draggingInst.position);
    if(snapped !== draggingInst.position.x){
      draggingInst.position.x = snapped;
      refreshInstanceList();
    }
  }else if(draggingCamera){
    setCameraX(cameraX - dx*2);
  }
}
function pointerUp(){
  draggingCamera=false;
  draggingInst=null;
  draggingInstOffset=0;
  if(activeColliderDrag){
    activeColliderDrag = null;
    refreshColliderList();
  }
  if(colliderPlacementMode){
    exitColliderPlacement();
  }
}
canvas.addEventListener('mousedown',pointerDown);
canvas.addEventListener('mousemove',pointerMove);
window.addEventListener('mouseup',pointerUp);
canvas.addEventListener('touchstart',e=>{e.preventDefault();pointerDown(e);},{passive:false});
canvas.addEventListener('touchmove', e=>{e.preventDefault();pointerMove(e);},{passive:false});
canvas.addEventListener('touchend',  e=>{e.preventDefault();pointerUp();},{passive:false});

/*** Buttons & toggles ***/
$('#btnPlacePlayerSpawn').addEventListener('click', () => {
  const spawn = ensurePlayerSpawn();
  spawnPlacementMode = true;
  selectedInstId = spawn.id;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('spawn-mode');
  refreshInstanceList();
});
$('#btnJitter').addEventListener('click',()=>{
  pushHistory();
  const posRange=Math.abs(parseFloat($('#jitterRange').value)||0);
  const scaleRange=Math.abs(parseFloat($('#jitterScaleRange').value)||0);
  if(posRange<=0 && scaleRange<=0) return;
  for(const inst of instances){
    if(inst.layerId!==activeLayerId || inst.locked) continue;
    if(posRange>0){
      const delta = (Math.random()*2-1)*posRange;
      inst.position = normalizePosition(inst.position);
      inst.position.x += delta;
      const grid = GRID_UNIT || 0;
      if(grid > 0){
        inst.position.x = Math.round(inst.position.x / grid) * grid;
      }
    }
    if(scaleRange>0){
      const sx=1 + (Math.random()*2-1)*scaleRange;
      const sy=1 + (Math.random()*2-1)*scaleRange;
      inst.scale = normalizeScale(inst.scale);
      inst.scale.x=Math.max(0.1,sx);
      inst.scale.y=Math.max(0.1,sy);
    }
  }
  refreshInstanceList();
});
$('#btnDeleteInst').addEventListener('click',deleteSelectedInstance);
$('#btnDuplicateInst').addEventListener('click',duplicateSelectedInstance);
$('#btnUndo').addEventListener('click',undo);
$('#chkDebug').addEventListener('change',e=>{debugOverlay=e.target.checked;});
$('#btnAddDrumSkin').addEventListener('click', addDrumSkin);
$('#btnPlaceRow').addEventListener('click',()=>{
  const pid=$('#libPrefab').value;
  const count=parseInt($('#libCount').value,10)||1;
  if(!prefabs[pid]){ alert('No prefab selected'); return; }
  pushHistory();
  for(let i=0;i<count;i++) addInstance(activeLayerId,pid);
  refreshInstanceList();
});
$('#btnAddParallaxLayer').addEventListener('click',()=>{
  const count=getParallaxLayerCount();
  if(count>=10){ alert('Parallax layer limit reached (10).'); return; }
  pushHistory();
  const id=`bg${count+1}`;
  layers.splice(count,0,{
    id,
    name:`Parallax ${count+1}`,
    type:"parallax",
    parallaxSpeed:0.15 + 0.1*count,
    offsetY:-140 + 20*count,
    separation:220,
    scale:0.6 + 0.05*count,
    meta:{},
  });
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
});

/*** Export / Import map ***/
async function exportLayout(){
  const statusEl = $('#exportStatus');
  const textEl = $('#exportText');
  try{
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      exportedAt: new Date().toISOString(),
    };
    const json=JSON.stringify(area,null,2);
    textEl.value=json;
    const areaId = area.id || area.meta?.areaId || 'map-export';
    const areaName = area.meta?.areaName || areaId;

    let popup=null;
    try {
      popup=window.open('', '_blank');
    } catch (_err) {
      popup=null;
    }

    if(popup){
      const doc=popup.document;
      doc.open();
      doc.write('<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Map export</title><style>body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;margin:24px;background:#0f172a;color:#e2e8f0;} h1{font-size:20px;margin-bottom:16px;} pre{padding:16px;background:#020617;border-radius:8px;border:1px solid #1e293b;max-width:calc(100vw - 48px);overflow:auto;white-space:pre-wrap;word-break:break-word;font-family:"JetBrains Mono","Fira Code",monospace;font-size:13px;line-height:1.6;} button{margin-top:16px;padding:8px 16px;background:#334155;color:#f8fafc;border:1px solid #475569;border-radius:6px;cursor:pointer;} button:hover{background:#1e293b;}</style></head><body></body></html>');
      doc.close();
      doc.title=`${areaName} export`;

      const heading=doc.createElement('h1');
      heading.textContent=`${areaName} JSON export`;

      const pre=doc.createElement('pre');
      pre.textContent=json;

      const copyBtn=doc.createElement('button');
      copyBtn.textContent='Copy JSON to clipboard';
      copyBtn.addEventListener('click',async()=>{
        try {
          await navigator.clipboard.writeText(json);
          copyBtn.textContent='Copied!';
          setTimeout(()=>{ copyBtn.textContent='Copy JSON to clipboard'; }, 2000);
        } catch(_clipboardErr){
          copyBtn.textContent='Copy failed';
          setTimeout(()=>{ copyBtn.textContent='Copy JSON to clipboard'; }, 2000);
        }
      });

      doc.body.append(heading, pre, copyBtn);
      statusEl.style.color='#22c55e';
      statusEl.textContent='Opened area JSON in new tab.';
    }else{
      const blob=new Blob([json],{type:'application/json'});
      const blobUrl=URL.createObjectURL(blob);
      const anchor=document.createElement('a');
      anchor.href=blobUrl;
      anchor.download=`${areaId}.json`;
      anchor.rel='noopener';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      setTimeout(()=>URL.revokeObjectURL(blobUrl),0);
      statusEl.style.color='#22c55e';
      statusEl.textContent='Download started. If blocked, copy JSON below.';
    }
  }catch(err){
    statusEl.style.color='#f97316';
    statusEl.textContent='Export error: '+err.message+' (JSON mirrored below)';
  }
}
$('#btnExportMap').addEventListener('click', exportLayout);

function pruneOldPreviewPayloads(){
  try {
    if (typeof localStorage === 'undefined') return;
    const expiry = Date.now() - 10 * 60 * 1000;
    for (let i = localStorage.length - 1; i >= 0; i--){
      const key = localStorage.key(i);
      if (!key || !key.startsWith(PREVIEW_STORAGE_PREFIX)) continue;
      let remove = false;
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          remove = true;
        } else {
          const payload = JSON.parse(raw);
          if (!payload || typeof payload !== 'object' || !Number.isFinite(payload.createdAt) || payload.createdAt < expiry){
            remove = true;
          }
        }
      } catch (_err) {
        remove = true;
      }
      if (remove) {
        try { localStorage.removeItem(key); } catch (_rmErr) { /* ignore */ }
      }
    }
  } catch (_error) {
    // Ignore storage errors (e.g., privacy mode)
  }
}

function storePreviewPayload(layout){
  const token = `mp${Date.now().toString(36)}${Math.random().toString(36).slice(2,8)}`;
  const safeLayout = JSON.parse(JSON.stringify(layout));
  const payload = {
    createdAt: Date.now(),
    layout: safeLayout,
    version: 1,
  };
  let stored = false;

  if (typeof localStorage !== 'undefined') {
    try {
      pruneOldPreviewPayloads();
      localStorage.setItem(PREVIEW_STORAGE_PREFIX + token, JSON.stringify(payload));
      stored = true;
    } catch (error) {
      console.error('[map-editor] Failed to store preview payload', error);
    }
  }

  return { token, payload, stored };
}

function launchGameplayPreview(){
  try {
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      editorPreview: true,
      exportedAt: new Date().toISOString(),
    };
    const { token, payload, stored } = storePreviewPayload(area);
    if (!token) {
      throw new Error('Failed to create preview token.');
    }
    if (!stored) {
      console.warn('[map-editor] Preview payload could not be persisted; relying on direct preview handshake.');
    }
    const url = new URL('./index.html', window.location.href);
    url.searchParams.set('mode', 'game');
    url.searchParams.set('preview', token);
    const win = window.open(url.toString(), '_blank');
    if (!win) {
      alert('Preview window was blocked. Allow pop-ups for this site to enable gameplay preview.');
      return;
    }
    try {
      const targetOrigin = url.origin || window.location.origin || '*';
      const message = {
        type: 'map-editor-preview',
        token,
        payload,
      };
      win.postMessage(message, targetOrigin);
      setTimeout(() => {
        try {
          win.postMessage(message, targetOrigin);
        } catch (_err) {
          // Ignore follow-up delivery errors.
        }
      }, 50);
    } catch (postError) {
      console.warn('[map-editor] Failed to transmit preview payload to new window', postError);
    }
    win?.focus?.();
  } catch (error) {
    console.error('[map-editor] Failed to launch gameplay preview', error);
    alert('Failed to launch gameplay preview: ' + error.message);
  }
}

const menus = [];
function bindMenu(toggleSelector, menuSelector){
  const toggle = $(toggleSelector);
  const menu = $(menuSelector);
  if (!toggle || !menu) return;
  const close = () => {
    menu.classList.remove('open');
    toggle.setAttribute('aria-expanded','false');
  };
  const open = () => {
    menu.classList.add('open');
    toggle.setAttribute('aria-expanded','true');
  };
  toggle.addEventListener('click', (event) => {
    event.stopPropagation();
    const isOpen = menu.classList.contains('open');
    menus.forEach(item => item.close());
    if (!isOpen) open();
  });
  menu.addEventListener('click', (event) => event.stopPropagation());
  menus.push({ toggle, menu, close });
}

bindMenu('#importMenuToggle', '#importMenu');
bindMenu('#overflowMenuToggle', '#overflowMenu');

document.addEventListener('click', () => menus.forEach(item => item.close()));

$('#btnLoadMap').addEventListener('click', async () => {
  const select = $('#mapRepoSelect');
  const mapId = select?.value || DEFAULT_LAYOUT_META.areaId;
  await loadRepositoryMapById(mapId);
});

const btnLoadMapInline = $('#btnLoadMapInline');
if (btnLoadMapInline){
  btnLoadMapInline.addEventListener('click', () => {
    $('#btnLoadMap')?.click();
    menus.forEach(item => item.close());
  });
}

$('#btnPreviewGameplay').addEventListener('click', launchGameplayPreview);
const spawnHeightField = $('#spawnPosY');
if (spawnHeightField){
  ['change','blur','input'].forEach(evt => {
    spawnHeightField.addEventListener(evt, updateSpawnHeightFromField);
  });
}

/*** Loaders for prefab/image ***/
$('#btnLoadPrefab').addEventListener('click',()=>{
  const inp=document.createElement('input');
  inp.type='file';
  inp.accept='application/json';
  inp.onchange=e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const parsed = JSON.parse(r.result);
        registerPrefab(parsed).catch(err=>{
          console.error('[map-editor] Failed to register prefab', err);
          alert('Invalid JSON: '+(err?.message||err));
        });
      }catch(err){
        alert('Invalid JSON: '+err.message);
      }
    };
    r.readAsText(f);
  };
  inp.click();
});
$('#btnLoadImage').addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';                  // <-- required
  inp.accept = 'image/*';
  inp.onchange = e => {
    const f = e.target.files[0];
    if (!f) return;
    registerImagePrefab(f);
  };
  inp.click();
});

/*** Init ***/
$('#gridSize').value = GRID_UNIT;
$('#gridSize').disabled = true;
$('#gridSize').title = `Grid locked to ${GRID_UNIT}px (configured)`;
populateRepositorySelect();
rebuildActiveLayerSelect();
rebuildLayerStack();
syncActiveLayerFields();
ensurePlayerSpawn();
refreshColliderList();
refreshInstanceList();
refreshDrumSkinList();
requestAnimationFrame(render);

(async () => {
  try {
    await ensureConfiguredPrefabsLoaded();
    await importDrumSkinImagesFromAssetManifest();
    const initialId = layoutMeta.repositoryId || layoutMeta.areaId || DEFAULT_LAYOUT_META.areaId;
    await loadRepositoryMapById(initialId);
  } catch (error) {
    console.error('[map-editor] failed to load initial map', error);
  }
})();
</script>
</body>
</html>
