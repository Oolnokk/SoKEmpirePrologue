<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parallax Map Builder (Layered v15f)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <style>
    :root {
      --bg:#05070a; --panel:#10141a; --card:#151b22;
      --line:#27303c; --muted:#7f8ea3; --text:#e6edf3;
      --btn:#1a2330; --btnHi:#222d3c;
    }
    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      height:100%;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;
      padding-left:env(safe-area-inset-left);
      padding-right:env(safe-area-inset-right);
      padding-bottom:env(safe-area-inset-bottom);
    }

    #app {
      display:flex;
      flex-direction:column;
      min-height:100vh;
      background:var(--bg);
    }

    header {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      padding:12px 14px 8px;
      background:var(--panel);
      border-bottom:1px solid var(--line);
      gap:8px;
      flex-wrap:wrap;
      font-size:11px;
    }
    header h1 {
      margin:0;
      font-size:16px;
      font-weight:600;
      color:var(--text);
      line-height:1.4;
    }

    button, select, input:not([type="range"]) {
      background:var(--btn);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      font-size:16px; /* avoid mobile zoom */
      min-height:44px;
      line-height:1.2;
    }
    input[type="range"] {
      accent-color:#38bdf8;
      min-height:30px;
    }
    button:hover { background:var(--btnHi); cursor:pointer; }
    .toolbar { display:flex; gap:6px; align-items:center; flex-wrap:wrap; justify-content:flex-end; position:relative; }
    .btn-primary { background:#2563eb; border-color:#1d4ed8; color:white; box-shadow:0 6px 20px rgba(37,99,235,0.25); }
    .btn-primary:hover { background:#1d4ed8; }
    .btn-secondary { background:transparent; border-color:var(--line); color:var(--text); box-shadow:none; }
    .split-group { display:flex; align-items:stretch; position:relative; }
    .split-group > button { border-radius:10px 0 0 10px; }
    .split-group .split-caret { width:34px; padding:4px; border-left:none; border-radius:0 10px 10px 0; display:grid; place-items:center; }
    .menu { position:absolute; top:calc(100% + 4px); right:0; background:var(--panel); border:1px solid var(--line); border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.35); min-width:200px; padding:6px; display:none; flex-direction:column; gap:4px; z-index:10; }
    .menu.open { display:flex; }
    .menu label { font-size:10px; color:var(--muted); display:flex; flex-direction:column; gap:2px; }
    .menu .menu-row { display:flex; gap:6px; align-items:center; }
    .menu button { width:100%; text-align:left; border-radius:8px; }
    .menu .menu-row button { width:auto; white-space:nowrap; }
    .menu .menu-inline-select { flex:1; }
    .kebab { width:32px; display:grid; place-items:center; border-radius:10px; }
    @media (max-width:540px) {
      header { flex-wrap:wrap; gap:8px; }
      .toolbar { width:100%; justify-content:flex-start; }
    }

    .layout {
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      flex:1;
    }

    .content-columns {
      display:flex;
      flex-direction:column;
      gap:12px;
      flex:1;
    }

    #bar {
      padding:8px 12px;
      display:flex;
      align-items:center;
      gap:10px;
      background:#111821;
      border-block:1px solid var(--line);
      font-size:11px;
      color:var(--muted);
      flex-wrap:wrap;
      position:sticky;
      top:0;
      z-index:5;
    }

    #controlPane {
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    #canvasPane {
      display:flex;
      flex-direction:column;
      gap:8px;
      position:sticky;
      top:0;
      z-index:2;
    }

    .card {
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:6px;
      margin-bottom:4px;
    }

    .card-heading {
      display:flex;
      align-items:center;
      gap:8px;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .row {
      display:flex;
      gap:6px;
      margin-top:4px;
    }
    .row label {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:10px;
    }
    label span {
      color:var(--muted);
      font-size:10px;
    }

    #sceneWrap {
      flex:1;
      border-radius:14px;
      border:1px solid var(--line);
      background:transparent;
      overflow:hidden;
      position:relative;
      min-height:clamp(320px, 55vh, 720px);
      width:100%;
    }
    #sceneCanvas {
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }
    #sceneCanvas.spawn-mode,
    #sceneCanvas.collider-mode,
    #sceneCanvas.behavior-place {
      cursor:crosshair;
    }

    #instList {
      max-height:160px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
    }
    #colliderList {
      max-height:140px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
      margin-top:4px;
    }
    .inst {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .inst span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .inst.active {
      background:rgba(120,150,255,0.16);
    }
    .collider {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .collider span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .collider.active {
      background:rgba(239, 68, 68, 0.16);
    }

    .pill {
      padding:1px 5px;
      border-radius:999px;
      background:#1c2330;
      color:var(--muted);
      font-size:9px;
    }
    .pill--spawn {
      margin-left:4px;
      background:#0f172a;
      color:#38bdf8;
    }
    .lock-pill {
      margin-left:4px;
      font-size:9px;
      color:#facc15;
    }

    #debugText {
      font-family:ui-monospace,Menlo,Consolas;
      font-size:9px;
      color:var(--muted);
      margin-top:4px;
      white-space:pre;
    }

    #exportStatus {
      font-size:9px;
      margin-top:2px;
    }
    #exportText {
      width:100%;
      height:80px;
      margin-top:4px;
      background:#020308;
      color:#9ca3af;
      border-radius:6px;
      border:1px solid #27303c;
      font-size:9px;
      padding:4px;
      font-family:ui-monospace,Menlo,Consolas;
      resize:vertical;
    }

    .hidden-select {
      display:none;
    }

    .hidden { display:none !important; }

    .mode-toggle {
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .mode-toggle .mode-btn {
      border-radius:10px;
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--text);
      padding:8px 12px;
      font-size:12px;
      font-weight:600;
      min-height:unset;
    }
    .mode-toggle .mode-btn.active {
      background:#22c55e;
      border-color:#16a34a;
      color:#041207;
    }

    .behavior-card {
      background:var(--card);
      border:1px solid var(--line);
      border-radius:12px;
      padding:8px;
      margin-bottom:8px;
    }
    .behavior-list {
      max-height:160px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
      margin-top:4px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .behavior-list .item {
      display:flex;
      justify-content:space-between;
      gap:8px;
      padding:6px 8px;
      border-radius:8px;
      background:#0c121b;
      cursor:pointer;
      border:1px solid transparent;
    }
    .behavior-list .item.active {
      border-color:#22c55e;
      background:rgba(34,197,94,0.08);
    }
    .behavior-pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:rgba(255,255,255,0.06);
      border-radius:999px;
      padding:4px 8px;
      font-size:10px;
      color:var(--muted);
    }
    .behavior-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
      gap:6px;
      margin-top:6px;
    }

    #instStretchLayer {
      display:inline-block;
      min-width:120px;
    }

    .layer-stack {
      display:flex;
      flex-direction:column-reverse; /* top tile = frontmost visually */
      gap:4px;
      margin-top:4px;
    }
    .layer-item {
      padding:4px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:#111823;
      font-size:9px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
    }
    .layer-item span { pointer-events:none; }
    .layer-item.active {
      background:#1f2933;
      border-color:#38bdf8;
      box-shadow:0 0 0 1px rgba(56,189,248,0.25);
    }
    .layer-item.dragging { opacity:0.4; }
    .layer-item-type {
      padding:1px 5px;
      border-radius:999px;
      font-size:8px;
      background:#0f172a;
      color:#9ca3af;
    }

    .accordion {
      background:var(--card);
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    .accordion summary {
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:600;
      color:var(--text);
      background:rgba(255,255,255,0.02);
    }
    .accordion summary::-webkit-details-marker { display:none; }
    .accordion .accordion-body {
      padding:0 12px 12px;
    }

    #toolbar {
      position:sticky;
      bottom:0;
      padding:10px 12px;
      background:var(--panel);
      border-top:1px solid var(--line);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      box-shadow:0 -10px 30px rgba(0,0,0,0.35);
      z-index:9;
    }
    .toolbar-group {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    @media (min-width:1100px) {
      .layout { padding:16px; }
      .content-columns {
        flex-direction:row;
        gap:14px;
        align-items:flex-start;
      }
      #canvasPane { flex:1 1 60%; top:12px; }
      #controlPane { flex:0 0 420px; }
      #sceneWrap { min-height:480px; height:60vh; }
      header { align-items:center; }
    }
  </style>
  <script src="./config/abilities/shared.js"></script>
  <script src="./config/abilities/combo_light.js"></script>
  <script src="./config/abilities/dagger_swords_combo_light.js"></script>
  <script src="./config/abilities/greatclub_combo_light.js"></script>
  <script src="./config/abilities/hatchets_combo_light.js"></script>
  <script src="./config/abilities/light_greatblade_combo_light.js"></script>
  <script src="./config/abilities/sarrarru_combo_light.js"></script>
  <script src="./config/abilities/unarmed_combo_light.js"></script>
  <script src="./config/abilities/quick_light.js"></script>
  <script src="./config/abilities/quick_punch.js"></script>
  <script src="./config/abilities/heavy_hold.js"></script>
  <script src="./config/abilities/evade_defensive.js"></script>
  <script src="./config/config.js"></script>
</head>
<body>
<div id="app">
  <header>
    <h1>Parallax Map Builder <span style="color:var(--muted)">· layered v15f</span></h1>
    <div class="toolbar" aria-label="Editor actions">
      <div class="split-group" aria-label="Import and load">
        <button id="btnLoadMap" aria-label="Load selected map">Load Map</button>
        <button id="importMenuToggle" class="split-caret" aria-haspopup="true" aria-expanded="false" aria-label="Open import menu">▾</button>
        <div id="importMenu" class="menu" role="menu" aria-label="Import menu">
          <button id="btnLoadPrefab" role="menuitem">Load Structure JSON</button>
          <button id="btnLoadImage" role="menuitem">Load Image</button>
          <div class="menu-row" role="menuitem">
            <label class="menu-inline-select">
              <span>Repository Map</span>
              <select id="mapRepoSelect" aria-label="Repository Map"></select>
            </label>
            <button id="btnLoadMapInline" aria-label="Load selected repository map">Load</button>
          </div>
        </div>
      </div>
      <button id="btnPreviewGameplay" class="btn-primary">Preview</button>
      <button id="btnExportMap" class="btn-secondary">Export</button>
      <button id="overflowMenuToggle" class="kebab" aria-label="More actions" aria-haspopup="true" aria-expanded="false">⋮</button>
      <div id="overflowMenu" class="menu" role="menu" aria-label="More actions">
        <button id="btnUndo" role="menuitem">Undo</button>
      </div>
    </div>
    <span style="color:var(--muted);font-size:12px">Tap the toolbar for primary actions.</span>
  </header>

  <div id="bar">
    <span>
      Cam:
      <input id="camSlider" type="range" min="-4000" max="4000" value="0" style="width:140px">
      <input id="camNum" type="number" value="0" style="width:80px">
    </span>
    <span>
      Zoom:
      <input id="zoomSlider" type="range" min="0.5" max="2.0" step="0.05" value="1" style="width:140px">
      <input id="zoomNum" type="number" min="0.5" max="2.0" step="0.05" value="1" style="width:70px">
    </span>
    <label style="display:flex;align-items:center;gap:6px">
      <input id="chkDebug" type="checkbox">
      <span>Debug</span>
    </label>
    <button id="btnAddParallaxLayer">+ Parallax Layer</button>
    <span class="pill">
      Tap layer tiles to select · drag to reorder (top = front).
    </span>
  </div>

  <main class="layout">
    <div class="mode-toggle" role="group" aria-label="Editor mode">
      <button id="btnModeLayout" class="mode-btn active" aria-pressed="true">Layout</button>
      <button id="btnModeBehavior" class="mode-btn" aria-pressed="false">Behavior Overlay</button>
      <span class="pill">Toggle to edit NPC spawners, path targets, interaction points and arrival spawns without leaving the preview.</span>
    </div>
    <div class="content-columns">
      <section id="canvasPane">
        <div class="card">
          <div class="card-heading">
            <strong>Preview</strong>
            <span style="font-size:10px;color:var(--muted);">Screen-space KF · select an instance & toggle Debug to see rays.</span>
          </div>
        </div>
        <div id="sceneWrap"><canvas id="sceneCanvas"></canvas></div>
        <div id="debugText"></div>
      </section>

      <aside id="controlPane">
        <details class="accordion" open>
          <summary>Instances (active layer only)</summary>
          <div class="accordion-body">
            <div id="instList"></div>
            <div style="display:flex;margin-top:6px">
              <button id="btnPlacePlayerSpawn" style="flex:1">Place Player Spawn</button>
            </div>
            <div class="row">
              <label><span>Spawn Height (px)</span><input id="spawnPosY" type="number" step="1"></label>
            </div>
            <small style="color:var(--muted);display:block;margin-top:4px">
              Positive values push the spawn below ground; negative lifts it above.
            </small>
            <small style="color:var(--muted);display:block;margin-top:4px">
              Only instances on the active layer can be picked, dragged or jittered. Use the button above and then click the preview to set the spawn (snaps to the grid unit).
            </small>
          </div>
        </details>

        <details class="accordion" open>
          <summary>Platform Colliders</summary>
          <div class="accordion-body">
            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
              <button id="btnAddCollider">Add collider</button>
              <button id="btnDeleteCollider">Remove selected</button>
              <span class="pill">Add then drag on the preview to place a collider (click again to cancel).</span>
            </div>
            <div id="colliderList"></div>
            <div class="row" style="margin-top:6px">
              <label><span>ID</span><input id="colliderId" readonly></label>
              <label><span>Label</span><input id="colliderLabel" type="text" placeholder="Ground segment"></label>
            </div>
            <div class="row">
              <label><span>Left (px)</span><input id="colliderLeft" type="number" step="1"></label>
              <label><span>Width (px)</span><input id="colliderWidth" type="number" step="1" min="1"></label>
            </div>
            <div class="row">
              <label><span>Top offset (px)</span><input id="colliderTopOffset" type="number" step="1"></label>
              <label><span>Height (px)</span><input id="colliderHeight" type="number" step="1" min="1"></label>
            </div>
            <div class="row">
              <label><span>Material type</span><input id="colliderMaterialType" type="text" list="materialTypePresets" placeholder="default"></label>
            </div>
            <div class="row">
              <label><span>Tags (comma-separated)</span><input id="colliderTags" type="text" placeholder="poi:patrol-point, schedule:morning"></label>
            </div>
            <datalist id="materialTypePresets">
              <option value="stone"></option>
              <option value="concrete"></option>
              <option value="wood"></option>
              <option value="metal"></option>
              <option value="ceramic"></option>
              <option value="glass"></option>
              <option value="dirt"></option>
              <option value="grass"></option>
              <option value="gravel"></option>
              <option value="sand"></option>
              <option value="snow"></option>
              <option value="ice"></option>
              <option value="water"></option>
            </datalist>
            <small style="color:var(--muted);display:block;margin-top:4px">
              Offsets are relative to the ground line. Negative values lift the collider above the ground.
            </small>
          </div>
        </details>

        <details class="accordion" open>
          <summary>Drum Skin Layers</summary>
          <div class="accordion-body">
            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
              <button id="btnAddDrumSkin">Add drum skin</button>
              <span class="pill">Bridges between two parallax layers with a tiled image.</span>
            </div>
            <div id="drumSkinList" style="margin-top:6px;display:flex;flex-direction:column;gap:6px"></div>
            <small style="color:var(--muted);display:block;margin-top:4px">
              Configure geometry before selecting an image. Drum skins render above parallax backgrounds but below props.
            </small>
          </div>
        </details>

        <details class="accordion" open>
          <summary>Layers</summary>
          <div class="accordion-body">
            <select id="activeLayerSelect" class="hidden-select"></select>
            <div id="layerStack" class="layer-stack"></div>
            <div class="row">
              <label><span>parallax</span><input id="layerParallax" type="number" step="0.05"></label>
              <label><span>y offset (from ground)</span><input id="layerYOffset" type="number"></label>
            </div>
            <div class="row">
              <label><span>separation</span><input id="layerSep" type="number"></label>
              <label><span>scale</span><input id="layerScale" type="number" step="0.05"></label>
            </div>
            <div class="row">
              <label><span>&nbsp;</span><button id="btnDuplicateLayer">Duplicate active layer</button></label>
            </div>
            <small style="color:var(--muted);display:block;margin-top:4px">
              Drag tiles to change draw order. Top tile renders in front.
            </small>
          </div>
        </details>

        <div class="card">
          <strong>Selected instance</strong>
          <div class="row">
            <label><span>ID</span><input id="instId" readonly></label>
            <label><span>Prefab</span><select id="instPrefab"></select></label>
          </div>
          <div class="row">
            <label>
              <span>Layer</span>
              <select id="instLayer" class="hidden-select"></select>
            </label>
            <label>
              <span>Display X (world)</span>
              <input id="instX" type="number">
            </label>
          </div>
          <div class="row">
            <label style="flex:none;display:flex;align-items:center;gap:4px">
              <input id="instLocked" type="checkbox">
              <span>Lock position</span>
            </label>
            <label><span>Grid (px)</span><input id="gridSize" type="number" value="10"></label>
            <label><span>Delete</span><button id="btnDeleteInst">Remove</button></label>
          </div>
          <div class="row">
            <label><span>Scale X</span><input id="instScaleX" type="number" step="0.05"></label>
            <label><span>Scale Y</span><input id="instScaleY" type="number" step="0.05"></label>
          </div>
          <div class="row">
            <label><span>Position Y (from ground)</span><input id="instOffY" type="number" step="1"></label>
            <label><span>Rot (deg)</span><input id="instRot" type="number" step="1"></label>
          </div>
          <div class="row">
            <label style="flex:none;display:flex;align-items:center;gap:4px">
              <input id="instStretchEnabled" type="checkbox">
              <span>Stretch quad</span>
            </label>
            <label>
              <span>Target layer</span>
              <select id="instStretchLayer" class="hidden-select"></select>
            </label>
          </div>
          <div class="row">
            <label><span>Top height (px)</span><input id="instStretchHeight" type="number" step="1" min="1"></label>
            <label><span>Top offset (px)</span><input id="instStretchTopOffset" type="number" step="1"></label>
          </div>
          <div class="row">
            <label><span>Slices</span><input id="instStretchSlices" type="number" step="1" min="4" max="80"></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:4px">
            Stretch quads span the selected prefab toward another layer. Leave disabled to render normally.
          </small>
          <div class="row">
            <label><span>&nbsp;</span><button id="btnDuplicateInst">Duplicate</button></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:4px">
            Duplicate copies all settings; lock blocks drag/jitter, not manual edits.
          </small>
        </div>

        <div class="card">
          <strong>Prefab Library</strong>
          <div class="row">
            <label>
              <span>Prefab</span>
              <select id="libPrefab"></select>
            </label>
            <label>
              <span>Count</span>
              <input id="libCount" type="number" min="1" max="50" value="8">
            </label>
          </div>
          <div class="row">
            <label><span>&nbsp;</span><button id="btnPlaceRow">Place row on active layer</button></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:4px">
            Structures & uploads land here; stamp rows onto the active layer.
          </small>
        </div>

        <div class="card">
          <strong>Jitter (active layer, unlocked only)</strong>
          <div class="row">
            <label><span>Pos range (px)</span><input id="jitterRange" type="number" value="40"></label>
            <label><span>Scale range (±)</span><input id="jitterScaleRange" type="number" step="0.05" value="0.15"></label>
          </div>
          <div class="row">
            <label><span>&nbsp;</span><button id="btnJitter">Apply jitter</button></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:4px">
            Randomizes horizontal position (snapped to the grid) and scale for unlocked instances on the active layer.
          </small>
        </div>

        <div class="card">
          <strong>Global & Export</strong>
          <div class="row">
            <label>
              <span>Ground from bottom (px)</span>
              <input id="groundOffset" type="number" value="140">
            </label>
            <label>
              <span>Proximity scale</span>
              <input id="proximityScale" type="number" step="0.05" min="0.05" value="1">
            </label>
          </div>
          <div id="exportStatus"></div>
          <textarea id="exportText" readonly
            placeholder="Layout JSON appears here when you export."></textarea>
          <small style="color:var(--muted);display:block;margin-top:4px">
            If the new tab is blocked, long-press here to copy the JSON.
          </small>
        </div>

        <div class="card">
          <strong>Far Background</strong>
          <div class="row">
            <label>
              <span>Tile image URL</span>
              <input id="bgTileUrl" type="text" placeholder="https://.../tile.png" list="bgTileUrlOptions">
              <datalist id="bgTileUrlOptions"></datalist>
            </label>
            <label>
              <span>Tile scale</span>
              <input id="bgTileScale" type="number" step="0.05" value="1">
            </label>
          </div>
          <div class="row">
            <label>
              <span>Tile split (%)</span>
              <input id="bgTilePortion" type="number" min="0" max="100" value="0">
            </label>
            <label>
              <span>Tile offset Y (px)</span>
              <input id="bgTileOffsetY" type="number" step="1" value="0">
            </label>
          </div>
          <div class="row">
            <label>
              <span>Tile fallback color</span>
              <input id="bgTileFallback" type="text" placeholder="optional CSS color">
            </label>
          </div>
          <div class="row">
            <label>
              <span>Sky top</span>
              <input id="bgSkyTop" type="text" value="rgba(59,63,69,0.9)">
            </label>
            <label>
              <span>Sky mid</span>
              <input id="bgSkyMid" type="text" value="rgba(80,89,96,0.5)">
            </label>
            <label>
              <span>Sky bottom</span>
              <input id="bgSkyBottom" type="text" value="rgba(32,38,50,0.0)">
            </label>
          </div>
          <div class="row">
            <label>
              <span>Time of day (0-24)</span>
              <input id="bgTime" type="number" min="0" max="24" step="0.1" value="12">
            </label>
          </div>
          <div class="row">
            <label style="width:100%">
              <span>Preview</span>
              <div id="bgGradientPreview" style="height:60px;border:1px solid var(--line);border-radius:8px;background:linear-gradient(180deg, #1f2937, #111827);box-shadow:inset 0 1px 4px rgba(0,0,0,0.25);"></div>
            </label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:4px">
            Stored with the map and sent to gameplay preview so gradients and tiles match in-engine.
          </small>
        </div>
      </aside>

      <aside id="behaviorPane" class="hidden">
        <div class="behavior-card">
          <div class="card-heading" style="margin-bottom:4px;align-items:flex-start;gap:10px;flex-wrap:wrap">
            <strong>NPC Spawners</strong>
            <div style="display:flex;gap:6px;flex-wrap:wrap">
              <button id="btnAddBehaviorSpawner">+ Spawner</button>
              <button id="btnPlaceBehaviorSpawner" class="btn-secondary">Place on preview</button>
            </div>
          </div>
          <div id="behaviorSpawnerList" class="behavior-list" aria-label="Spawner list"></div>
          <div class="behavior-grid">
            <label><span>Spawner ID</span><input id="behaviorSpawnerId" type="text" placeholder="patrol_a"></label>
            <label><span>Layer</span><select id="behaviorSpawnerLayer" class="hidden-select"></select></label>
            <label><span>Position X</span><input id="behaviorSpawnerX" type="number" step="1"></label>
            <label><span>Position Y (from ground)</span><input id="behaviorSpawnerY" type="number" step="1"></label>
            <label><span>Spawn radius (px)</span><input id="behaviorSpawnerRadius" type="number" min="0" step="1"></label>
            <label><span>Count</span><input id="behaviorSpawnerCount" type="number" min="1" step="1"></label>
            <label><span>Template ID</span><input id="behaviorSpawnerTemplate" type="text" placeholder="watchman"></label>
            <label><span>Character ID</span><input id="behaviorSpawnerCharacter" type="text" placeholder="npc id (optional)"></label>
            <label style="display:flex;align-items:center;gap:8px"><input id="behaviorSpawnerRespawn" type="checkbox"><span>Respawn enabled</span></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:6px">Spawners export to layout.spawners and can be previewed without stamping prefabs.</small>
        </div>

        <div class="behavior-card">
          <div class="card-heading" style="margin-bottom:4px;align-items:flex-start;gap:10px;flex-wrap:wrap">
            <strong>Path Targets</strong>
            <div style="display:flex;gap:6px;flex-wrap:wrap">
              <button id="btnAddPathTarget">+ Path Target</button>
              <button id="btnPlacePathTarget" class="btn-secondary">Place on preview</button>
            </div>
          </div>
          <div id="behaviorPathTargetList" class="behavior-list" aria-label="Path targets"></div>
          <div class="behavior-grid">
            <label><span>Target name</span><input id="behaviorPathName" type="text" placeholder="alpha"></label>
            <label><span>Order</span><input id="behaviorPathOrder" type="number" step="1"></label>
            <label><span>Layer</span><select id="behaviorPathLayer" class="hidden-select"></select></label>
            <label><span>Instance link (optional)</span><input id="behaviorPathInstanceId" type="text" placeholder="instance id"></label>
            <label><span>Position X</span><input id="behaviorPathX" type="number" step="1"></label>
            <label><span>Position Y (from ground)</span><input id="behaviorPathY" type="number" step="1"></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:6px">Explicit targets merge with markers tagged path:target:* when exporting.</small>
        </div>

        <div class="behavior-card">
          <div class="card-heading" style="margin-bottom:4px;align-items:flex-start;gap:10px;flex-wrap:wrap">
            <strong>POIs (Points of Interest)</strong>
            <div style="display:flex;gap:6px;flex-wrap:wrap">
              <button id="btnAddPOI">+ POI</button>
              <button id="btnDeletePOI">Remove selected</button>
            </div>
          </div>
          <div id="behaviorPOIList" class="behavior-list" aria-label="POI list"></div>
          <div class="behavior-grid">
            <label><span>POI ID</span><input id="behaviorPOIId" type="text" placeholder="poi_patrol_west"></label>
            <label><span>POI Name</span><input id="behaviorPOIName" type="text" placeholder="patrol-point"></label>
            <label><span>Label</span><input id="behaviorPOILabel" type="text" placeholder="Western Patrol Zone"></label>
            <label><span>Type</span><input id="behaviorPOIType" type="text" placeholder="box" value="box"></label>
            <label><span>Left (X)</span><input id="behaviorPOILeft" type="number" step="1"></label>
            <label><span>Width</span><input id="behaviorPOIWidth" type="number" step="1" min="1" value="120"></label>
            <label><span>Top (Y from ground)</span><input id="behaviorPOITop" type="number" step="1" value="-50"></label>
            <label><span>Height</span><input id="behaviorPOIHeight" type="number" step="1" min="1" value="100"></label>
            <label><span>Schedule Hours (comma-separated)</span><input id="behaviorPOISchedule" type="text" placeholder="0,1,2,3,4,5,6,7,8,9,10,11"></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:6px">POIs define navigation targets for NPCs. Render as green zones when "Show POIs" is enabled.</small>
        </div>

        <div class="behavior-card">
          <div class="card-heading" style="margin-bottom:4px;align-items:flex-start;gap:10px;flex-wrap:wrap">
            <strong>Interaction Points</strong>
            <button id="btnAddInteractionPoint">+ Interaction</button>
          </div>
          <div id="behaviorInteractionList" class="behavior-list" aria-label="Interaction points"></div>
          <div class="behavior-grid">
            <label><span>Interaction ID</span><input id="behaviorInteractionId" type="text" placeholder="door_east"></label>
            <label><span>Layer</span><select id="behaviorInteractionLayer" class="hidden-select"></select></label>
            <label><span>Position X</span><input id="behaviorInteractionX" type="number" step="1"></label>
            <label><span>Position Y (from ground)</span><input id="behaviorInteractionY" type="number" step="1"></label>
            <label><span>Action</span><input id="behaviorInteractionAction" type="text" placeholder="transition"></label>
            <label><span>Target / payload</span><input id="behaviorInteractionTarget" type="text" placeholder="area or script"></label>
            <label><span>Prompt text</span><input id="behaviorInteractionPrompt" type="text" placeholder="Press interact"></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:6px">Stored in layout meta for scripting; does not require a prefab.</small>
        </div>

        <div class="behavior-card">
          <div class="card-heading" style="margin-bottom:4px;align-items:flex-start;gap:10px;flex-wrap:wrap">
            <strong>Arrival Spawns</strong>
            <button id="btnAddArrivalSpawn">+ Arrival</button>
          </div>
          <div id="behaviorArrivalList" class="behavior-list" aria-label="Arrival spawns"></div>
          <div class="behavior-grid">
            <label><span>Arrival ID</span><input id="behaviorArrivalId" type="text" placeholder="from_upper_floor"></label>
            <label><span>Layer</span><select id="behaviorArrivalLayer" class="hidden-select"></select></label>
            <label><span>Position X</span><input id="behaviorArrivalX" type="number" step="1"></label>
            <label><span>Position Y (from ground)</span><input id="behaviorArrivalY" type="number" step="1"></label>
            <label><span>Source map (optional)</span><input id="behaviorArrivalFrom" type="text" placeholder="area id"></label>
          </div>
          <small style="color:var(--muted);display:block;margin-top:6px">Use arrival spawns for cross-map handoffs without replacing the default player spawn.</small>
        </div>
      </aside>
    </div>
  </main>

  <nav id="toolbar" aria-label="Primary actions">
    <div class="toolbar-group">
      <button id="btnLoadPrefab">Load Structure JSON</button>
      <button id="btnLoadImage">Load Image</button>
    </div>
    <div class="toolbar-group">
      <select id="mapRepoSelect" aria-label="Repository Map"></select>
      <button id="btnLoadMap">Load Map</button>
    </div>
    <div class="toolbar-group">
      <button id="btnUndo">Undo</button>
      <button id="btnPreviewGameplay">Preview Gameplay</button>
      <button id="btnExportMap">Download Area JSON</button>
    </div>
  </nav>
</div>

<script type="module" src="./js/map-config-defaults.js"></script>
<script type="module">
const $ = s => document.querySelector(s);
const ROOT_CONFIG = window.CONFIG || {};
const MAP_CONFIG = ROOT_CONFIG.map || {};
const MAP_EDITOR_DEFAULTS = (() => {
  if (typeof window.resolveMapEditorDefaults === 'function') {
    return window.resolveMapEditorDefaults(MAP_CONFIG) || {};
  }
  const fallbackCanvasHeight = Number.isFinite(ROOT_CONFIG.canvas?.h) && ROOT_CONFIG.canvas.h > 0
    ? ROOT_CONFIG.canvas.h
    : 460;
  const fallbackGroundOffset = (() => {
    const configGround = ROOT_CONFIG.ground;
    const configuredOffset = configGround && typeof configGround === 'object' ? Number(configGround.offset) : NaN;
    if (Number.isFinite(configuredOffset)) {
      return Math.max(0, configuredOffset);
    }
    const ratio = Number(ROOT_CONFIG.groundRatio);
    if (Number.isFinite(ratio) && ratio > 0 && ratio < 1 && fallbackCanvasHeight > 0) {
      return Math.max(0, Math.round(fallbackCanvasHeight * (1 - ratio)));
    }
    return 140;
  })();
  const fallbackCustomArea = { id: 'custom_area', label: 'Empty Layout', path: null, areaName: 'Custom Area' };
  return {
    canvasHeight: fallbackCanvasHeight,
    groundOffset: fallbackGroundOffset,
    groundRatio: Number.isFinite(ROOT_CONFIG.groundRatio) ? ROOT_CONFIG.groundRatio : null,
    customArea: fallbackCustomArea,
  };
})();
const DEFAULT_LAYOUT_ID = typeof window.resolveDefaultLayoutId === 'function'
  ? window.resolveDefaultLayoutId(MAP_CONFIG)
  : ((typeof MAP_CONFIG.defaultLayoutId === 'string' && MAP_CONFIG.defaultLayoutId.trim())
    ? MAP_CONFIG.defaultLayoutId.trim()
    : 'defaultdistrict');
const PREVIEW_STORAGE_PREFIX = typeof window.resolvePreviewStoragePrefix === 'function'
  ? window.resolvePreviewStoragePrefix(MAP_CONFIG)
  : ((typeof MAP_CONFIG.previewStoragePrefix === 'string' && MAP_CONFIG.previewStoragePrefix.trim())
    ? MAP_CONFIG.previewStoragePrefix.trim()
    : 'sok-map-editor-preview:');
const pickDefaultLayoutEntry = typeof window.pickDefaultLayoutEntry === 'function'
  ? window.pickDefaultLayoutEntry
  : null;
const DEFAULT_CANVAS_HEIGHT = Number.isFinite(MAP_EDITOR_DEFAULTS.canvasHeight)
  && MAP_EDITOR_DEFAULTS.canvasHeight > 0
  ? MAP_EDITOR_DEFAULTS.canvasHeight
  : 460;
const DEFAULT_GROUND_OFFSET = Number.isFinite(MAP_EDITOR_DEFAULTS.groundOffset)
  ? Math.max(0, MAP_EDITOR_DEFAULTS.groundOffset)
  : 140;
const DEFAULT_CUSTOM_ENTRY = (() => {
  const custom = MAP_EDITOR_DEFAULTS.customArea || {};
  const id = (typeof custom.id === 'string' && custom.id.trim()) ? custom.id.trim() : 'custom_area';
  const label = (typeof custom.label === 'string' && custom.label.trim()) ? custom.label.trim() : 'Empty Layout';
  const areaName = (typeof custom.areaName === 'string' && custom.areaName.trim())
    ? custom.areaName.trim()
    : (label || 'Custom Area');
  const path = (typeof custom.path === 'string' && custom.path.trim()) ? custom.path.trim() : null;
  return { id, label: label || 'Empty Layout', path, areaName: areaName || 'Custom Area' };
})();
const REPOSITORY_LAYOUTS = (() => {
  const normalized = Array.isArray(MAP_CONFIG.layouts) && MAP_CONFIG.layouts.length
    ? MAP_CONFIG.layouts.map((entry) => ({
        id: entry.id || entry.areaId || entry.path || 'custom_area',
        label: entry.label || entry.areaName || entry.id || 'Map',
        path: entry.path || null,
        areaName: entry.areaName || entry.label || entry.id || 'Map',
      }))
    : [];
  const seen = new Set();
  const result = [];
  const add = (entry) => {
    if (entry && entry.id && !seen.has(entry.id)) {
      result.push(entry);
      seen.add(entry.id);
    }
  };
  add(DEFAULT_CUSTOM_ENTRY);
  normalized.forEach(add);
  return result;
})();
const DEFAULT_LAYOUT_META = (() => {
  const fallback = {
    areaId: DEFAULT_CUSTOM_ENTRY.id,
    areaName: DEFAULT_CUSTOM_ENTRY.areaName || DEFAULT_CUSTOM_ENTRY.label || 'Custom Area',
    sourcePath: DEFAULT_CUSTOM_ENTRY.path,
    repositoryId: DEFAULT_CUSTOM_ENTRY.id,
  };
  const findEntryById = (id) => REPOSITORY_LAYOUTS.find((entry) => entry.id === id) || null;
  const chosen = pickDefaultLayoutEntry
    ? pickDefaultLayoutEntry(REPOSITORY_LAYOUTS, MAP_CONFIG)
    : (findEntryById(DEFAULT_LAYOUT_ID)
      || findEntryById('defaultdistrict')
      || REPOSITORY_LAYOUTS.find((entry) => entry.id && entry.id !== DEFAULT_CUSTOM_ENTRY.id)
      || null);
  if (!chosen) return fallback;
  return {
    areaId: chosen.id || fallback.areaId,
    areaName: chosen.areaName || chosen.label || chosen.id || fallback.areaName,
    sourcePath: chosen.path || fallback.sourcePath,
    repositoryId: chosen.id || fallback.repositoryId,
  };
})();
const GRID_UNIT = (Number.isFinite(MAP_CONFIG.gridUnit) && MAP_CONFIG.gridUnit > 0) ? MAP_CONFIG.gridUnit : 10;
const SPAWN_LAYER_ID = MAP_CONFIG.spawnLayerId || 'gameplay';
const PREFAB_MANIFESTS = Array.isArray(MAP_CONFIG.prefabManifests)
  ? MAP_CONFIG.prefabManifests.filter((entry) => typeof entry === 'string' && entry.trim())
  : [];
let runtimeModulePromise = null;
let prefabBootstrapPromise = null;

$('#groundOffset').value = DEFAULT_GROUND_OFFSET;
$('#proximityScale').value = clampValue(toNumber($('#proximityScale').value, 1) || 1, 0.05, 50);

function getRuntimeModule(){
  if (!runtimeModulePromise){
    runtimeModulePromise = import('./js/vendor/map-runtime.js');
  }
  return runtimeModulePromise;
}

function clamp(v,a,b){ return v<a?a:v>b?b:v; }
function lerp(a,b,t){ return a + (b-a)*t; }
function rad(d){ return d * Math.PI/180; }

const BACKGROUND_DEFAULTS = {
  skyColors: [
    'rgba(59,63,69,0.9)',
    'rgba(80,89,96,0.5)',
    'rgba(32,38,50,0.0)',
  ],
  tilePortion: 0,
  tileScale: 1,
  tileOffsetY: 0,
  time24h: 12,
};

function clampValue(num, min, max){
  if (!Number.isFinite(num)) return Number.isFinite(min) ? min : num;
  if (Number.isFinite(min) && num < min) return min;
  if (Number.isFinite(max) && num > max) return max;
  return num;
}

function coerceFiniteNumber(value){
  const num = Number(value);
  return Number.isFinite(num) ? num : null;
}

const colorParserCtx = typeof document !== 'undefined'
  ? document.createElement('canvas').getContext('2d')
  : null;

function parseCssColor(color){
  if (!colorParserCtx || !color) return null;
  try {
    colorParserCtx.fillStyle = '#000';
    colorParserCtx.fillStyle = color;
    const normalized = colorParserCtx.fillStyle;
    const match = normalized.match(/^rgba?\((\d+(?:\.\d+)?)[ ,]+(\d+(?:\.\d+)?)[ ,]+(\d+(?:\.\d+)?)(?:[ ,]+([0-9.]+))?\)$/);
    if (!match) return null;
    return {
      r: Number(match[1]),
      g: Number(match[2]),
      b: Number(match[3]),
      a: match[4] != null ? Number(match[4]) : 1,
    };
  } catch (_e) {
    return null;
  }
}

function lerpCssColor(a, b, t){
  const start = parseCssColor(a);
  const end = parseCssColor(b);
  const amt = Number.isFinite(t) ? Math.min(Math.max(t, 0), 1) : 0;
  if (!start || !end) return a || b;
  const lerpCh = (x, y) => x + (y - x) * amt;
  const r = Math.round(lerpCh(start.r, end.r));
  const g = Math.round(lerpCh(start.g, end.g));
  const bCh = Math.round(lerpCh(start.b, end.b));
  const aCh = lerpCh(start.a, end.a);
  return `rgba(${r}, ${g}, ${bCh}, ${Number(aCh.toFixed(3))})`;
}

function sampleDayCycleColor(colors, time24h, offset = 0){
  const palette = Array.isArray(colors) && colors.length >= 3 ? colors : BACKGROUND_DEFAULTS.skyColors;
  const normalized = ((Number(time24h) + offset) % 24 + 24) % 24;
  if (normalized < 8) {
    return lerpCssColor(palette[0], palette[1], normalized / 8);
  }
  if (normalized < 16) {
    return lerpCssColor(palette[1], palette[2], (normalized - 8) / 8);
  }
  return lerpCssColor(palette[2], palette[0], (normalized - 16) / 8);
}

function computeSkyGradientStops(background){
  const time = Number.isFinite(background?.sky?.time24h)
    ? background.sky.time24h
    : BACKGROUND_DEFAULTS.time24h;
  const colors = background?.sky?.colors;
  return {
    top: sampleDayCycleColor(colors, time, -1.5),
    mid: sampleDayCycleColor(colors, time, 0),
    bottom: sampleDayCycleColor(colors, time, 1.5),
  };
}

function normalizeBackgroundConfig(source = null, existing = null){
  const target = typeof existing === 'object' && existing ? { ...existing } : {};
  const layout = (target.layout = typeof source?.layout === 'object' && source.layout ? { ...source.layout } : (target.layout || {}));
  const sky = (target.sky = typeof source?.sky === 'object' && source.sky ? { ...source.sky } : (target.sky || {}));
  const tiles = (target.tiles = typeof source?.tiles === 'object' && source.tiles ? { ...source.tiles } : (target.tiles || {}));

  const skyColors = Array.isArray(sky.colors) && sky.colors.length >= 3
    ? sky.colors.slice(0, 3)
    : BACKGROUND_DEFAULTS.skyColors;
  sky.colors = skyColors;
  sky.time24h = clampValue(
    coerceFiniteNumber(sky.time24h ?? source?.time24h ?? BACKGROUND_DEFAULTS.time24h) ?? BACKGROUND_DEFAULTS.time24h,
    0,
    24,
  );

  const portionCandidate = layout.tilePortion ?? tiles.heightRatio ?? tiles.portion ?? BACKGROUND_DEFAULTS.tilePortion;
  layout.tilePortion = clampValue(coerceFiniteNumber(portionCandidate) ?? BACKGROUND_DEFAULTS.tilePortion, 0, 1);

  const tileUrl = typeof tiles.url === 'string'
    ? tiles.url
    : (typeof tiles.imageUrl === 'string' ? tiles.imageUrl : null);
  tiles.url = tileUrl;
  tiles.imageUrl = tileUrl;
  tiles.scale = clampValue(coerceFiniteNumber(tiles.scale ?? tiles.tileScale ?? BACKGROUND_DEFAULTS.tileScale) ?? BACKGROUND_DEFAULTS.tileScale, 0.05, 10);
  tiles.offsetY = coerceFiniteNumber(tiles.offsetY ?? tiles.tileOffsetY ?? BACKGROUND_DEFAULTS.tileOffsetY) || 0;
  if (typeof tiles.fallbackColor !== 'string') {
    tiles.fallbackColor = null;
  }

  return target;
}

let backgroundConfig = normalizeBackgroundConfig(MAP_CONFIG?.background || ROOT_CONFIG?.background || null);

/*** Undo history ***/
const historyStack = [];
const HISTORY_LIMIT = 50;
let isRestoring = false;
function snapshotState(){
  return JSON.parse(JSON.stringify({
    ...buildAreaDescriptor(),
    activeLayerId,
  }));
}
function pushHistory(){
  if(isRestoring) return;
  historyStack.push(snapshotState());
  if(historyStack.length > HISTORY_LIMIT) historyStack.shift();
}

function refreshBackgroundPreview(){
  const preview = $('#bgGradientPreview');
  if (!preview) return;
  const stops = computeSkyGradientStops(backgroundConfig);
  preview.style.background = `linear-gradient(180deg, ${stops.top}, ${stops.mid} 50%, ${stops.bottom})`;
}

function syncBackgroundFields(){
  const layout = backgroundConfig?.layout || {};
  const tiles = backgroundConfig?.tiles || {};
  const sky = backgroundConfig?.sky || {};
  const colors = Array.isArray(sky.colors) && sky.colors.length >= 3 ? sky.colors : BACKGROUND_DEFAULTS.skyColors;

  const portionPercent = Math.round(clampValue((layout.tilePortion ?? BACKGROUND_DEFAULTS.tilePortion) * 100, 0, 100));
  const tileScale = Number.isFinite(tiles.scale) ? tiles.scale : BACKGROUND_DEFAULTS.tileScale;
  const tileOffset = Number.isFinite(tiles.offsetY) ? tiles.offsetY : BACKGROUND_DEFAULTS.tileOffsetY;

  $('#bgTileUrl').value = tiles.url || '';
  $('#bgTileScale').value = tileScale;
  $('#bgTileOffsetY').value = tileOffset;
  $('#bgTilePortion').value = portionPercent;
  $('#bgTileFallback').value = tiles.fallbackColor || '';

  $('#bgSkyTop').value = colors[0] || BACKGROUND_DEFAULTS.skyColors[0];
  $('#bgSkyMid').value = colors[1] || BACKGROUND_DEFAULTS.skyColors[1];
  $('#bgSkyBottom').value = colors[2] || BACKGROUND_DEFAULTS.skyColors[2];
  $('#bgTime').value = Number.isFinite(sky.time24h) ? sky.time24h : BACKGROUND_DEFAULTS.time24h;

  refreshBackgroundPreview();
}

function commitBackgroundFromFields({ pushToHistory = true } = {}){
  const portionPercent = clampValue(toNumber($('#bgTilePortion').value, BACKGROUND_DEFAULTS.tilePortion * 100), 0, 100);
  const next = normalizeBackgroundConfig({
    layout: {
      tilePortion: portionPercent / 100,
    },
    tiles: {
      url: ($('#bgTileUrl').value || '').trim() || null,
      scale: toNumber($('#bgTileScale').value, backgroundConfig?.tiles?.scale ?? BACKGROUND_DEFAULTS.tileScale),
      offsetY: toNumber($('#bgTileOffsetY').value, backgroundConfig?.tiles?.offsetY ?? BACKGROUND_DEFAULTS.tileOffsetY),
      fallbackColor: ($('#bgTileFallback').value || '').trim() || null,
    },
    sky: {
      colors: [
        $('#bgSkyTop').value || BACKGROUND_DEFAULTS.skyColors[0],
        $('#bgSkyMid').value || BACKGROUND_DEFAULTS.skyColors[1],
        $('#bgSkyBottom').value || BACKGROUND_DEFAULTS.skyColors[2],
      ],
      time24h: toNumber($('#bgTime').value, backgroundConfig?.sky?.time24h ?? BACKGROUND_DEFAULTS.time24h),
    },
  }, backgroundConfig);

  const current = JSON.stringify(backgroundConfig || {});
  const incoming = JSON.stringify(next || {});
  if (current === incoming) {
    syncBackgroundFields();
    return;
  }

  if (pushToHistory && !isRestoring) {
    pushHistory();
  }
  backgroundConfig = next;
  syncBackgroundFields();
}
function restoreState(state){
  if(!state) return;
  isRestoring = true;
  exitSpawnPlacement();
  exitColliderPlacement();

  const adopted = adoptAreaState(state, state.meta || {});
  layoutMeta = { ...DEFAULT_LAYOUT_META, ...(adopted.meta || {}) };

  layers = adopted.layers.map((layer, index) => normalizeLayer(layer, index));
  instances.length = 0;
  nextInstId = 1;
  for (const inst of adopted.instances){
    const normalized = normalizeInstance(inst, nextInstId);
    if (normalized.id == null){
      normalized.id = nextInstId++;
    } else {
      nextInstId = Math.max(nextInstId, normalized.id + 1);
    }
    normalized.tags = Array.isArray(normalized.tags) ? normalized.tags : [];
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    instances.push(normalized);
  }

  const spawn = ensurePlayerSpawn();
  if (spawn && spawn.id >= nextInstId){
    nextInstId = spawn.id + 1;
  }

  colliders.length = 0;
  nextColliderId = 1;
  if (Array.isArray(adopted.colliders)){
    for (const col of adopted.colliders){
      const normalized = normalizeCollider(col, nextColliderId);
      if (normalized.id == null){
        normalized.id = nextColliderId++;
      } else {
        nextColliderId = Math.max(nextColliderId, normalized.id + 1);
      }
      colliders.push(normalized);
    }
  }
  selectedColliderId = colliders[0]?.id ?? null;

  drumSkins.length = 0;
  nextDrumSkinId = 1;
  if (Array.isArray(adopted.drumSkins)) {
    for (const drum of adopted.drumSkins) {
      const normalized = normalizeDrumSkin(drum, nextDrumSkinId, layers);
      normalized.id ??= nextDrumSkinId;
      nextDrumSkinId = Math.max(nextDrumSkinId + 1, (normalized.id || 0) + 1);
      drumSkins.push(normalized);
    }
  }
  selectedDrumSkinId = drumSkins[0]?.id ?? null;

  behaviorSpawners = Array.isArray(adopted.spawners)
    ? adopted.spawners.map((spawner, index) => normalizeBehaviorSpawner(spawner, index + 1))
    : [];
  selectedBehaviorSpawnerId = behaviorSpawners[0]?.spawnerId ?? null;
  behaviorPathTargets = Array.isArray(adopted.pathTargets)
    ? adopted.pathTargets.map((target, index) => normalizeEditorPathTarget(target, index + 1))
    : [];
  selectedPathTargetId = behaviorPathTargets[0]?.targetId ?? null;
  const adoptedBehaviorMeta = adopted.behavior && typeof adopted.behavior === 'object'
    ? adopted.behavior
    : (layoutMeta.behavior || {});
  behaviorPOIs = Array.isArray(adoptedBehaviorMeta.pois)
    ? adoptedBehaviorMeta.pois.map((poi, index) => normalizePOI(poi, index + 1))
    : [];
  selectedPOIId = behaviorPOIs[0]?.id ?? null;
  behaviorInteractionPoints = Array.isArray(adoptedBehaviorMeta.interactionPoints)
    ? adoptedBehaviorMeta.interactionPoints.map((point, index) => normalizeInteractionPoint(point, index + 1))
    : [];
  behaviorArrivalSpawns = Array.isArray(adoptedBehaviorMeta.arrivalSpawns)
    ? adoptedBehaviorMeta.arrivalSpawns.map((spawn, index) => normalizeArrivalSpawn(spawn, index + 1))
    : [];
  selectedInteractionId = behaviorInteractionPoints[0]?.interactionId ?? null;
  selectedArrivalId = behaviorArrivalSpawns[0]?.arrivalId ?? null;

  backgroundConfig = normalizeBackgroundConfig(adopted.background || adopted.meta?.background || backgroundConfig, backgroundConfig);

  activeLayerId = adopted.activeLayerId || layoutMeta.activeLayerId || getDefaultSpawnLayerId();
  cameraX = toNumber(adopted.camera?.startX, 0);
  zoom = toNumber(adopted.camera?.startZoom, 1);
  $('#groundOffset').value = toNumber(adopted.ground?.offset, DEFAULT_GROUND_OFFSET);
  $('#proximityScale').value = clampValue(adopted.proximityScale ?? layoutMeta.proximityScale ?? 1, 0.05, 50);
  selectedInstId = getPlayerSpawnInstance()?.id || (instances[0]?.id ?? null);

  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
  refreshInstanceList();
  refreshColliderList();
  refreshDrumSkinList();
  refreshBehaviorPanels();
  syncColliderFields();
  syncBackgroundFields();
  setCameraX(cameraX);
  setZoom(zoom);

  isRestoring = false;
}
function undo(){
  const st = historyStack.pop();
  if(st) restoreState(st);
}

/*** Easing + unified screen-space KF ***/
function ease01(mode, x){
  x = clamp(x,0,1);
  if (mode === 'smoothstep') return x*x*(3 - 2*x);
  if (mode === 'quadInOut')  return x < 0.5
      ? 2*x*x
      : 1 - Math.pow(-2*x + 2, 2) / 2;
  return x; // linear
}

/*
  Step 1: computeTFromDx(kfMeta, dxScreen)

    reticleX = center of screen
    dxScreen = rootScreenX - reticleX    (screen pixels)

    radiusPx = kfMeta.radiusPx || kfMeta.radius || 600
    t        = clamp(-dxScreen / radiusPx, -1, 1)

  This is done ONCE per structure instance (root).
*/
function computeTFromDx(kfMeta, dxScreen){
  const baseRadius =
    (kfMeta && Number.isFinite(kfMeta.radiusPx) && kfMeta.radiusPx > 0) ? kfMeta.radiusPx :
    (kfMeta && Number.isFinite(kfMeta.radius)   && kfMeta.radius   > 0) ? kfMeta.radius   :
    600;
  const radiusPx = Math.max(1, baseRadius);
  const rawT = -dxScreen / radiusPx;
  return {
    t: clamp(rawT, -1, 1),
    radiusPx
  };
}

/*
  Step 2: evalKfPose(kf, t)

  Given a shared t in [-1,1], lerp between left/center/right for this part.
  This matches the "single t, many parts" mental model.
*/
function evalKfPose(kf, t){
  if(!kf){
    return {
      t,
      dx:0, dy:0,
      scaleX:1,
      rotZdeg:0,
      translateSpace:'screen',
      order:'scaleThenRotate'
    };
  }

  const ease = kf.ease || 'smoothstep';
  const L = kf.left   || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const C = kf.center || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const R = kf.right  || {dx:0,dy:0,scaleX:1,rotZdeg:0};

  let from, to, u;
  if(t <= 0){
    // -1..0 : LEFT -> CENTER
    u = ease01(ease, t + 1); // [-1,0] -> [0,1]
    from = L; to = C;
  }else{
    // 0..1 : CENTER -> RIGHT
    u = ease01(ease, t);     // [0,1] -> [0,1]
    from = C; to = R;
  }

  return {
    t,
    dx:      lerp(from.dx      || 0, to.dx      || 0, u),
    dy:      lerp(from.dy      || 0, to.dy      || 0, u),
    scaleX:  lerp(from.scaleX ?? 1, to.scaleX ?? 1, u),
    rotZdeg: lerp(from.rotZdeg || 0, to.rotZdeg || 0, u),
    translateSpace: kf.translateSpace || 'screen',
    order:          kf.transformOrder || 'scaleThenRotate'
  };
}

/*** Apply a pose into current ctx, respecting translateSpace/order */
function applyPose(ctx, pose){
  const dx = pose.dx || 0;
  const dy = pose.dy || 0;
  const sx = (pose.scaleX != null ? pose.scaleX : 1);
  const rot = pose.rotZdeg || 0;
  const space = pose.translateSpace || 'screen';
  const order = pose.order || 'scaleThenRotate';

  // "screen": offsets in current (screen) space, before local scaling/rot.
  if(space === 'screen'){
    ctx.translate(dx, dy);
  }

  if(order === 'scaleThenRotate'){
    if(sx !== 1) ctx.scale(sx, 1);
    if(rot) ctx.rotate(rad(rot));
  }else{
    if(rot) ctx.rotate(rad(rot));
    if(sx !== 1) ctx.scale(sx, 1);
  }

  // "local": offsets after local transform (move in the part's space)
  if(space === 'local'){
    ctx.translate(dx, dy);
  }
}

/*** Anchors ***/
function computeAnchor(t){
  const w = t.w || 100;
  const h = t.h || 100;
  if(t.pivot === 'bottom') return {ax:w*0.5, ay:h};
  if(t.pivot === 'top')    return {ax:w*0.5, ay:0};
  if(t.pivot === 'center') return {ax:w*0.5, ay:h*0.5};
  const ax = (Number.isFinite(t.anchorXPct)? t.anchorXPct : 50) * 0.01 * w;
  const ay = (Number.isFinite(t.anchorYPct)? t.anchorYPct : 100) * 0.01 * h;
  return {ax, ay};
}

/*** Layers ***/
function createDefaultLayers(){
  return [
    { id:"bg1",  name:"Parallax 1", type:"parallax",  parallaxSpeed:0.2, offsetY:-120, separation:220, scale:0.7, meta:{} },
    { id:"bg2",  name:"Parallax 2", type:"parallax",  parallaxSpeed:0.4, offsetY:-90,  separation:220, scale:0.8, meta:{} },
    { id:"gameplay", name:"Gameplay", type:"gameplay", parallaxSpeed:1.0, offsetY:-20, separation:180, scale:1.0, meta:{} },
    { id:"fg1",  name:"Foreground 1", type:"foreground", parallaxSpeed:1.1, offsetY:-10, separation:180, scale:1.05, meta:{} },
    { id:"fg2",  name:"Foreground 2", type:"foreground", parallaxSpeed:1.2, offsetY:0,   separation:180, scale:1.1, meta:{} }
  ];
}
let layers = createDefaultLayers();
let activeLayerId = SPAWN_LAYER_ID && layers.some((l) => l.id === SPAWN_LAYER_ID) ? SPAWN_LAYER_ID : 'gameplay';
let layoutMeta = { ...DEFAULT_LAYOUT_META };
let drumSkins = [];
let nextDrumSkinId = 1;
let selectedDrumSkinId = null;
function getParallaxLayerCount(){ return layers.filter(l=>l.type==="parallax").length; }
function findLayer(id){ return layers.find(l=>l.id===id) || null; }
function getLayerGroundY(layerId){
  const layer = findLayer(layerId);
  const offsetY = toNumber(layer?.offsetY ?? layer?.yOffset, 0);
  const separation = toNumber(layer?.separation ?? layer?.sep, 0);
  return getGroundOffset() + offsetY + separation;
}

/*** Prefabs & Instances ***/
const imageCache = new Map();
const prefabs = {};
let selectedPrefabId = null;
let nextInstId = 1;
const instances = [];
let selectedInstId = null;
let playerSpawnInstId = null;
let spawnPlacementMode = false;
let editorMode = 'layout';

let behaviorSpawners = [];
let selectedBehaviorSpawnerId = null;
let behaviorPathTargets = [];
let selectedPathTargetId = null;
let behaviorPOIs = [];
let selectedPOIId = null;
let behaviorInteractionPoints = [];
let selectedInteractionId = null;
let behaviorArrivalSpawns = [];
let selectedArrivalId = null;
let behaviorPlacement = null;
const colliders = [];
let nextColliderId = 1;
let selectedColliderId = null;
let colliderPlacementMode = false;
let activeColliderDrag = null;

function isPlayerSpawn(inst){
  return Array.isArray(inst?.tags) && inst.tags.includes('spawn:player');
}

function getDefaultSpawnLayerId(){
  if (findLayer(SPAWN_LAYER_ID)) return SPAWN_LAYER_ID;
  const gameplay = layers.find((layer) => layer.type === 'gameplay');
  return gameplay ? gameplay.id : (layers[0]?.id || 'gameplay');
}

function ensurePlayerSpawn(){
  let spawn = instances.find(isPlayerSpawn);
  const spawnLayerId = getDefaultSpawnLayerId();
  if (!spawn){
    spawn = {
      id: nextInstId++,
      prefabId: 'spawn_player',
      layerId: spawnLayerId,
      position: { x: 0, y: 0 },
      scale: { x: 1, y: 1 },
      rotationDeg: 0,
      locked: true,
      tags: ['spawn:player'],
      meta: {},
    };
    instances.push(spawn);
  } else {
    if (!Array.isArray(spawn.tags)) spawn.tags = [];
    if (!spawn.tags.includes('spawn:player')) spawn.tags.push('spawn:player');
    spawn.layerId = spawn.layerId || spawnLayerId;
    spawn.position = normalizePosition(spawn.position);
    spawn.scale = normalizeScale(spawn.scale);
    spawn.rotationDeg = Number.isFinite(spawn.rotationDeg) ? spawn.rotationDeg : 0;
    spawn.meta = spawn.meta && typeof spawn.meta === 'object' ? spawn.meta : {};
  }
  playerSpawnInstId = spawn.id;
  return spawn;
}

function getPlayerSpawnInstance(){
  if (playerSpawnInstId != null){
    const inst = instances.find((item) => item.id === playerSpawnInstId);
    if (inst) return inst;
  }
  const spawn = instances.find(isPlayerSpawn) || null;
  if (spawn) playerSpawnInstId = spawn.id;
  return spawn;
}

function exitSpawnPlacement(){
  spawnPlacementMode = false;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('spawn-mode');
}

function syncSpawnHeightField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = getPlayerSpawnInstance();
  if (!spawn){
    field.value = '';
    return;
  }
  const pos = normalizePosition(spawn.position);
  field.value = Number.isFinite(pos.y) ? pos.y : 0;
}

function updateSpawnHeightFromField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = ensurePlayerSpawn();
  if (!spawn) return;
  const val = parseFloat(field.value);
  if (!Number.isFinite(val)) {
    syncSpawnHeightField();
    return;
  }
  spawn.position = normalizePosition(spawn.position);
  if (spawn.position.y === val) return;
  pushHistory();
  spawn.position.y = val;
  refreshInstanceList();
}

function toNumber(value, fallback){
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function normalizePosition(position){
  if (!position || typeof position !== 'object'){
    return { x: 0, y: 0 };
  }
  const x = toNumber(position.x, 0);
  const y = toNumber(position.y, 0);
  return { x, y };
}

function normalizeScale(scale){
  if (!scale || typeof scale !== 'object'){
    return { x: 1, y: 1 };
  }
  const x = toNumber(scale.x, 1) || 1;
  const y = toNumber(scale.y, scale.x ?? 1) || 1;
  return { x, y };
}

function normalizeBehaviorSpawner(spawner, fallbackId = 1){
  const safe = spawner && typeof spawner === 'object' ? { ...spawner } : {};
  const spawnerId = typeof safe.spawnerId === 'string' && safe.spawnerId.trim()
    ? safe.spawnerId.trim()
    : (typeof safe.id === 'string' && safe.id.trim() ? safe.id.trim() : `spawner_${fallbackId}`);
  const layerId = typeof safe.layerId === 'string' && safe.layerId.trim()
    ? safe.layerId.trim()
    : getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position);
  const spawnRadius = toNumber(safe.spawnRadius ?? safe.radius, 0) || 0;
  const count = Math.max(1, toNumber(safe.count ?? safe.maxCount, 1) || 1);
  const respawn = !!safe.respawn;
  const templateId = typeof safe.templateId === 'string' ? safe.templateId.trim() : '';
  const characterId = typeof safe.characterId === 'string' ? safe.characterId.trim() : '';
  const meta = safe.meta && typeof safe.meta === 'object' ? { ...safe.meta } : {};
  return {
    ...safe,
    spawnerId,
    id: spawnerId,
    layerId,
    position,
    spawnRadius,
    count,
    respawn,
    templateId,
    characterId,
    meta,
    type: typeof safe.type === 'string' && safe.type.trim() ? safe.type.trim() : 'npc',
  };
}

function normalizeEditorPathTarget(target, fallbackId = 1){
  const safe = target && typeof target === 'object' ? { ...target } : {};
  const targetId = typeof safe.targetId === 'string' && safe.targetId.trim()
    ? safe.targetId.trim()
    : (typeof safe.id === 'string' && safe.id.trim() ? safe.id.trim() : `target_${fallbackId}`);
  const name = typeof safe.name === 'string' && safe.name.trim() ? safe.name.trim() : targetId;
  const layerId = typeof safe.layerId === 'string' && safe.layerId.trim()
    ? safe.layerId.trim()
    : getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position);
  const order = toNumber(safe.order ?? safe.meta?.order ?? safe.meta?.pathOrder, null);
  const instanceId = typeof safe.instanceId === 'string' && safe.instanceId.trim() ? safe.instanceId.trim() : '';
  const meta = safe.meta && typeof safe.meta === 'object' ? { ...safe.meta } : {};
  return {
    ...safe,
    targetId,
    id: targetId,
    name,
    layerId,
    position,
    order: Number.isFinite(order) ? order : null,
    instanceId,
    meta,
  };
}

function normalizePOI(poi, fallbackId = 1){
  const safe = poi && typeof poi === 'object' ? { ...poi } : {};
  const id = typeof safe.id === 'string' && safe.id.trim()
    ? safe.id.trim()
    : `poi_${fallbackId}`;
  const name = typeof safe.name === 'string' && safe.name.trim() ? safe.name.trim() : 'poi';
  const label = typeof safe.label === 'string' && safe.label.trim() ? safe.label.trim() : name;
  const type = typeof safe.type === 'string' && safe.type.trim() ? safe.type.trim() : 'box';
  const bounds = safe.bounds && typeof safe.bounds === 'object' ? safe.bounds : {};
  const normalizedBounds = {
    left: toNumber(bounds.left, 0),
    width: toNumber(bounds.width, 120),
    top: toNumber(bounds.top, -50),
    height: toNumber(bounds.height, 100)
  };
  const meta = safe.meta && typeof safe.meta === 'object' ? { ...safe.meta } : {};
  const scheduleHours = Array.isArray(meta.scheduleHours) ? meta.scheduleHours : [];
  return {
    id,
    name,
    label,
    type,
    bounds: normalizedBounds,
    meta: {
      ...meta,
      scheduleHours: scheduleHours.length > 0 ? scheduleHours : undefined
    }
  };
}

function normalizeInteractionPoint(point, fallbackId = 1){
  const safe = point && typeof point === 'object' ? { ...point } : {};
  const interactionId = typeof safe.interactionId === 'string' && safe.interactionId.trim()
    ? safe.interactionId.trim()
    : (typeof safe.id === 'string' && safe.id.trim() ? safe.id.trim() : `interaction_${fallbackId}`);
  const layerId = typeof safe.layerId === 'string' && safe.layerId.trim()
    ? safe.layerId.trim()
    : getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position);
  const action = typeof safe.action === 'string' ? safe.action.trim() : '';
  const target = typeof safe.target === 'string' ? safe.target.trim() : '';
  const prompt = typeof safe.prompt === 'string' ? safe.prompt.trim() : '';
  const meta = safe.meta && typeof safe.meta === 'object' ? { ...safe.meta } : {};
  return {
    ...safe,
    interactionId,
    id: interactionId,
    layerId,
    position,
    action,
    target,
    prompt,
    meta,
  };
}

function normalizeArrivalSpawn(spawn, fallbackId = 1){
  const safe = spawn && typeof spawn === 'object' ? { ...spawn } : {};
  const arrivalId = typeof safe.arrivalId === 'string' && safe.arrivalId.trim()
    ? safe.arrivalId.trim()
    : (typeof safe.id === 'string' && safe.id.trim() ? safe.id.trim() : `arrival_${fallbackId}`);
  const layerId = typeof safe.layerId === 'string' && safe.layerId.trim()
    ? safe.layerId.trim()
    : getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position);
  const fromAreaId = typeof safe.fromAreaId === 'string' && safe.fromAreaId.trim()
    ? safe.fromAreaId.trim()
    : (typeof safe.from === 'string' && safe.from.trim() ? safe.from.trim() : '');
  const meta = safe.meta && typeof safe.meta === 'object' ? { ...safe.meta } : {};
  return {
    ...safe,
    arrivalId,
    id: arrivalId,
    layerId,
    position,
    fromAreaId,
    meta,
  };
}

function normalizeStretchQuadSpec(raw){
  if (!raw || typeof raw !== 'object') return null;
  const targetLayerId = typeof raw.targetLayerId === 'string' ? raw.targetLayerId.trim() : '';
  const height = toNumber(raw.height ?? raw.span ?? raw.topHeight ?? raw.topAboveGround, null);
  if (!targetLayerId || !Number.isFinite(height) || height <= 0) return null;

  const topOffset = toNumber(raw.topOffset ?? raw.topYOffset ?? raw.yOffset, 0) || 0;
  const slicesRaw = Math.round(toNumber(raw.slices ?? raw.strips ?? raw.steps, 24) || 24);
  const slices = clamp(slicesRaw, 4, 80);

  return { targetLayerId, height, topOffset, slices };
}

function normalizeDrumSkin(raw, index = 0, layerList = layers){
  const safe = raw && typeof raw === 'object' ? JSON.parse(JSON.stringify(raw)) : {};
  const parallaxLayers = Array.isArray(layerList)
    ? layerList.filter((layer) => layer?.type === 'parallax')
    : [];
  const fallbackTopLayer = parallaxLayers[0];
  const fallbackBottomLayer = parallaxLayers[1] || parallaxLayers[0];
  const legacyLayerAId = typeof safe.layerA === 'string' && safe.layerA.trim() ? safe.layerA.trim() : fallbackTopLayer?.id;
  const legacyLayerBId = typeof safe.layerB === 'string' && safe.layerB.trim() ? safe.layerB.trim() : fallbackBottomLayer?.id;
  const legacyLayerA = legacyLayerAId ? findLayer(legacyLayerAId) : fallbackTopLayer;
  const legacyLayerB = legacyLayerBId ? findLayer(legacyLayerBId) : fallbackBottomLayer;

  const defaultTopParallax = toNumber(safe.topParallax ?? safe.parallaxTop ?? safe.parallaxA, legacyLayerA?.parallaxSpeed ?? 1) || 1;
  const defaultBottomParallax = toNumber(safe.bottomParallax ?? safe.parallaxBottom ?? safe.parallaxB, legacyLayerB?.parallaxSpeed ?? defaultTopParallax) || defaultTopParallax;

  const defaultTopScale = toNumber(safe.topScale ?? safe.scaleTop ?? safe.scaleA, legacyLayerA?.scale ?? 1) || 1;
  const defaultBottomScale = toNumber(safe.bottomScale ?? safe.scaleBottom ?? safe.scaleB, legacyLayerB?.scale ?? defaultTopScale) || defaultTopScale;

  const legacyHeightA = toNumber(safe.heightA ?? safe.offsetA ?? safe.yOffsetA, null);
  const legacyHeightB = toNumber(safe.heightB ?? safe.offsetB ?? safe.yOffsetB, null);

  const topYOffset = toNumber(
    safe.topYOffset ?? safe.topOffset ?? safe.offsetTop ?? (Number.isFinite(legacyHeightA)
      ? (legacyLayerA?.offsetY ?? fallbackTopLayer?.offsetY ?? 0) - legacyHeightA
      : null),
    legacyLayerA?.offsetY ?? fallbackTopLayer?.offsetY ?? 0,
  ) || 0;
  const bottomYOffset = toNumber(
    safe.bottomYOffset ?? safe.bottomOffset ?? safe.offsetBottom ?? (Number.isFinite(legacyHeightB)
      ? (legacyLayerB?.offsetY ?? fallbackBottomLayer?.offsetY ?? 0) - legacyHeightB
      : null),
    legacyLayerB?.offsetY ?? fallbackBottomLayer?.offsetY ?? topYOffset,
  ) || 0;

  const prefabId = typeof safe.prefabId === 'string' ? safe.prefabId.trim() : '';
  const textureId = typeof safe.textureId === 'string' ? safe.textureId.trim() : '';
  const prefabRef = textureId || prefabId;
  const imageURL = typeof safe.imageURL === 'string' ? safe.imageURL.trim() : '';
  const tileScale = toNumber(safe.tileScale, 1) || 1;
  const visible = safe.visible !== false;
  const id = safe.id ?? safe.drumSkinId ?? index + 1;
  return {
    id,
    topParallax: defaultTopParallax,
    bottomParallax: defaultBottomParallax,
    topScale: defaultTopScale,
    bottomScale: defaultBottomScale,
    topYOffset,
    bottomYOffset,
    prefabId: prefabRef,
    textureId: prefabRef,
    imageURL,
    tileScale,
    visible,
    legacyLayerA: legacyLayerA?.id ?? null,
    legacyLayerB: legacyLayerB?.id ?? null,
  };
}

// Expanded/Refactored: 
// Now checks area-level drumSkin layer config before instance meta
function getStretchQuadMeta(inst, areaDrumSkins) {
  // Prefer area-level drumSkinLayers over legacy instance meta
  if (Array.isArray(areaDrumSkins)) {
    // Check if instance sits on a ground span drum skin
    for (const drum of areaDrumSkins) {
      const layerAId = drum.legacyLayerA || drum.layerA || null;
      const layerBId = drum.legacyLayerB || drum.layerB || null;
      // If instance is positioned within the drum skin quad (custom test as needed)
      // Example: check if inst.layerId is between drum.layerA and drum.layerB
      if (
        inst &&
        drum.visible &&
        (
          (layerAId && inst.layerId === layerAId) ||
          (layerBId && inst.layerId === layerBId) ||
          // Or custom geometric test for inside quad...
          false
        )
      ) {
        return {
          spec: {
            topParallax: drum.topParallax,
            bottomParallax: drum.bottomParallax,
            topYOffset: drum.topYOffset,
            bottomYOffset: drum.bottomYOffset,
            imageURL: drum.imageURL,
            tileScale: drum.tileScale || 1.0
          },
          key: "areaDrumSkin"
        };
      }
    }
  }
  // --- Legacy support: instance-level meta ---
  const meta = inst?.meta && typeof inst.meta === 'object' ? inst.meta : null;
  if (!meta) return { spec: null, key: null };
  if (meta.stretchQuad) return { spec: normalizeStretchQuadSpec(meta.stretchQuad), key: 'stretchQuad' };
  if (meta.groundSpan) return { spec: normalizeStretchQuadSpec(meta.groundSpan), key: 'groundSpan' };
  if (meta.drumSkin) return { spec: normalizeStretchQuadSpec(meta.drumSkin), key: 'drumSkin' };
  return { spec: null, key: null };
}

function normalizeLayer(layer, index = 0){
  const safe = layer && typeof layer === 'object' ? JSON.parse(JSON.stringify(layer)) : {};
  const id = safe.id || `layer_${index}`;
  const name = safe.name || `Layer ${index + 1}`;
  const type = safe.type || 'gameplay';
  const parallaxSpeed = toNumber(safe.parallaxSpeed ?? safe.parallax, 1);
  const offsetY = toNumber(safe.offsetY ?? safe.yOffset, 0);
  const separation = toNumber(safe.separation ?? safe.sep, 0);
  const scale = toNumber(safe.scale, 1);
  const source = safe.source ?? null;
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, name, type, parallaxSpeed, offsetY, separation, scale, source, meta };
}

function normalizeInstance(inst, fallbackId = 0){
  const safe = inst && typeof inst === 'object' ? JSON.parse(JSON.stringify(inst)) : {};
  const id = safe.id ?? safe.meta?.original?.id ?? fallbackId;
  const prefabId = safe.prefabId ?? safe.meta?.original?.prefabId ?? 'unknown_prefab';
  const layerId = safe.layerId ?? safe.meta?.original?.layerId ?? getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position ?? { x: safe.x, y: safe.y ?? (safe.offsetY != null ? -safe.offsetY : 0) });
  const scale = normalizeScale(safe.scale ?? { x: safe.scaleX, y: safe.scaleY });
  const rotationDeg = toNumber(safe.rotationDeg ?? safe.rot, 0);
  const locked = !!(safe.locked ?? safe.meta?.original?.locked);
  const tags = Array.isArray(safe.tags)
    ? safe.tags.map((tag) => String(tag))
    : Array.isArray(safe.meta?.original?.tags)
      ? safe.meta.original.tags.map((tag) => String(tag))
      : [];
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, prefabId, layerId, position, scale, rotationDeg, locked, tags, meta };
}

function normalizeCollider(raw, fallbackId = 1){
  const safe = raw && typeof raw === 'object' ? JSON.parse(JSON.stringify(raw)) : {};
  const id = safe.id ?? safe.meta?.original?.id ?? fallbackId;
  const labelRaw = typeof safe.label === 'string' ? safe.label.trim() : '';
  const type = (safe.type === 'box' || safe.shape === 'box') ? 'box' : 'box';
  const materialTypeRaw = typeof safe.materialType === 'string' ? safe.materialType.trim() : '';
  const metaMaterialType = typeof safe.meta?.materialType === 'string' ? safe.meta.materialType.trim() : '';
  const legacyStepSoundRaw = typeof safe.stepSound === 'string' ? safe.stepSound.trim() : '';
  const legacyMetaStepSound = typeof safe.meta?.stepSound === 'string' ? safe.meta.stepSound.trim() : '';
  const normalizedMaterialType = materialTypeRaw
    || metaMaterialType
    || legacyStepSoundRaw
    || legacyMetaStepSound
    || '';

  let left = toNumber(safe.left ?? safe.x ?? safe.position?.x, 0);
  const rightRaw = safe.right ?? safe.meta?.original?.right;
  let width = toNumber(safe.width ?? safe.w, null);
  if (!Number.isFinite(width) && Number.isFinite(rightRaw)){
    width = toNumber(rightRaw, left) - left;
  }
  if (!Number.isFinite(width)) width = 120;
  if (width < 0){
    left += width;
    width = Math.abs(width);
  }

  let topOffset = toNumber(safe.topOffset ?? safe.top ?? safe.y ?? safe.offsetY, 0);
  const bottomRaw = safe.bottomOffset ?? safe.bottom ?? safe.meta?.bottomOffset;
  let height = toNumber(safe.height ?? safe.h, null);
  if (!Number.isFinite(height) && Number.isFinite(bottomRaw)){
    height = toNumber(bottomRaw, 0) - topOffset;
  }
  if (!Number.isFinite(height)) height = 40;
  if (height < 0){
    topOffset += height;
    height = Math.abs(height);
  }

  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};

  return {
    id,
    label: labelRaw || `Collider ${id ?? fallbackId}`,
    type,
    left,
    width: Math.max(1, width),
    topOffset,
    height: Math.max(1, height),
    materialType: normalizedMaterialType || null,
    meta,
  };
}

function adoptAreaState(area, context = {}){
  const raw = area && typeof area === 'object' ? JSON.parse(JSON.stringify(area)) : {};
  const id = raw.id || raw.areaId || context.areaId || DEFAULT_LAYOUT_META.areaId;
  const name = raw.name || raw.areaName || context.areaName || DEFAULT_LAYOUT_META.areaName;
  const camera = {
    startX: toNumber(raw.camera?.startX ?? raw.cameraStartX, 0),
    startZoom: toNumber(raw.camera?.startZoom ?? raw.zoomStart, 1),
  };
  const ground = {
    offset: toNumber(raw.ground?.offset ?? raw.groundOffset, DEFAULT_GROUND_OFFSET),
  };
  const proximityScale = clampValue(toNumber(raw.proximityScale ?? raw.meta?.proximityScale, 1) || 1, 0.05, 50);
  const layersList = Array.isArray(raw.layers) && raw.layers.length
    ? raw.layers.map((layer, index) => normalizeLayer(layer, index))
    : createDefaultLayers();
  const instancesList = Array.isArray(raw.instances) ? raw.instances : [];
  const normalizedInstances = [];
  let fallbackId = 1;
  for (const inst of instancesList){
    const normalized = normalizeInstance(inst, fallbackId);
    if (normalized.id == null){
      normalized.id = fallbackId;
    }
    fallbackId = Math.max(fallbackId + 1, normalized.id + 1);
    normalizedInstances.push(normalized);
  }

  const collidersList = Array.isArray(raw.colliders) ? raw.colliders : [];
  const normalizedColliders = [];
  let fallbackColliderId = 1;
  for (const collider of collidersList){
    const normalized = normalizeCollider(collider, fallbackColliderId);
    if (normalized.id == null){
      normalized.id = fallbackColliderId;
    }
    fallbackColliderId = Math.max(fallbackColliderId + 1, normalized.id + 1);
    normalizedColliders.push(normalized);
  }

  const drumSkinList = Array.isArray(raw.drumSkins) ? raw.drumSkins : [];
  const normalizedDrumSkins = drumSkinList.map((drum, index) => normalizeDrumSkin(drum, index, layersList));
  const migratedFromInstances = [];
  for (const inst of normalizedInstances) {
    const legacy = inst?.meta?.drumSkin || inst?.meta?.groundSpan || inst?.meta?.stretchQuad || null;
    const normalizedLegacy = normalizeStretchQuadSpec(legacy);
    if (normalizedLegacy) {
      migratedFromInstances.push({
        legacyLayerA: inst.layerId,
        legacyLayerB: normalizedLegacy.targetLayerId,
        topParallax: findLayer(inst.layerId)?.parallaxSpeed ?? 1,
        bottomParallax: findLayer(normalizedLegacy.targetLayerId)?.parallaxSpeed ?? 1,
        topScale: findLayer(inst.layerId)?.scale ?? 1,
        bottomScale: findLayer(normalizedLegacy.targetLayerId)?.scale ?? 1,
        topYOffset: findLayer(inst.layerId)?.offsetY ?? 0,
        bottomYOffset: (findLayer(normalizedLegacy.targetLayerId)?.offsetY ?? 0) - (normalizedLegacy.height || 0),
        prefabId: inst.prefabId || '',
        imageURL: inst?.prefab?.imageURL || inst?.prefab?.url || '',
        tileScale: 1,
        visible: true,
      });
      if (inst.meta) {
        delete inst.meta.drumSkin;
        delete inst.meta.groundSpan;
        delete inst.meta.stretchQuad;
      }
    }
  }
  const combinedDrumSkins = [...normalizedDrumSkins];
  migratedFromInstances.forEach((drum) => combinedDrumSkins.push(normalizeDrumSkin(drum, combinedDrumSkins.length, layersList)));

  const spawnerList = Array.isArray(raw.spawners) ? raw.spawners : [];
  const pathTargetList = Array.isArray(raw.pathTargets) ? raw.pathTargets : [];
  const behaviorMeta = raw.meta?.behavior && typeof raw.meta.behavior === 'object' ? { ...raw.meta.behavior } : {};
  const normalizedSpawners = spawnerList.map((spawner, index) => normalizeBehaviorSpawner(spawner, index + 1));
  const normalizedPathTargets = pathTargetList.map((target, index) => normalizeEditorPathTarget(target, index + 1));
  const normalizedInteractionPoints = Array.isArray(behaviorMeta.interactionPoints)
    ? behaviorMeta.interactionPoints.map((point, index) => normalizeInteractionPoint(point, index + 1))
    : [];
  const normalizedArrivalSpawns = Array.isArray(behaviorMeta.arrivalSpawns || behaviorMeta.playerArrivalSpawns)
    ? (behaviorMeta.arrivalSpawns || behaviorMeta.playerArrivalSpawns)
      .map((spawn, index) => normalizeArrivalSpawn(spawn, index + 1))
    : [];

  const meta = raw.meta && typeof raw.meta === 'object' ? { ...raw.meta } : {};
  const background = normalizeBackgroundConfig(raw.background || meta.background || null, backgroundConfig);
  const activeLayerId = raw.activeLayerId
    || meta.activeLayerId
    || layersList[0]?.id
    || getDefaultSpawnLayerId();

  return {
    id,
    name,
    camera,
    ground,
    proximityScale,
    layers: layersList,
    instances: normalizedInstances,
    colliders: normalizedColliders,
    drumSkins: combinedDrumSkins,
    spawners: normalizedSpawners,
    pathTargets: normalizedPathTargets,
    behavior: {
      ...behaviorMeta,
      interactionPoints: normalizedInteractionPoints,
      arrivalSpawns: normalizedArrivalSpawns,
    },
    meta: {
      ...meta,
      areaId: id,
      areaName: name,
      sourcePath: context.sourcePath ?? meta.sourcePath ?? null,
      repositoryId: context.repositoryId ?? meta.repositoryId ?? null,
      proximityScale,
      background,
      behavior: {
        ...behaviorMeta,
        interactionPoints: normalizedInteractionPoints,
        arrivalSpawns: normalizedArrivalSpawns,
      },
    },
    background,
    activeLayerId,
  };
}

function buildAreaDescriptor(){
  ensurePlayerSpawn();
  const normalizedBackground = backgroundConfig ? normalizeBackgroundConfig(backgroundConfig, backgroundConfig) : null;
  const clonedLayers = layers.map((layer, index) => {
    const normalized = normalizeLayer(layer, index);
    return {
      id: normalized.id,
      name: normalized.name,
      type: normalized.type,
      parallaxSpeed: normalized.parallaxSpeed,
      offsetY: normalized.offsetY,
      separation: normalized.separation,
      scale: normalized.scale,
      source: normalized.source ?? null,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedInstances = instances.map((inst, index) => {
    const normalized = normalizeInstance(inst, inst.id ?? index + 1);
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    return {
      id: normalized.id ?? index + 1,
      prefabId: normalized.prefabId,
      layerId: normalized.layerId,
      position: normalized.position,
      scale: normalized.scale,
      rotationDeg: toNumber(normalized.rotationDeg, 0),
      locked: !!normalized.locked,
      tags: Array.isArray(normalized.tags) ? normalized.tags.map((tag) => String(tag)) : [],
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedColliders = colliders.map((col, index) => {
    const normalized = normalizeCollider(col, col.id ?? index + 1);
    const materialType = typeof normalized.materialType === 'string' ? normalized.materialType.trim() : '';
    const descriptor = {
      id: normalized.id ?? index + 1,
      label: typeof normalized.label === 'string' && normalized.label.trim()
        ? normalized.label.trim()
        : `Collider ${index + 1}`,
      type: normalized.type || 'box',
      shape: normalized.type || 'box',
      left: toNumber(normalized.left, 0) || 0,
      width: Math.max(1, toNumber(normalized.width, 120) || 120),
      topOffset: toNumber(normalized.topOffset, 0) || 0,
      height: Math.max(1, toNumber(normalized.height, 40) || 40),
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
    if (materialType) {
      descriptor.materialType = materialType;
    }
    return descriptor;
  });

  const clonedDrumSkins = drumSkins.map((drum, index) => {
    const normalized = normalizeDrumSkin(drum, drum.id ?? index + 1, layers);
    return { ...normalized };
  });
  nextDrumSkinId = clonedDrumSkins.reduce((maxId, drum) => Math.max(maxId, (drum.id ?? 0) + 1), 1);

  const clonedSpawners = behaviorSpawners.map((spawner, index) => {
    const normalized = normalizeBehaviorSpawner(spawner, index + 1);
    normalized.position = normalizePosition(normalized.position);
    return {
      ...normalized,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedPathTargets = behaviorPathTargets.map((target, index) => {
    const normalized = normalizeEditorPathTarget(target, index + 1);
    normalized.position = normalizePosition(normalized.position);
    return {
      ...normalized,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedPOIs = behaviorPOIs.map((poi, index) => {
    const normalized = normalizePOI(poi, index + 1);
    return {
      ...normalized,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedInteractions = behaviorInteractionPoints.map((point, index) => {
    const normalized = normalizeInteractionPoint(point, index + 1);
    normalized.position = normalizePosition(normalized.position);
    return {
      ...normalized,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedArrivalSpawns = behaviorArrivalSpawns.map((spawn, index) => {
    const normalized = normalizeArrivalSpawn(spawn, index + 1);
    normalized.position = normalizePosition(normalized.position);
    return {
      ...normalized,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const meta = {
    ...layoutMeta,
    proximityScale: getProximityScale(),
    background: normalizedBackground,
    activeLayerId,
    behavior: {
      ...(layoutMeta.behavior || {}),
      pois: clonedPOIs,
      interactionPoints: clonedInteractions,
      arrivalSpawns: clonedArrivalSpawns,
    },
  };

  return {
    id: meta.areaId || DEFAULT_LAYOUT_META.areaId,
    name: meta.areaName || DEFAULT_LAYOUT_META.areaName,
    source: 'map-editor',
    camera: {
      startX: cameraX,
      startZoom: zoom,
    },
    ground: {
      offset: getGroundOffset(),
    },
    proximityScale: getProximityScale(),
    background: normalizedBackground,
    layers: clonedLayers,
    instances: clonedInstances,
    colliders: clonedColliders,
    drumSkins: clonedDrumSkins,
    spawners: clonedSpawners,
    pathTargets: clonedPathTargets,
    meta,
  };
}

async function convertDataToArea(data, context = {}){
  const runtime = await getRuntimeModule();
  return runtime.convertLayoutToArea(data || {}, {
    areaId: context.areaId || context.meta?.areaId || DEFAULT_LAYOUT_META.areaId,
    areaName: context.areaName || context.meta?.areaName || DEFAULT_LAYOUT_META.areaName,
    prefabResolver: (prefabId) => {
      const prefab = prefabs[prefabId];
      return prefab ? JSON.parse(JSON.stringify(prefab)) : null;
    },
  });
}

function getRepositoryEntry(mapId){
  return REPOSITORY_LAYOUTS.find((entry) => entry.id === mapId) || null;
}

async function loadRepositoryMapById(mapId){
  const entry = getRepositoryEntry(mapId) || getRepositoryEntry(DEFAULT_LAYOUT_META.areaId);
  const context = {
    areaId: entry?.id || DEFAULT_LAYOUT_META.areaId,
    areaName: entry?.areaName || entry?.label || DEFAULT_LAYOUT_META.areaName,
    sourcePath: entry?.path || null,
    repositoryId: entry?.id || null,
  };

  await ensureConfiguredPrefabsLoaded();

  try {
    const areaData = entry?.path
      ? await (async () => {
          const response = await fetch(entry.path, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const json = await response.json();
          return convertDataToArea(json, context);
        })()
      : await convertDataToArea({}, context);
    restoreState(areaData);
  } catch (error) {
    console.error('[map-editor] failed to load map from repository', error);
    const fallbackArea = await convertDataToArea({}, context);
    restoreState(fallbackArea);
    alert(`Failed to load map: ${error.message}. Loaded empty layout instead.`);
  }
  historyStack.length = 0;
  pushHistory();
  const select = $('#mapRepoSelect');
  if (select) select.value = context.repositoryId || select.value;
}

function populateRepositorySelect(){
  const select = $('#mapRepoSelect');
  if (!select) return;
  select.innerHTML = '';
  REPOSITORY_LAYOUTS.forEach((entry) => {
    const opt = document.createElement('option');
    opt.value = entry.id;
    opt.textContent = entry.label;
    select.appendChild(opt);
  });
  const targetId = layoutMeta.repositoryId || DEFAULT_LAYOUT_META.repositoryId;
  if (targetId) select.value = targetId;
}

let cameraX = 0;
let zoom = 1;
let debugOverlay = false;

function getGroundOffset(){
  return parseFloat($('#groundOffset').value) || DEFAULT_GROUND_OFFSET;
}

function getProximityScale(){
  return clampValue(toNumber($('#proximityScale').value, 1) || 1, 0.05, 50);
}

/*** Layer UI & stack ***/
function rebuildActiveLayerSelect(){
  const sel = $('#activeLayerSelect');
  const instLayerSel = $('#instLayer');
  const stretchLayerSel = $('#instStretchLayer');
  const behaviorSpawnerLayerSel = $('#behaviorSpawnerLayer');
  const behaviorPathLayerSel = $('#behaviorPathLayer');
  const behaviorInteractionLayerSel = $('#behaviorInteractionLayer');
  const behaviorArrivalLayerSel = $('#behaviorArrivalLayer');
  sel.innerHTML = '';
  instLayerSel.innerHTML = '';
  if (stretchLayerSel){
    stretchLayerSel.innerHTML = '';
    const noneOpt = document.createElement('option');
    noneOpt.value = '';
    noneOpt.textContent = '—';
    stretchLayerSel.appendChild(noneOpt);
  }
  layers.forEach(layer=>{
    const o = document.createElement('option');
    o.value = layer.id; o.textContent = layer.name;
    sel.appendChild(o);
    const o2 = document.createElement('option');
    o2.value = layer.id; o2.textContent = layer.name;
    instLayerSel.appendChild(o2);
    if (behaviorSpawnerLayerSel){
      const option = document.createElement('option');
      option.value = layer.id; option.textContent = layer.name;
      behaviorSpawnerLayerSel.appendChild(option);
    }
    if (behaviorPathLayerSel){
      const option = document.createElement('option');
      option.value = layer.id; option.textContent = layer.name;
      behaviorPathLayerSel.appendChild(option);
    }
    if (behaviorInteractionLayerSel){
      const option = document.createElement('option');
      option.value = layer.id; option.textContent = layer.name;
      behaviorInteractionLayerSel.appendChild(option);
    }
    if (behaviorArrivalLayerSel){
      const option = document.createElement('option');
      option.value = layer.id; option.textContent = layer.name;
      behaviorArrivalLayerSel.appendChild(option);
    }
    if (stretchLayerSel){
      const o3 = document.createElement('option');
      o3.value = layer.id; o3.textContent = layer.name;
      stretchLayerSel.appendChild(o3);
    }
  });
  if(!findLayer(activeLayerId) && layers.length){
    activeLayerId = layers[0].id;
  }
  sel.value = activeLayerId;
  if (behaviorSpawnerLayerSel) behaviorSpawnerLayerSel.value = behaviorSpawnerLayerSel.value || activeLayerId;
  if (behaviorPathLayerSel) behaviorPathLayerSel.value = behaviorPathLayerSel.value || getDefaultSpawnLayerId();
  if (behaviorInteractionLayerSel) behaviorInteractionLayerSel.value = behaviorInteractionLayerSel.value || activeLayerId;
  if (behaviorArrivalLayerSel) behaviorArrivalLayerSel.value = behaviorArrivalLayerSel.value || activeLayerId;
}
function rebuildLayerStack(){
  const stack = $('#layerStack');
  stack.innerHTML = '';
  layers.forEach(layer=>{
    const div = document.createElement('div');
    div.className = 'layer-item' + (layer.id===activeLayerId ? ' active' : '');
    div.draggable = true;
    div.dataset.layerId = layer.id;
    div.innerHTML = `
      <span>${layer.name}</span>
      <span class="layer-item-type">${layer.type}</span>
    `;
    div.addEventListener('click', () => setActiveLayer(layer.id));
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', layer.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
    });
    div.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    div.addEventListener('drop', e => {
      e.preventDefault();
      const srcId = e.dataTransfer.getData('text/plain');
      const dstId = layer.id;
      if(!srcId || srcId === dstId) return;
      pushHistory();
      const srcIndex = layers.findIndex(l=>l.id===srcId);
      const dstIndex = layers.findIndex(l=>l.id===dstId);
      if(srcIndex<0 || dstIndex<0) return;
      const [moved] = layers.splice(srcIndex,1);
      const insertIndex = srcIndex < dstIndex ? dstIndex-1 : dstIndex;
      layers.splice(insertIndex,0,moved);
      rebuildActiveLayerSelect();
      rebuildLayerStack();
    });
    stack.appendChild(div);
  });
}
function syncActiveLayerFields(){
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  $('#layerParallax').value = layer.parallaxSpeed;
  $('#layerYOffset').value = layer.offsetY;
  $('#layerSep').value = layer.separation;
  $('#layerScale').value = layer.scale;
  rebuildLayerStack();
}
function setActiveLayer(id){
  if(!findLayer(id)) return;
  activeLayerId = id;
  $('#activeLayerSelect').value = id;
  syncActiveLayerFields();
  const first = instances.find(i=>i.layerId === activeLayerId);
  selectedInstId = first ? first.id : null;
  refreshInstanceList();
}
['layerParallax','layerYOffset','layerSep','layerScale'].forEach(id=>{
  $(`#${id}`).addEventListener('input', e=>{
    const layer = findLayer(activeLayerId);
    if(!layer) return;
    const v = parseFloat(e.target.value);
    if(!Number.isFinite(v)) return;
    pushHistory();
    if(id==='layerParallax') layer.parallaxSpeed=v;
    if(id==='layerYOffset') layer.offsetY=v;
    if(id==='layerSep')      layer.separation=v;
    if(id==='layerScale')    layer.scale=v;
  });
});

/*** Duplicate layer ***/
$('#btnDuplicateLayer').addEventListener('click',()=>{
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  pushHistory();
  let baseId = layer.id + '_copy';
  let n = 1;
  while(findLayer(baseId)) baseId = layer.id + '_copy' + (n++);
  const newLayer = JSON.parse(JSON.stringify(layer));
  newLayer.id = baseId;
  newLayer.name = layer.name + ' copy';
  const idx = layers.indexOf(layer);
  layers.splice(idx+1,0,newLayer);
  const clones = instances
    .filter(inst=>inst.layerId===layer.id)
    .map(inst=>{
      const c = JSON.parse(JSON.stringify(inst));
      c.id = nextInstId++;
      c.layerId = newLayer.id;
      return c;
    });
  instances.push(...clones);
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  activeLayerId = newLayer.id;
  syncActiveLayerFields();
  refreshInstanceList();
});

/*** Image loading ***/
function loadImage(url){
  return new Promise(res=>{
    if(!url) return res(null);
    if(imageCache.has(url)) return res(imageCache.get(url));
    const img=new Image();
    img.crossOrigin='anonymous';
    img.onload=()=>{ imageCache.set(url,img); res(img); };
    img.onerror=()=>res(null);
    img.src=url;
  });
}

/*** Prefabs ***/
async function registerPrefab(obj, options = {}){
  const {
    select = true,
    autoPopulate = true,
    silent = false,
    deferRefresh = false,
    prefabId: explicitPrefabId = null,
  } = options;
  const prefab = obj && typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : null;
  if(!prefab || !prefab.structureId || !Array.isArray(prefab.parts)){
    const message = 'Invalid structure JSON';
    if(!silent) alert(message);
    throw new Error(message);
  }

  const candidateIds = [
    explicitPrefabId,
    prefab.id,
    prefab.prefabId,
    prefab.slug,
    prefab.structureId,
  ];
  const resolvedId = candidateIds
    .map((value) => (typeof value === 'string' ? value.trim() : ''))
    .find((value) => !!value);
  if(!resolvedId){
    const message = 'Prefab missing identifier';
    if(!silent) alert(message);
    throw new Error(message);
  }

  prefab.id = resolvedId;
  prefabs[resolvedId]=prefab;
  if(select && !selectedPrefabId) selectedPrefabId=resolvedId;

  for(const part of prefab.parts){
    const t=part.propTemplate||{};
    if(t.url) await loadImage(t.url);
  }

  if(!deferRefresh){
    rebuildPrefabSelect();
  }

  if(autoPopulate && !instances.length && activeLayerId){
    pushHistory();
    addRowOnLayer(activeLayerId,8,resolvedId);
    refreshInstanceList();
  }

  return resolvedId;
}

async function ensureConfiguredPrefabsLoaded(){
  if(prefabBootstrapPromise) return prefabBootstrapPromise;
  prefabBootstrapPromise = (async () => {
    if(!PREFAB_MANIFESTS.length) return { loaded: 0, registered: 0, errors: [] };
    try{
      const module = await import('./js/prefab-catalog.js');
      const loader = module.loadPrefabsFromManifests;
      if(typeof loader !== 'function'){
        throw new Error('Prefab catalog loader unavailable');
      }
      const { prefabs: prefabMap, errors } = await loader(PREFAB_MANIFESTS);
      let registered = 0;
      for(const [id, prefab] of prefabMap.entries()){
        const already = !!prefabs[id];
        await registerPrefab(prefab, {
          prefabId: id,
          select: !selectedPrefabId && !already,
          autoPopulate: false,
          silent: true,
          deferRefresh: true,
        });
        if(!already) registered++;
      }
      rebuildPrefabSelect();
      if(errors?.length){
        const summarize = typeof module.summarizeLoadErrors === 'function'
          ? module.summarizeLoadErrors(errors)
          : null;
        if(summarize){
          console.warn('[map-editor] Some prefabs failed to load\n' + summarize);
        }
      }
      return { loaded: prefabMap.size, registered, errors: errors || [] };
    }catch(error){
      console.error('[map-editor] Failed to load configured prefabs', error);
      return { loaded: 0, registered: 0, errors: [{ type: 'bootstrap', error }] };
    }
  })();
  return prefabBootstrapPromise;
}
let cachedAssetManifest = null;
async function loadAssetManifest(){
  if (cachedAssetManifest) return cachedAssetManifest;
  try {
    const response = await fetch('./assets/asset-manifest.json', { cache: 'no-cache' });
    cachedAssetManifest = await response.json();
    return cachedAssetManifest;
  } catch (error) {
    console.warn('[map-editor] Failed to load asset manifest', error);
    cachedAssetManifest = [];
    return cachedAssetManifest;
  }
}
async function importDrumSkinImagesFromAssetManifest(){
  const manifest = await loadAssetManifest();
  if (!Array.isArray(manifest)) return manifest;

  const drumSkinUrls = Array.isArray(manifest)
    ? manifest.filter((entry) => typeof entry === 'string' && entry.startsWith('./assets/prefabs/images/'))
    : [];
  if (!drumSkinUrls.length) return;

  let registered = 0;
  for (const url of drumSkinUrls) {
    const baseName = url.split('/').pop() || '';
    const stem = baseName.replace(/\.[^/.]+$/, '') || 'drum_skin';
    let prefabId = stem;
    let suffix = 1;
    while (prefabs[prefabId]) {
      prefabId = `${stem}_${suffix++}`;
    }

    const img = await loadImage(url);
    if (!img) {
      console.warn('[map-editor] Skipping drum skin import; failed to load image', url);
      continue;
    }

    const prefab = {
      id: prefabId,
      structureId: prefabId,
      isImage: true,
      tags: ['drum-skin', 'drum', 'image'],
      parts: [{
        name: prefabId,
        layer: 'near',
        relX: 0,
        relY: 0,
        propTemplate: {
          id: prefabId,
          w: img.width || 1,
          h: img.height || 1,
          url,
          pivot: 'bottom',
          anchorXPct: 50,
          anchorYPct: 100,
          parallaxX: 1,
          parallaxClampPx: 0,
        },
      }],
      meta: {
        catalog: {
          id: prefabId,
          sourceUrl: url,
        },
        drumSkin: {
          imageURL: url,
        },
      },
    };

    try {
      await registerPrefab(prefab, {
        select: false,
        autoPopulate: false,
        silent: true,
        deferRefresh: true,
        prefabId,
      });
      registered++;
    } catch (error) {
      console.warn('[map-editor] Failed to register drum skin prefab from manifest', { url, error });
    }
  }

  if (registered) {
    rebuildPrefabSelect();
    refreshLibrarySelect();
    refreshDrumSkinList();
  }
}

function populateBackgroundTileChoices(manifest){
  const list = document.getElementById('bgTileUrlOptions');
  if (!list) return;
  list.innerHTML = '';
  const urls = Array.isArray(manifest)
    ? manifest.filter((entry) => typeof entry === 'string' && entry.startsWith('./assets/prefabs/images/'))
    : [];
  urls.forEach((url) => {
    const option = document.createElement('option');
    option.value = url;
    option.label = url.split('/').pop() || url;
    list.appendChild(option);
  });
}
function registerImagePrefab(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.onload=()=>{
    const base=(file.name||'img').replace(/\.[^/.]+$/,'')||'img';
    let id=`img_${base}`, c=1;
    while(prefabs[id]) id=`img_${base}_${c++}`;
    prefabs[id]={
      id,
      structureId:id,
      isImage:true,
      parts:[{
        name:id,
        layer:'near',
        relX:0,
        relY:0,
        propTemplate:{
          id,
          w:img.width,
          h:img.height,
          url:url,
          pivot:'bottom',
          anchorXPct:50,
          anchorYPct:100
        }
      }]
    };
    imageCache.set(url,img);
    selectedPrefabId=id;
    rebuildPrefabSelect();
    refreshLibrarySelect();
  };
  img.onerror=()=>alert('Failed to load image');
  img.src=url;
}
function rebuildPrefabSelect(){
  const instSel=$('#instPrefab');
  instSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    instSel.appendChild(o);
  });
  if(selectedPrefabId) instSel.value=selectedPrefabId;
  refreshLibrarySelect();
}
function refreshLibrarySelect(){
  const libSel=$('#libPrefab');
  libSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    libSel.appendChild(o);
  });
  if(selectedPrefabId) libSel.value=selectedPrefabId;
}

/*** Instances ***/
function allocSlot(layerId){
  const n=nextSlotByLayer[layerId] ?? 0;
  nextSlotByLayer[layerId]=n+1;
  return n;
}
function makeInstance(layerId,prefabId){
  const grid = GRID_UNIT || 0;
  const existing = instances.filter((inst) => inst.layerId === layerId);
  const baseX = existing.length ? Math.max(...existing.map((inst) => inst.position?.x ?? 0)) + (grid || 100) : 0;
  return {
    id:nextInstId++,
    prefabId,
    layerId,
    position:{ x: Number.isFinite(baseX) ? baseX : 0, y: 0 },
    scale:{ x:1, y:1 },
    rotationDeg:0,
    locked:false,
    tags:[],
    meta:{},
  };
}
function addInstance(layerId,prefabId){
  const layer=findLayer(layerId);
  if(!layer) return;
  const pid=prefabId || selectedPrefabId || Object.keys(prefabs)[0];
  if(!prefabs[pid]) return;
  const inst=makeInstance(layerId,pid);
  instances.push(inst);
  if(layerId===activeLayerId) selectedInstId=inst.id;
}
function addRowOnLayer(layerId,count,prefabId){
  for(let i=0;i<count;i++) addInstance(layerId,prefabId);
}
function getSelectedInstance(){
  return instances.find(i=>i.id===selectedInstId) || null;
}
function deleteSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be removed. Use the placement button to reposition it.');
    return;
  }
  pushHistory();
  const idx=instances.findIndex(i=>i.id===inst.id);
  if(idx>=0) instances.splice(idx,1);
  selectedInstId=null;
  refreshInstanceList();
}
function duplicateSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be duplicated.');
    return;
  }
  pushHistory();
  const dup = JSON.parse(JSON.stringify(inst));
  dup.id = nextInstId++;
  dup.position = normalizePosition(dup.position);
  const grid = GRID_UNIT || 0;
  dup.position.x += grid > 0 ? grid : 50;
  instances.push(dup);
  selectedInstId = dup.id;
  refreshInstanceList();
}
function refreshInstanceList(){
  const list=$('#instList');
  list.innerHTML='';
  const visible=instances.filter(i=>i.layerId===activeLayerId);
  for(const inst of visible){
    const layer=findLayer(inst.layerId);
    if(!layer) continue;
    const div=document.createElement('div');
    div.className='inst'+(inst.id===selectedInstId?' active':'');
    const span=document.createElement('span');
    const pos = normalizePosition(inst.position);
    span.textContent=`${inst.id} · ${inst.prefabId} · x=${pos.x.toFixed(1)}`;
    if(inst.locked){
      const lp=document.createElement('span');
      lp.className='lock-pill';
      lp.textContent='🔒';
      span.appendChild(lp);
    }
    if(isPlayerSpawn(inst)){
      const spawnPill=document.createElement('span');
      spawnPill.className='pill pill--spawn';
      spawnPill.textContent='Player Spawn';
      span.appendChild(spawnPill);
    }
    const pill=document.createElement('span');
    pill.className='pill';
    pill.textContent=layer.name;
    div.appendChild(span);
    div.appendChild(pill);
    div.onclick=()=>{ selectedInstId=inst.id; fillInstEditor(); refreshInstanceList(); };
    list.appendChild(div);
  }
  fillInstEditor();
  syncSpawnHeightField();
}
function fillInstEditor(){
  const inst=getSelectedInstance();
  if(!inst || inst.layerId!==activeLayerId){
    $('#instId').value='';
    $('#instX').value='';
    $('#instLayer').value=activeLayerId||'';
    $('#instLocked').checked=false;
    $('#instScaleX').value='';
    $('#instScaleY').value='';
    $('#instOffY').value='';
    $('#instRot').value='';
    $('#instStretchEnabled').checked = false;
    $('#instStretchLayer').value = '';
    $('#instStretchHeight').value = '';
    $('#instStretchTopOffset').value = '';
    $('#instStretchSlices').value = 24;
    return;
  }
  $('#instId').value=inst.id;
  $('#instPrefab').value=inst.prefabId;
  $('#instLayer').value=inst.layerId;
  const pos = normalizePosition(inst.position);
  $('#instX').value=pos.x.toFixed(1);
  $('#instLocked').checked=!!inst.locked;
  const scale = normalizeScale(inst.scale);
  $('#instScaleX').value=scale.x;
  $('#instScaleY').value=scale.y;
  $('#instOffY').value=pos.y;
  $('#instRot').value=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;
  const stretch = getStretchQuadMeta(inst).spec;
  $('#instStretchEnabled').checked = !!stretch;
  $('#instStretchLayer').value = stretch?.targetLayerId || '';
  $('#instStretchHeight').value = stretch?.height ?? '';
  $('#instStretchTopOffset').value = stretch?.topOffset ?? '';
  $('#instStretchSlices').value = stretch?.slices ?? 24;
}

/**** Behavior overlay ****/
function setEditorMode(mode){
  editorMode = mode === 'behavior' ? 'behavior' : 'layout';
  const layoutBtn = $('#btnModeLayout');
  const behaviorBtn = $('#btnModeBehavior');
  const controlPane = $('#controlPane');
  const behaviorPane = $('#behaviorPane');
  if (layoutBtn){
    layoutBtn.classList.toggle('active', editorMode === 'layout');
    layoutBtn.setAttribute('aria-pressed', editorMode === 'layout');
  }
  if (behaviorBtn){
    behaviorBtn.classList.toggle('active', editorMode === 'behavior');
    behaviorBtn.setAttribute('aria-pressed', editorMode === 'behavior');
  }
  if (controlPane) controlPane.classList.toggle('hidden', editorMode === 'behavior');
  if (behaviorPane) behaviorPane.classList.toggle('hidden', editorMode !== 'behavior');
  if (editorMode !== 'behavior') exitBehaviorPlacement();
  ensureRenderLoop();
}

function startBehaviorPlacement(kind){
  const canvasEl = document.getElementById('sceneCanvas');
  const targetId = kind === 'pathTarget' ? selectedPathTargetId : selectedBehaviorSpawnerId;
  if (!targetId || editorMode !== 'behavior') return;
  behaviorPlacement = { kind, id: targetId };
  canvasEl?.classList.add('behavior-place');
}

function exitBehaviorPlacement(){
  const canvasEl = document.getElementById('sceneCanvas');
  behaviorPlacement = null;
  canvasEl?.classList.remove('behavior-place');
}

function refreshBehaviorSpawnerList(){
  const list = $('#behaviorSpawnerList');
  if (!list) return;
  list.innerHTML = '';
  for (const spawner of behaviorSpawners){
    const div = document.createElement('div');
    const isActive = spawner.spawnerId === selectedBehaviorSpawnerId;
    div.className = 'item' + (isActive ? ' active' : '');
    const span = document.createElement('span');
    const pos = normalizePosition(spawner.position);
    span.textContent = `${spawner.spawnerId || 'spawner'} · x=${pos.x.toFixed(1)} y=${pos.y.toFixed(1)}`;
    const pill = document.createElement('span');
    pill.className = 'behavior-pill';
    pill.textContent = spawner.layerId || getDefaultSpawnLayerId();
    div.appendChild(span);
    div.appendChild(pill);
    const del = document.createElement('button');
    del.textContent = '✕';
    del.style.minWidth = '32px';
    del.onclick = (ev) => { ev.stopPropagation(); deleteBehaviorSpawner(spawner.spawnerId); };
    div.appendChild(del);
    div.onclick = () => { selectedBehaviorSpawnerId = spawner.spawnerId; syncBehaviorSpawnerFields(); refreshBehaviorSpawnerList(); };
    list.appendChild(div);
  }
  syncBehaviorSpawnerFields();
}

function syncBehaviorSpawnerFields(){
  const spawner = behaviorSpawners.find((s) => s.spawnerId === selectedBehaviorSpawnerId) || null;
  $('#behaviorSpawnerId').value = spawner?.spawnerId || '';
  $('#behaviorSpawnerLayer').value = spawner?.layerId || getDefaultSpawnLayerId();
  $('#behaviorSpawnerX').value = spawner ? toNumber(spawner.position?.x, 0) : '';
  $('#behaviorSpawnerY').value = spawner ? toNumber(spawner.position?.y, 0) : '';
  $('#behaviorSpawnerRadius').value = spawner ? toNumber(spawner.spawnRadius, 0) : '';
  $('#behaviorSpawnerCount').value = spawner ? toNumber(spawner.count, 1) : '';
  $('#behaviorSpawnerTemplate').value = spawner?.templateId || '';
  $('#behaviorSpawnerCharacter').value = spawner?.characterId || '';
  $('#behaviorSpawnerRespawn').checked = !!spawner?.respawn;
}

function updateBehaviorSpawnerFromFields(){
  const spawner = behaviorSpawners.find((s) => s.spawnerId === selectedBehaviorSpawnerId) || null;
  if (!spawner) return;
  const nextId = ($('#behaviorSpawnerId').value || spawner.spawnerId || '').trim() || spawner.spawnerId;
  if (!isRestoring) pushHistory();
  spawner.spawnerId = nextId;
  spawner.id = nextId;
  selectedBehaviorSpawnerId = nextId;
  spawner.layerId = $('#behaviorSpawnerLayer').value || spawner.layerId;
  spawner.position = normalizePosition({
    x: toNumber($('#behaviorSpawnerX').value, spawner.position?.x),
    y: toNumber($('#behaviorSpawnerY').value, spawner.position?.y),
  });
  spawner.spawnRadius = Math.max(0, toNumber($('#behaviorSpawnerRadius').value, spawner.spawnRadius) || 0);
  spawner.count = Math.max(1, toNumber($('#behaviorSpawnerCount').value, spawner.count) || 1);
  spawner.templateId = ($('#behaviorSpawnerTemplate').value || '').trim();
  spawner.characterId = ($('#behaviorSpawnerCharacter').value || '').trim();
  spawner.respawn = $('#behaviorSpawnerRespawn').checked;
  refreshBehaviorSpawnerList();
  ensureRenderLoop();
}

function addBehaviorSpawner(){
  pushHistory();
  const next = normalizeBehaviorSpawner({
    spawnerId: `spawner_${behaviorSpawners.length + 1}`,
    layerId: activeLayerId,
    position: { x: 0, y: 0 },
    count: 1,
    spawnRadius: 0,
    respawn: false,
  }, behaviorSpawners.length + 1);
  behaviorSpawners.push(next);
  selectedBehaviorSpawnerId = next.spawnerId;
  refreshBehaviorSpawnerList();
  ensureRenderLoop();
}

function deleteBehaviorSpawner(spawnerId){
  const idx = behaviorSpawners.findIndex((s) => s.spawnerId === spawnerId);
  if (idx < 0) return;
  pushHistory();
  behaviorSpawners.splice(idx, 1);
  if (selectedBehaviorSpawnerId === spawnerId){
    selectedBehaviorSpawnerId = behaviorSpawners[0]?.spawnerId ?? null;
  }
  refreshBehaviorSpawnerList();
  ensureRenderLoop();
}

function refreshPathTargetList(){
  const list = $('#behaviorPathTargetList');
  if (!list) return;
  list.innerHTML = '';
  for (const target of behaviorPathTargets){
    const div = document.createElement('div');
    const isActive = target.targetId === selectedPathTargetId;
    div.className = 'item' + (isActive ? ' active' : '');
    const span = document.createElement('span');
    const pos = normalizePosition(target.position);
    span.textContent = `${target.name || target.targetId} · x=${pos.x.toFixed(1)} y=${pos.y.toFixed(1)}`;
    const pill = document.createElement('span');
    pill.className = 'behavior-pill';
    pill.textContent = target.layerId || getDefaultSpawnLayerId();
    div.appendChild(span);
    div.appendChild(pill);
    const del = document.createElement('button');
    del.textContent = '✕';
    del.style.minWidth = '32px';
    del.onclick = (ev) => { ev.stopPropagation(); deletePathTarget(target.targetId); };
    div.appendChild(del);
    div.onclick = () => { selectedPathTargetId = target.targetId; syncPathTargetFields(); refreshPathTargetList(); };
    list.appendChild(div);
  }
  syncPathTargetFields();
}

function syncPathTargetFields(){
  const target = behaviorPathTargets.find((t) => t.targetId === selectedPathTargetId) || null;
  $('#behaviorPathName').value = target?.name || '';
  $('#behaviorPathOrder').value = target && Number.isFinite(target.order) ? target.order : '';
  $('#behaviorPathLayer').value = target?.layerId || getDefaultSpawnLayerId();
  $('#behaviorPathInstanceId').value = target?.instanceId || '';
  $('#behaviorPathX').value = target ? toNumber(target.position?.x, 0) : '';
  $('#behaviorPathY').value = target ? toNumber(target.position?.y, 0) : '';
}

function updatePathTargetFromFields(){
  const target = behaviorPathTargets.find((t) => t.targetId === selectedPathTargetId) || null;
  if (!target) return;
  if (!isRestoring) pushHistory();
  const nextId = ($('#behaviorPathName').value || target.targetId).trim() || target.targetId;
  target.name = ($('#behaviorPathName').value || target.name || nextId).trim();
  target.targetId = nextId;
  target.id = nextId;
  selectedPathTargetId = nextId;
  target.order = Number.isFinite(Number($('#behaviorPathOrder').value))
    ? Number($('#behaviorPathOrder').value)
    : null;
  target.layerId = $('#behaviorPathLayer').value || target.layerId;
  target.instanceId = ($('#behaviorPathInstanceId').value || '').trim();
  target.position = normalizePosition({
    x: toNumber($('#behaviorPathX').value, target.position?.x),
    y: toNumber($('#behaviorPathY').value, target.position?.y),
  });
  refreshPathTargetList();
  ensureRenderLoop();
}

function addPathTarget(){
  pushHistory();
  const next = normalizeEditorPathTarget({
    targetId: `target_${behaviorPathTargets.length + 1}`,
    name: `target_${behaviorPathTargets.length + 1}`,
    layerId: getDefaultSpawnLayerId(),
    position: { x: 0, y: 0 },
  }, behaviorPathTargets.length + 1);
  behaviorPathTargets.push(next);
  selectedPathTargetId = next.targetId;
  refreshPathTargetList();
  ensureRenderLoop();
}

function deletePathTarget(targetId){
  const idx = behaviorPathTargets.findIndex((t) => t.targetId === targetId);
  if (idx < 0) return;
  pushHistory();
  behaviorPathTargets.splice(idx, 1);
  if (selectedPathTargetId === targetId){
    selectedPathTargetId = behaviorPathTargets[0]?.targetId ?? null;
  }
  refreshPathTargetList();
  ensureRenderLoop();
}

function refreshInteractionList(){
  const list = $('#behaviorInteractionList');
  if (!list) return;
  list.innerHTML = '';
  for (const point of behaviorInteractionPoints){
    const div = document.createElement('div');
    const isActive = point.interactionId === selectedInteractionId;
    div.className = 'item' + (isActive ? ' active' : '');
    const span = document.createElement('span');
    const pos = normalizePosition(point.position);
    span.textContent = `${point.interactionId || 'interaction'} · x=${pos.x.toFixed(1)} y=${pos.y.toFixed(1)}`;
    const pill = document.createElement('span');
    pill.className = 'behavior-pill';
    pill.textContent = point.layerId || getDefaultSpawnLayerId();
    div.appendChild(span);
    div.appendChild(pill);
    const del = document.createElement('button');
    del.textContent = '✕';
    del.style.minWidth = '32px';
    del.onclick = (ev) => { ev.stopPropagation(); deleteInteractionPoint(point.interactionId); };
    div.appendChild(del);
    div.onclick = () => { selectedInteractionId = point.interactionId; syncInteractionFields(); refreshInteractionList(); };
    list.appendChild(div);
  }
  syncInteractionFields();
}

function syncInteractionFields(){
  const point = behaviorInteractionPoints.find((p) => p.interactionId === selectedInteractionId) || null;
  $('#behaviorInteractionId').value = point?.interactionId || '';
  $('#behaviorInteractionLayer').value = point?.layerId || getDefaultSpawnLayerId();
  $('#behaviorInteractionX').value = point ? toNumber(point.position?.x, 0) : '';
  $('#behaviorInteractionY').value = point ? toNumber(point.position?.y, 0) : '';
  $('#behaviorInteractionAction').value = point?.action || '';
  $('#behaviorInteractionTarget').value = point?.target || '';
  $('#behaviorInteractionPrompt').value = point?.prompt || '';
}

function updateInteractionFromFields(){
  const point = behaviorInteractionPoints.find((p) => p.interactionId === selectedInteractionId) || null;
  if (!point) return;
  if (!isRestoring) pushHistory();
  const nextId = ($('#behaviorInteractionId').value || point.interactionId).trim() || point.interactionId;
  point.interactionId = nextId;
  point.id = nextId;
  selectedInteractionId = nextId;
  point.layerId = $('#behaviorInteractionLayer').value || point.layerId;
  point.position = normalizePosition({
    x: toNumber($('#behaviorInteractionX').value, point.position?.x),
    y: toNumber($('#behaviorInteractionY').value, point.position?.y),
  });
  point.action = ($('#behaviorInteractionAction').value || '').trim();
  point.target = ($('#behaviorInteractionTarget').value || '').trim();
  point.prompt = ($('#behaviorInteractionPrompt').value || '').trim();
  refreshInteractionList();
}

function addInteractionPoint(){
  pushHistory();
  const next = normalizeInteractionPoint({
    interactionId: `interaction_${behaviorInteractionPoints.length + 1}`,
    layerId: getDefaultSpawnLayerId(),
    position: { x: 0, y: 0 },
  }, behaviorInteractionPoints.length + 1);
  behaviorInteractionPoints.push(next);
  selectedInteractionId = next.interactionId;
  refreshInteractionList();
}

function deleteInteractionPoint(interactionId){
  const idx = behaviorInteractionPoints.findIndex((p) => p.interactionId === interactionId);
  if (idx < 0) return;
  pushHistory();
  behaviorInteractionPoints.splice(idx, 1);
  if (selectedInteractionId === interactionId){
    selectedInteractionId = behaviorInteractionPoints[0]?.interactionId ?? null;
  }
  refreshInteractionList();
}

function refreshArrivalList(){
  const list = $('#behaviorArrivalList');
  if (!list) return;
  list.innerHTML = '';
  for (const spawn of behaviorArrivalSpawns){
    const div = document.createElement('div');
    const isActive = spawn.arrivalId === selectedArrivalId;
    div.className = 'item' + (isActive ? ' active' : '');
    const span = document.createElement('span');
    const pos = normalizePosition(spawn.position);
    span.textContent = `${spawn.arrivalId || 'arrival'} · x=${pos.x.toFixed(1)} y=${pos.y.toFixed(1)}`;
    const pill = document.createElement('span');
    pill.className = 'behavior-pill';
    pill.textContent = spawn.layerId || getDefaultSpawnLayerId();
    div.appendChild(span);
    div.appendChild(pill);
    const del = document.createElement('button');
    del.textContent = '✕';
    del.style.minWidth = '32px';
    del.onclick = (ev) => { ev.stopPropagation(); deleteArrivalSpawn(spawn.arrivalId); };
    div.appendChild(del);
    div.onclick = () => { selectedArrivalId = spawn.arrivalId; syncArrivalFields(); refreshArrivalList(); };
    list.appendChild(div);
  }
  syncArrivalFields();
}

function syncArrivalFields(){
  const spawn = behaviorArrivalSpawns.find((s) => s.arrivalId === selectedArrivalId) || null;
  $('#behaviorArrivalId').value = spawn?.arrivalId || '';
  $('#behaviorArrivalLayer').value = spawn?.layerId || getDefaultSpawnLayerId();
  $('#behaviorArrivalX').value = spawn ? toNumber(spawn.position?.x, 0) : '';
  $('#behaviorArrivalY').value = spawn ? toNumber(spawn.position?.y, 0) : '';
  $('#behaviorArrivalFrom').value = spawn?.fromAreaId || '';
}

function updateArrivalFromFields(){
  const spawn = behaviorArrivalSpawns.find((s) => s.arrivalId === selectedArrivalId) || null;
  if (!spawn) return;
  if (!isRestoring) pushHistory();
  const nextId = ($('#behaviorArrivalId').value || spawn.arrivalId).trim() || spawn.arrivalId;
  spawn.arrivalId = nextId;
  spawn.id = nextId;
  selectedArrivalId = nextId;
  spawn.layerId = $('#behaviorArrivalLayer').value || spawn.layerId;
  spawn.position = normalizePosition({
    x: toNumber($('#behaviorArrivalX').value, spawn.position?.x),
    y: toNumber($('#behaviorArrivalY').value, spawn.position?.y),
  });
  spawn.fromAreaId = ($('#behaviorArrivalFrom').value || '').trim();
  refreshArrivalList();
}

function addArrivalSpawn(){
  pushHistory();
  const next = normalizeArrivalSpawn({
    arrivalId: `arrival_${behaviorArrivalSpawns.length + 1}`,
    layerId: getDefaultSpawnLayerId(),
    position: { x: 0, y: 0 },
  }, behaviorArrivalSpawns.length + 1);
  behaviorArrivalSpawns.push(next);
  selectedArrivalId = next.arrivalId;
  refreshArrivalList();
}

function deleteArrivalSpawn(arrivalId){
  const idx = behaviorArrivalSpawns.findIndex((s) => s.arrivalId === arrivalId);
  if (idx < 0) return;
  pushHistory();
  behaviorArrivalSpawns.splice(idx, 1);
  if (selectedArrivalId === arrivalId){
    selectedArrivalId = behaviorArrivalSpawns[0]?.arrivalId ?? null;
  }
  refreshArrivalList();
}

function refreshBehaviorPanels(){
  refreshBehaviorSpawnerList();
  refreshPathTargetList();
  refreshPOIList();
  refreshInteractionList();
  refreshArrivalList();
}

function getSelectedCollider(){
  if (selectedColliderId == null) return null;
  return colliders.find((c) => c.id === selectedColliderId) || null;
}

function formatColliderNumber(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return '—';
  const fixed = Math.abs(num) >= 100 ? num.toFixed(0) : num.toFixed(1);
  return fixed.replace(/\.0$/, '');
}

function refreshColliderList(){
  const list = $('#colliderList');
  if (!list) return;
  list.innerHTML = '';
  for (const col of colliders){
    const div = document.createElement('div');
    div.className = 'collider' + (col.id === selectedColliderId ? ' active' : '');
    const label = typeof col.label === 'string' && col.label.trim()
      ? col.label.trim()
      : `Collider ${col.id}`;
    const title = document.createElement('span');
    title.textContent = `${col.id} · ${label}`;
    const left = toNumber(col.left, 0);
    const width = Math.max(0, toNumber(col.width, 0));
    const topOffset = toNumber(col.topOffset, 0);
    const height = Math.max(0, toNumber(col.height, 0));
    const meta = document.createElement('span');
    const materialType = typeof col.materialType === 'string' && col.materialType.trim() ? col.materialType.trim() : '';
    const stats = `x:${formatColliderNumber(left)} w:${formatColliderNumber(width)} y:${formatColliderNumber(topOffset)} h:${formatColliderNumber(height)}`;
    meta.textContent = materialType ? `${stats} · material:${materialType}` : stats;
    div.appendChild(title);
    div.appendChild(meta);
    div.onclick = () => {
      selectedColliderId = col.id;
      syncColliderFields();
      refreshColliderList();
    };
    list.appendChild(div);
  }
  syncColliderFields();
}

function syncColliderFields(){
  const collider = getSelectedCollider();
  const idField = $('#colliderId');
  if (idField) idField.value = collider?.id ?? '';
  const labelField = $('#colliderLabel');
  if (labelField) labelField.value = collider?.label ?? '';
  const leftField = $('#colliderLeft');
  if (leftField) leftField.value = collider ? String(toNumber(collider.left, 0)) : '';
  const widthField = $('#colliderWidth');
  if (widthField) widthField.value = collider ? String(Math.max(1, toNumber(collider.width, 0))) : '';
  const topField = $('#colliderTopOffset');
  if (topField) topField.value = collider ? String(toNumber(collider.topOffset, 0)) : '';
  const heightField = $('#colliderHeight');
  if (heightField) heightField.value = collider ? String(Math.max(1, toNumber(collider.height, 0))) : '';
  const materialField = $('#colliderMaterialType');
  if (materialField) materialField.value = collider && typeof collider.materialType === 'string' ? collider.materialType : '';
  const tagsField = $('#colliderTags');
  if (tagsField) {
    const tags = Array.isArray(collider?.tags) ? collider.tags.join(', ') : '';
    tagsField.value = tags;
  }
  const removeBtn = $('#btnDeleteCollider');
  if (removeBtn) removeBtn.disabled = !collider;
}

function resolveDrumSkinPrefabTexture(prefab) {
  if (!prefab || typeof prefab !== 'object') return '';
  const meta = typeof prefab.meta === 'object' && prefab.meta ? prefab.meta : {};
  const drumMeta = typeof meta.drumSkin === 'object' && meta.drumSkin ? meta.drumSkin : {};
  const candidates = [drumMeta.imageURL, drumMeta.url, prefab.imageURL, prefab.url];
  if (Array.isArray(prefab.parts)) {
    for (const part of prefab.parts) {
      if (part?.propTemplate?.url) {
        candidates.push(part.propTemplate.url);
        if (prefab.isImage) break;
      }
    }
  }
  return candidates.map((value) => (typeof value === 'string' ? value.trim() : '')).find(Boolean) || '';
}

function refreshDrumSkinList() {
  const list = $('#drumSkinList');
  if (!list) return;
  const drumSkinPrefabs = Object.entries(prefabs)
    .map(([id, prefab]) => ({ id, prefab }))
    .filter(({ prefab }) => {
      if (!prefab || typeof prefab !== 'object') return false;
      const tags = Array.isArray(prefab.tags) ? prefab.tags.map((tag) => String(tag).toLowerCase()) : [];
      const hasDrumTag = tags.includes('drum-skin') || tags.includes('drumskin') || tags.includes('drum');
      return prefab.isImage || hasDrumTag;
    })
    .sort((a, b) => a.id.localeCompare(b.id));
  const drumIds = new Set(drumSkins.map((drum) => drum.id));
  if (selectedDrumSkinId != null && !drumIds.has(selectedDrumSkinId)) {
    selectedDrumSkinId = null;
  }
  list.innerHTML = '';
  if (!drumSkins.length) {
    const empty = document.createElement('div');
    empty.style.color = 'var(--muted)';
    empty.textContent = 'No drum skins yet – add one to span between parallax layers.';
    list.appendChild(empty);
    return;
  }

  for (const drum of drumSkins) {
    const card = document.createElement('div');
    card.style.border = '1px solid var(--line)';
    card.style.borderRadius = '8px';
    card.style.padding = '6px';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = '4px';
    const isActive = drum.id === selectedDrumSkinId;
    card.style.outline = isActive ? '2px solid #22c55e' : '';
    card.style.outlineOffset = '1px';
    card.onclick = (event) => {
      const target = event.target;
      const withinControl = target instanceof HTMLElement && target.closest('button, input, select, option, textarea');
      if (withinControl) return;
      selectedDrumSkinId = drum.id;
      refreshDrumSkinList();
    };

    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.gap = '6px';
    const title = document.createElement('strong');
    title.textContent = `Drum ${drum.id}`;
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => {
      pushHistory();
      drumSkins = drumSkins.filter((item) => item.id !== drum.id);
      if (selectedDrumSkinId === drum.id) {
        selectedDrumSkinId = null;
      }
      refreshDrumSkinList();
    };
    header.appendChild(title);
    header.appendChild(removeBtn);
    card.appendChild(header);

    const row1 = document.createElement('div');
    row1.className = 'row';
    const topParallaxField = document.createElement('input');
    topParallaxField.type = 'number';
    topParallaxField.step = '0.05';
    topParallaxField.value = drum.topParallax ?? 1;
    topParallaxField.onchange = () => {
      const val = toNumber(topParallaxField.value, drum.topParallax) || 1;
      if (val === drum.topParallax) return;
      pushHistory();
      drum.topParallax = val;
      refreshDrumSkinList();
    };
    const bottomParallaxField = document.createElement('input');
    bottomParallaxField.type = 'number';
    bottomParallaxField.step = '0.05';
    bottomParallaxField.value = drum.bottomParallax ?? drum.topParallax ?? 1;
    bottomParallaxField.onchange = () => {
      const val = toNumber(bottomParallaxField.value, drum.bottomParallax) || drum.topParallax || 1;
      if (val === drum.bottomParallax) return;
      pushHistory();
      drum.bottomParallax = val;
      refreshDrumSkinList();
    };
    const topParallaxLabel = document.createElement('label');
    topParallaxLabel.style.flex = '1';
    topParallaxLabel.innerHTML = '<span>Top parallax</span>';
    topParallaxLabel.appendChild(topParallaxField);
    const bottomParallaxLabel = document.createElement('label');
    bottomParallaxLabel.style.flex = '1';
    bottomParallaxLabel.innerHTML = '<span>Bottom parallax</span>';
    bottomParallaxLabel.appendChild(bottomParallaxField);
    row1.appendChild(topParallaxLabel);
    row1.appendChild(bottomParallaxLabel);
    card.appendChild(row1);

    const row2 = document.createElement('div');
    row2.className = 'row';
    const topScaleField = document.createElement('input');
    topScaleField.type = 'number';
    topScaleField.step = '0.05';
    topScaleField.value = drum.topScale ?? 1;
    topScaleField.onchange = () => {
      const val = toNumber(topScaleField.value, drum.topScale) || 1;
      if (val === drum.topScale) return;
      pushHistory();
      drum.topScale = val;
      refreshDrumSkinList();
    };
    const bottomScaleField = document.createElement('input');
    bottomScaleField.type = 'number';
    bottomScaleField.step = '0.05';
    bottomScaleField.value = drum.bottomScale ?? drum.topScale ?? 1;
    bottomScaleField.onchange = () => {
      const val = toNumber(bottomScaleField.value, drum.bottomScale) || drum.topScale || 1;
      if (val === drum.bottomScale) return;
      pushHistory();
      drum.bottomScale = val;
      refreshDrumSkinList();
    };
    const topScaleLabel = document.createElement('label');
    topScaleLabel.style.flex = '1';
    topScaleLabel.innerHTML = '<span>Top scale</span>';
    topScaleLabel.appendChild(topScaleField);
    const bottomScaleLabel = document.createElement('label');
    bottomScaleLabel.style.flex = '1';
    bottomScaleLabel.innerHTML = '<span>Bottom scale</span>';
    bottomScaleLabel.appendChild(bottomScaleField);
    row2.appendChild(topScaleLabel);
    row2.appendChild(bottomScaleLabel);
    card.appendChild(row2);

    const row3 = document.createElement('div');
    row3.className = 'row';
    const topOffsetField = document.createElement('input');
    topOffsetField.type = 'number';
    topOffsetField.step = '1';
    topOffsetField.value = drum.topYOffset ?? 0;
    topOffsetField.onchange = () => {
      const val = toNumber(topOffsetField.value, drum.topYOffset) || 0;
      if (val === drum.topYOffset) return;
      pushHistory();
      drum.topYOffset = val;
      refreshDrumSkinList();
    };
    const bottomOffsetField = document.createElement('input');
    bottomOffsetField.type = 'number';
    bottomOffsetField.step = '1';
    bottomOffsetField.value = drum.bottomYOffset ?? 0;
    bottomOffsetField.onchange = () => {
      const val = toNumber(bottomOffsetField.value, drum.bottomYOffset) || 0;
      if (val === drum.bottomYOffset) return;
      pushHistory();
      drum.bottomYOffset = val;
      refreshDrumSkinList();
    };
    const topOffsetLabel = document.createElement('label');
    topOffsetLabel.style.flex = '1';
    topOffsetLabel.innerHTML = '<span>Top Y offset</span>';
    topOffsetLabel.appendChild(topOffsetField);
    const bottomOffsetLabel = document.createElement('label');
    bottomOffsetLabel.style.flex = '1';
    bottomOffsetLabel.innerHTML = '<span>Bottom Y offset</span>';
    bottomOffsetLabel.appendChild(bottomOffsetField);
    row3.appendChild(topOffsetLabel);
    row3.appendChild(bottomOffsetLabel);
    card.appendChild(row3);
    const row4 = document.createElement('div');
    row4.className = 'row';
    const prefabField = document.createElement('select');
    const blankOpt = document.createElement('option');
    blankOpt.value = '';
    blankOpt.textContent = 'Custom URL';
    prefabField.appendChild(blankOpt);
    for (const { id } of drumSkinPrefabs) {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = id;
      prefabField.appendChild(opt);
    }
    const selectedPrefabId = drum.prefabId || drum.textureId || '';
    prefabField.value = selectedPrefabId;
    prefabField.onchange = () => {
      pushHistory();
      drum.prefabId = prefabField.value;
      drum.textureId = prefabField.value;
      if (!drum.imageURL && drum.prefabId) {
        const chosen = prefabs[drum.prefabId];
        const resolved = resolveDrumSkinPrefabTexture(chosen);
        if (resolved) {
          drum.imageURL = resolved;
        }
      }
      refreshDrumSkinList();
    };

    const urlField = document.createElement('input');
    urlField.type = 'text';
    urlField.value = drum.imageURL || '';
    urlField.placeholder = 'Image URL (tiled)';
    urlField.onchange = () => {
      pushHistory();
      drum.imageURL = urlField.value.trim();
      refreshDrumSkinList();
    };
    const scaleField = document.createElement('input');
    scaleField.type = 'number';
    scaleField.step = '0.05';
    scaleField.min = '0.05';
    scaleField.value = drum.tileScale ?? 1;
    scaleField.onchange = () => {
      const val = toNumber(scaleField.value, drum.tileScale) || 1;
      if (val === drum.tileScale) return;
      pushHistory();
      drum.tileScale = val;
      refreshDrumSkinList();
    };
    const prefabLabel = document.createElement('label');
    prefabLabel.style.flex = '0.9';
    prefabLabel.innerHTML = '<span>Prefab</span>';
    prefabLabel.appendChild(prefabField);
    const urlLabel = document.createElement('label');
    urlLabel.style.flex = '1';
    urlLabel.innerHTML = '<span>Image URL</span>';
    urlLabel.appendChild(urlField);
    const scaleLabel = document.createElement('label');
    scaleLabel.style.flex = '0.8';
    scaleLabel.innerHTML = '<span>Tile scale</span>';
    scaleLabel.appendChild(scaleField);
    row4.appendChild(prefabLabel);
    row4.appendChild(urlLabel);
    row4.appendChild(scaleLabel);
    card.appendChild(row4);

    const missingTexture = !prefabField.value && !urlField.value;
    if (missingTexture) {
      const warning = document.createElement('div');
      warning.textContent = 'Select a drum skin prefab or provide an image URL.';
      warning.style.color = '#eab308';
      warning.style.fontSize = '10px';
      warning.style.marginTop = '2px';
      card.appendChild(warning);
    }
    prefabField.style.borderColor = missingTexture ? '#eab308' : 'var(--line)';
    urlField.style.borderColor = missingTexture ? '#eab308' : 'var(--line)';

    const row5 = document.createElement('div');
    row5.style.display = 'flex';
    row5.style.alignItems = 'center';
    row5.style.gap = '8px';
    const visibleField = document.createElement('input');
    visibleField.type = 'checkbox';
    visibleField.checked = drum.visible !== false;
    visibleField.onchange = () => {
      pushHistory();
      drum.visible = visibleField.checked;
    };
    const visibleLabel = document.createElement('label');
    visibleLabel.style.display = 'flex';
    visibleLabel.style.alignItems = 'center';
    visibleLabel.style.gap = '6px';
    visibleLabel.appendChild(visibleField);
    const text = document.createElement('span');
    text.textContent = 'Visible';
    text.style.color = 'var(--muted)';
    visibleLabel.appendChild(text);
    row5.appendChild(visibleLabel);
    card.appendChild(row5);

    list.appendChild(card);
  }
}

function addDrumSkin() {
  const parallaxLayers = layers.filter((layer) => layer.type === 'parallax');
  const layerA = parallaxLayers[0];
  const layerB = parallaxLayers[1] || layerA;
  const defaultTopParallax = toNumber(layerA?.parallaxSpeed, 1) || 1;
  const defaultBottomParallax = toNumber(layerB?.parallaxSpeed ?? defaultTopParallax, defaultTopParallax) || defaultTopParallax;
  const defaultTopScale = toNumber(layerA?.scale, 1) || 1;
  const defaultBottomScale = toNumber(layerB?.scale ?? defaultTopScale, defaultTopScale) || defaultTopScale;
  const defaultTopYOffset = toNumber(layerA?.offsetY, 0) || 0;
  const defaultBottomYOffset = toNumber(layerB?.offsetY ?? defaultTopYOffset, defaultTopYOffset) || defaultTopYOffset;
  const drumSkinPrefabs = Object.entries(prefabs)
    .map(([id, prefab]) => ({ id, prefab }))
    .filter(({ prefab }) => {
      if (!prefab || typeof prefab !== 'object') return false;
      const tags = Array.isArray(prefab.tags) ? prefab.tags.map((tag) => String(tag).toLowerCase()) : [];
      const hasDrumTag = tags.includes('drum-skin') || tags.includes('drumskin') || tags.includes('drum');
      return prefab.isImage || hasDrumTag;
    })
    .sort((a, b) => a.id.localeCompare(b.id));
  const defaultPrefabId = drumSkinPrefabs[0]?.id || '';
  const defaultPrefabUrl = defaultPrefabId ? resolveDrumSkinPrefabTexture(prefabs[defaultPrefabId]) : '';
  pushHistory();
  drumSkins.push({
    id: nextDrumSkinId++,
    topParallax: defaultTopParallax,
    bottomParallax: defaultBottomParallax,
    topScale: defaultTopScale,
    bottomScale: defaultBottomScale,
    topYOffset: defaultTopYOffset,
    bottomYOffset: defaultBottomYOffset,
    prefabId: defaultPrefabId,
    textureId: defaultPrefabId,
    imageURL: defaultPrefabUrl,
    tileScale: 1,
    visible: true,
  });
  selectedDrumSkinId = drumSkins[drumSkins.length - 1]?.id ?? null;
  refreshDrumSkinList();
}

function updateSelectedColliderFromFields(){
  const collider = getSelectedCollider();
  if (!collider) return;
  let changed = false;

  const labelField = $('#colliderLabel');
  if (labelField){
    const newLabel = labelField.value.trim();
    if (newLabel !== (collider.label ?? '')){
      if (!changed) pushHistory();
      changed = true;
      collider.label = newLabel;
    }
  }

  const leftField = $('#colliderLeft');
  if (leftField){
    const value = parseFloat(leftField.value);
    if (Number.isFinite(value) && value !== collider.left){
      if (!changed) pushHistory();
      changed = true;
      collider.left = value;
    }
  }

  const widthField = $('#colliderWidth');
  if (widthField){
    const value = parseFloat(widthField.value);
    if (Number.isFinite(value) && value > 0 && value !== collider.width){
      if (!changed) pushHistory();
      changed = true;
      collider.width = Math.max(1, value);
    }
  }

  const topField = $('#colliderTopOffset');
  if (topField){
    const value = parseFloat(topField.value);
    if (Number.isFinite(value) && value !== collider.topOffset){
      if (!changed) pushHistory();
      changed = true;
      collider.topOffset = value;
    }
  }

  const heightField = $('#colliderHeight');
  if (heightField){
    const value = parseFloat(heightField.value);
    if (Number.isFinite(value) && value > 0 && value !== collider.height){
      if (!changed) pushHistory();
      changed = true;
      collider.height = Math.max(1, value);
    }
  }

  const materialField = $('#colliderMaterialType');
  if (materialField){
    const raw = materialField.value.trim();
    const normalized = raw || null;
    const previous = typeof collider.materialType === 'string' ? collider.materialType : null;
    if (normalized !== previous){
      if (!changed) pushHistory();
      changed = true;
      collider.materialType = normalized;
    }
  }

  const tagsField = $('#colliderTags');
  if (tagsField){
    const raw = tagsField.value.trim();
    const newTags = raw ? raw.split(',').map(t => t.trim()).filter(Boolean) : [];
    const oldTags = Array.isArray(collider.tags) ? collider.tags : [];
    const tagsChanged = newTags.length !== oldTags.length ||
                        newTags.some((tag, i) => tag !== oldTags[i]);
    if (tagsChanged){
      if (!changed) pushHistory();
      changed = true;
      collider.tags = newTags.length > 0 ? newTags : undefined;
    }
  }

  if (changed){
    refreshColliderList();
  }
}

function removeSelectedCollider(){
  const collider = getSelectedCollider();
  if (!collider) return;
  const idx = colliders.findIndex((c) => c.id === collider.id);
  if (idx === -1) return;
  pushHistory();
  colliders.splice(idx, 1);
  const fallback = colliders[idx] || colliders[idx - 1] || null;
  selectedColliderId = fallback?.id ?? null;
  refreshColliderList();
}

function enterColliderPlacement(){
  if (colliderPlacementMode){
    exitColliderPlacement();
    return;
  }
  exitSpawnPlacement();
  colliderPlacementMode = true;
  activeColliderDrag = null;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('collider-mode');
}

function exitColliderPlacement(){
  colliderPlacementMode = false;
  activeColliderDrag = null;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('collider-mode');
}

/*** Instance editor bindings ***/
function updateSelectedInstanceFromFields(){
  const inst = getSelectedInstance();
  if(!inst || inst.layerId !== activeLayerId) return;

  let changed = false;

  const pid = $('#instPrefab').value;
  if(prefabs[pid] && pid !== inst.prefabId){
    if(!changed) pushHistory();
    changed = true;
    inst.prefabId = pid;
  }

  const newLayerId = $('#instLayer').value;
  if(findLayer(newLayerId) && newLayerId !== inst.layerId){
    if(!changed) pushHistory();
    changed = true;
    inst.layerId = newLayerId;
  }

  const locked = $('#instLocked').checked;
  if(locked !== !!inst.locked){
    if(!changed) pushHistory();
    changed = true;
    inst.locked = locked;
  }

  inst.scale = normalizeScale(inst.scale);
  inst.position = normalizePosition(inst.position);

  const sx = parseFloat($('#instScaleX').value);
  if(Number.isFinite(sx) && sx !== inst.scale.x){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.x = Math.max(0.05, sx);
  }

  const sy = parseFloat($('#instScaleY').value);
  if(Number.isFinite(sy) && sy !== inst.scale.y){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.y = Math.max(0.05, sy);
  }

  const offY = parseFloat($('#instOffY').value);
  if(Number.isFinite(offY) && offY !== inst.position.y){
    if(!changed) pushHistory();
    changed = true;
    inst.position.y = offY;
  }

  const rot = parseFloat($('#instRot').value);
  if(Number.isFinite(rot) && rot !== inst.rotationDeg){
    if(!changed) pushHistory();
    changed = true;
    inst.rotationDeg = rot;
  }

  const xVal = parseFloat($('#instX').value);
  if(Number.isFinite(xVal)){
    const grid = GRID_UNIT || 0;
    let target = xVal;
    if(grid > 0){
      target = Math.round(target / grid) * grid;
      $('#instX').value = target.toFixed(1);
    }
    if(target !== inst.position.x){
      if(!changed) pushHistory();
      changed = true;
      inst.position.x = target;
    }
  }

  const stretchEnabled = $('#instStretchEnabled').checked;
  const stretchTarget = ($('#instStretchLayer').value || '').trim();
  const stretchHeight = parseFloat($('#instStretchHeight').value);
  const stretchTopOffset = parseFloat($('#instStretchTopOffset').value);
  const stretchSlices = parseInt($('#instStretchSlices').value, 10);

  const currentStretch = getStretchQuadMeta(inst);
  const nextStretch = (() => {
    if (!stretchEnabled) return null;
    const normalizedHeight = Number.isFinite(stretchHeight) ? stretchHeight : null;
    if (!stretchTarget || normalizedHeight === null || normalizedHeight <= 0){
      return null;
    }
    return {
      targetLayerId: stretchTarget,
      height: normalizedHeight,
      topOffset: Number.isFinite(stretchTopOffset) ? stretchTopOffset : 0,
      slices: Number.isFinite(stretchSlices) ? clamp(Math.round(stretchSlices), 4, 80) : 24,
    };
  })();

  const serializeSpec = (spec) => (spec ? JSON.stringify(spec) : null);
  if (serializeSpec(currentStretch.spec) !== serializeSpec(nextStretch)){
    if(!changed) pushHistory();
    changed = true;
    if(!inst.meta || typeof inst.meta !== 'object') inst.meta = {};
    if(nextStretch){
      inst.meta.stretchQuad = nextStretch;
      if (currentStretch.key && currentStretch.key !== 'stretchQuad'){
        delete inst.meta[currentStretch.key];
      }
    } else {
      delete inst.meta.stretchQuad;
      if (currentStretch.key){
        delete inst.meta[currentStretch.key];
      }
    }
  }

  if(changed){
    refreshInstanceList();
  }
}

['instPrefab','instLayer','instLocked',
 'instScaleX','instScaleY','instOffY','instRot','instX',
 'instStretchEnabled','instStretchLayer','instStretchHeight','instStretchTopOffset','instStretchSlices'
].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedInstanceFromFields);
  el.addEventListener('blur', updateSelectedInstanceFromFields);
});

['colliderLabel','colliderLeft','colliderWidth','colliderTopOffset','colliderHeight','colliderMaterialType','colliderTags'].forEach(id => {
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedColliderFromFields);
  el.addEventListener('blur', updateSelectedColliderFromFields);
});

const addColliderButton = document.getElementById('btnAddCollider');
if (addColliderButton){
  addColliderButton.addEventListener('click', () => {
    enterColliderPlacement();
  });
}
const removeColliderButton = document.getElementById('btnDeleteCollider');
if (removeColliderButton){
  removeColliderButton.addEventListener('click', () => {
    removeSelectedCollider();
  });
}

/*** Camera & Zoom ***/
function setCameraX(v){
  cameraX=clamp(v,-4000,4000);
  $('#camSlider').value=cameraX;
  $('#camNum').value=cameraX;
}
function setZoom(v){
  zoom=clamp(v,0.5,2.0);
  $('#zoomSlider').value=zoom;
  $('#zoomNum').value=zoom.toFixed(2);
}
$('#camSlider').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#camNum').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#zoomSlider').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));
$('#zoomNum').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));

/*** Canvas & Render ***/
const canvas=document.getElementById('sceneCanvas');
const ctx=canvas.getContext('2d',{alpha:true,desynchronized:true});
let lastDrumSkinQuads = [];
let renderHandle = null;

function ensureRenderLoop(){
  if (renderHandle != null) return;
  renderHandle = requestAnimationFrame(render);
}

function resizeCanvas(){
  const rect=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const w=Math.max(1,rect.width*dpr);
  const h=Math.max(1,rect.height*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
  }
}
function layerDrawOrder(layer){
  return layers.indexOf(layer);
}
function partOrder(part){
  if(part.layer==='far') return 0;
  if(part.layer==='near') return 2;
  return 1;
}

function render(){
  renderHandle = null;
  resizeCanvas();
  const dpr=window.devicePixelRatio||1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  ctx.clearRect(0,0,W,H);

  // sky
  const sky=ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,"rgba(59,63,69,0.9)");
  sky.addColorStop(0.5,"rgba(80,89,96,0.5)");
  sky.addColorStop(1,"rgba(32,38,50,0.0)");
  ctx.fillStyle=sky;
  ctx.fillRect(0,0,W,H);

  // treeline
  ctx.save();
  ctx.translate(0,H*0.46);
  ctx.beginPath();
  ctx.moveTo(0,20);
  const steps=24, step=W/steps;
  for(let i=0;i<=steps;i++){
    const h=(i%2===0)?-28:-46;
    ctx.lineTo(i*step,h);
  }
  ctx.lineTo(W,20);
  ctx.closePath();
  ctx.fillStyle="rgba(22,51,33,0.9)";
  ctx.fill();
  ctx.restore();

  const dbg=[];
  const drumRenderables = [];
  lastDrumSkinQuads = [];

  for (const drum of drumSkins){
    if (drum.visible === false) continue;
    const legacyLayerA = drum.legacyLayerA ? findLayer(drum.legacyLayerA) : null;
    const legacyLayerB = drum.legacyLayerB ? findLayer(drum.legacyLayerB) : null;
    const prefab = prefabs[drum.prefabId] || prefabs[drum.textureId];
    const resolvedUrl = drum.imageURL || resolveDrumSkinPrefabTexture(prefab);
    if (!resolvedUrl) continue;
    let img = imageCache.get(resolvedUrl);
    if (!img) {
      loadImage(resolvedUrl);
      img = imageCache.get(resolvedUrl);
    }

    const topParallax = toNumber(drum.topParallax, legacyLayerA?.parallaxSpeed ?? 1) || 1;
    const bottomParallax = toNumber(drum.bottomParallax, legacyLayerB?.parallaxSpeed ?? topParallax) || topParallax;
    const topScale = toNumber(drum.topScale, legacyLayerA?.scale ?? 1) || 1;
    const bottomScale = toNumber(drum.bottomScale, legacyLayerB?.scale ?? topScale) || topScale;
    const avgScale = (topScale + bottomScale) * 0.5;
    const centerA = W/2 + (-cameraX * topParallax) * zoom;
    const centerB = W/2 + (-cameraX * bottomParallax) * zoom;
    const span = W * 1.4 * avgScale;
    const halfSpan = span * 0.5;
    const yA = groundY + (toNumber(drum.topYOffset, legacyLayerA?.offsetY ?? 0) || 0) * zoom;
    const yB = groundY + (toNumber(drum.bottomYOffset, legacyLayerB?.offsetY ?? 0) || 0) * zoom;
    const points = [
      { x: centerA - halfSpan, y: yA },
      { x: centerA + halfSpan, y: yA },
      { x: centerB + halfSpan, y: yB },
      { x: centerB - halfSpan, y: yB },
    ];
    const bounds = points.reduce((acc, pt) => ({
      minX: Math.min(acc.minX, pt.x),
      maxX: Math.max(acc.maxX, pt.x),
      minY: Math.min(acc.minY, pt.y),
      maxY: Math.max(acc.maxY, pt.y),
    }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
    drumRenderables.push({
      drum,
      topParallax,
      bottomParallax,
      topScale,
      bottomScale,
      points,
      bounds,
      img,
      url: resolvedUrl,
    });
  }

  for (const renderable of drumRenderables){
    const { drum, topParallax, bottomParallax, topScale, bottomScale, points, img } = renderable;
    ctx.save();
    let filled = false;
    if (img && img.complete && img.naturalWidth){
      const pattern = ctx.createPattern(img, 'repeat');
      if (pattern){
        const patternScale = Math.max(0.05, (drum.tileScale || 1) * zoom * ((topScale + bottomScale) * 0.5));
        if (pattern.setTransform){
          const avgParallax = (topParallax + bottomParallax) * 0.5;
          const offsetX = (-cameraX * avgParallax) * zoom;
          const periodX = Math.max(1, img.width * patternScale);
          const periodY = Math.max(1, img.height * patternScale);
          const avgYOffset = ((toNumber(drum.topYOffset, 0) || 0) + (toNumber(drum.bottomYOffset, 0) || 0)) * 0.5;
          const baseY = groundY + avgYOffset * zoom;
          const tx = ((offsetX % periodX) + periodX) % periodX;
          const ty = ((baseY % periodY) + periodY) % periodY;
          const leftPoint = points[0];
          const rightPoint = points[1];
          const bottomLeft = points[3];
          const height = Math.max(1, points[2].y - leftPoint.y);
          const shear = ((bottomLeft.x - leftPoint.x) / height) * patternScale;
          const alignX = leftPoint.x % periodX;
          const alignY = leftPoint.y % periodY;
          pattern.setTransform(new DOMMatrix([
            patternScale,
            0,
            shear,
            patternScale,
            tx + alignX,
            ty + alignY,
          ]));
        }
        ctx.fillStyle = pattern;
        filled = true;
      }
    }
    if (!filled){
      ctx.fillStyle = 'rgba(148,163,184,0.26)';
    }
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++){
      ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fill();
    const isSelected = drum.id === selectedDrumSkinId;
    if (isSelected || debugOverlay){
      ctx.strokeStyle = isSelected ? '#22c55e' : 'rgba(148,163,184,0.7)';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.stroke();
    }
    ctx.restore();
    if (debugOverlay){
      const til = drum.tileScale || 1;
      dbg.push(`drum ${drum.id} par:${topParallax.toFixed(2)}->${bottomParallax.toFixed(2)} y:${(drum.topYOffset || 0).toFixed(1)}->${(drum.bottomYOffset || 0).toFixed(1)} tile=${til.toFixed(2)}`);
    }
  }

  lastDrumSkinQuads = drumRenderables;

  const renderList=[];
  for(const inst of instances){
    const layer=findLayer(inst.layerId);
    const prefab=prefabs[inst.prefabId];
    if(!layer) continue;
    if(!prefab && !isPlayerSpawn(inst)) continue;
    renderList.push({inst,layer,prefab});
  }
  renderList.sort((a,b)=>layerDrawOrder(a.layer)-layerDrawOrder(b.layer));

  const retX=W/2;
  const retY=groundY - 8*zoom;

  for(const {inst,layer,prefab} of renderList){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const instRot=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;

    if(isPlayerSpawn(inst)){
      const baseOffset=(pos.x - cameraX*par)*zoom;
      const rootScreenX=W/2 + baseOffset;
      const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - 20*zoom);
      ctx.strokeStyle='#38bdf8';
      ctx.fillStyle='rgba(56,189,248,0.18)';
      ctx.lineWidth=1.2;
      const radius=10*zoom;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-radius,0);
      ctx.lineTo(radius,0);
      ctx.moveTo(0,-radius);
      ctx.lineTo(0,radius);
      ctx.stroke();
      ctx.fillStyle='#38bdf8';
      ctx.font=`${10*zoom}px ui-monospace,Menlo,Consolas`;
      ctx.textAlign='center';
      ctx.fillText('Player Spawn',0,-radius-6);
      ctx.restore();

      if(debugOverlay){
        dbg.push(`spawn @${layer.name} x=${pos.x.toFixed(1)}`);
      }
      continue;
    }

    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    const dxScreen = rootScreenX - retX;

    if(prefab.isImage){
      const part=prefab.parts[0];
      const t=part.propTemplate||{};
      const img=imageCache.get(t.url);
      if(!img) continue;
      const w=t.w || img.width;
      const h=t.h || img.height;
      const {ax,ay}=computeAnchor(t);
      ctx.save();
      ctx.translate(rootScreenX,rootScreenY);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));
      ctx.drawImage(img,-ax,-ay,w,h);
      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.2:0.7;
        ctx.strokeRect(-ax,-ay,w,h);
        dbg.push(`img ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)}`);
      }
      ctx.restore();
      continue;
    }

    // Structured prefab: compute shared t from root part
    const rootPart = prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!rootPart) continue;
    const rootT = rootPart.propTemplate || {};
    const rootRelY = rootPart.relY || 0;

    const {t: sharedT, radiusPx} = computeTFromDx(rootT.kf || {}, dxScreen);
    const rootPose = evalKfPose(rootT.kf || {}, sharedT);

    const parts=[...prefab.parts].sort((a,b)=>
      (partOrder(a)-partOrder(b)) || ((a.z||0)-(b.z||0))
    );

    for(const part of parts){
      const t = part.propTemplate || {};
      const img = imageCache.get(t.url);
      const relX = part.relX || 0;
      const relY = part.relY || 0;

      const partPose = evalKfPose(t.kf || {}, sharedT);

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - rootRelY*layerScale*zoom);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));

      // apply root pose
      applyPose(ctx, rootPose);

      // part local offset
      ctx.translate(relX, -relY);

      // apply part pose
      applyPose(ctx, partPose);

      const w = t.w || 100;
      const h = t.h || 100;
      const {ax,ay} = computeAnchor(t);

      if(img && img.complete && img.naturalWidth){
        ctx.drawImage(img,-ax,-ay,w,h);
      } else {
        ctx.fillStyle="rgba(148,163,253,0.18)";
        ctx.fillRect(-ax,-ay,w,h);
      }

      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.1:0.6;
        ctx.strokeRect(-ax,-ay,w,h);
        ctx.fillStyle="#e5e7eb";
        ctx.font="7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`${part.name}`, -ax, -ay-3);
      }

      ctx.restore();
    }

    if(debugOverlay){
      const isSel = inst.id === selectedInstId;
      dbg.push(
        `struct ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)} t=${sharedT.toFixed(3)} rPx=${radiusPx.toFixed(1)}${inst.locked?' 🔒':''}`
      );

      if (isSel && rootT.kf){
        const towerY = rootScreenY - rootRelY*layerScale*zoom;

        ctx.save();
        ctx.lineWidth = 0.8;

        // Ray from reticle to tower horizontally
        ctx.strokeStyle = "rgba(56,189,248,0.9)";
        ctx.beginPath();
        ctx.moveTo(retX, retY);
        ctx.lineTo(rootScreenX, retY);
        ctx.stroke();

        // Down to tower
        ctx.beginPath();
        ctx.moveTo(rootScreenX, retY);
        ctx.lineTo(rootScreenX, towerY);
        ctx.stroke();

        // Radius band around reticle in screen-space
        const r = radiusPx;
        ctx.strokeStyle = "rgba(148,163,253,0.35)";
        ctx.beginPath();
        ctx.moveTo(retX - r, retY);
        ctx.lineTo(retX + r, retY);
        ctx.stroke();

        // Labels
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`dx=${dxScreen.toFixed(1)}px`, rootScreenX+4, towerY-18);
        ctx.fillText(`t=${sharedT.toFixed(2)}`, rootScreenX+4, towerY-9);
        ctx.fillText(`rPx=${r.toFixed(1)}`, retX+4, retY+12);

        ctx.restore();
      }
    }
  }

  if(colliders.length){
    ctx.save();
    ctx.lineWidth = 1.5;
    for(const collider of colliders){
      const leftWorld = toNumber(collider.left, 0);
      const widthWorld = Math.max(0, toNumber(collider.width, 0));
      const topOffset = toNumber(collider.topOffset, 0);
      const heightWorld = Math.max(0, toNumber(collider.height, 0));
      if(widthWorld <= 0 || heightWorld <= 0) continue;
      const screenLeft = W/2 + (leftWorld - cameraX) * zoom;
      const screenTop = groundY + topOffset * zoom;
      const screenWidth = widthWorld * zoom;
      const screenHeight = heightWorld * zoom;
      if(screenWidth <= 0 || screenHeight <= 0) continue;
      const isSelected = collider.id === selectedColliderId;
      ctx.fillStyle = isSelected ? 'rgba(239,68,68,0.18)' : 'rgba(148,163,184,0.12)';
      ctx.strokeStyle = isSelected ? 'rgba(239,68,68,0.65)' : 'rgba(148,163,184,0.55)';
      ctx.fillRect(screenLeft, screenTop, screenWidth, screenHeight);
      ctx.strokeRect(screenLeft, screenTop, screenWidth, screenHeight);
      const label = typeof collider.label === 'string' ? collider.label.trim() : '';
      if(label){
        ctx.save();
        ctx.fillStyle = isSelected ? '#fecaca' : '#cbd5f5';
        const fontSize = Math.max(7, 9 * zoom);
        ctx.font = `${fontSize}px ui-monospace,Menlo,Consolas`;
        ctx.textBaseline = 'top';
        ctx.fillText(label, screenLeft + 4, screenTop + 2);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  if (editorMode === 'behavior'){
    const toScreen = (position, layerId) => {
      const layer = findLayer(layerId) || findLayer(getDefaultSpawnLayerId()) || { parallaxSpeed: 1, name: layerId };
      const parallax = toNumber(layer?.parallaxSpeed ?? layer?.parallax ?? 1, 1) || 1;
      const pos = normalizePosition(position);
      return {
        x: W/2 + (pos.x - cameraX * parallax) * zoom,
        y: groundY + pos.y * zoom,
        name: layer?.name || layerId || 'layer',
      };
    };
    const drawMarker = (pos, color, label) => {
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      const radius = Math.max(4, 6 * zoom);
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = color;
      ctx.font = `${Math.max(8, 9 * zoom)}px ui-monospace,Menlo,Consolas`;
      ctx.textBaseline = 'bottom';
      ctx.fillText(label, pos.x + radius + 4, pos.y - radius - 2);
      ctx.restore();
    };

    for (const spawner of behaviorSpawners){
      const pos = toScreen(spawner.position, spawner.layerId);
      drawMarker(pos, '#22c55e', `Spawner:${spawner.spawnerId || 'npc'}`);
    }
    for (const target of behaviorPathTargets){
      const pos = toScreen(target.position, target.layerId);
      drawMarker(pos, '#38bdf8', `Path:${target.name || target.targetId}`);
    }
    for (const point of behaviorInteractionPoints){
      const pos = toScreen(point.position, point.layerId);
      drawMarker(pos, '#f59e0b', `Interact:${point.interactionId || 'id'}`);
    }
    for (const spawn of behaviorArrivalSpawns){
      const pos = toScreen(spawn.position, spawn.layerId);
      drawMarker(pos, '#c084fc', `Arrival:${spawn.arrivalId || 'arrival'}`);
    }
  }

  // ground line
  ctx.save();
  ctx.strokeStyle="rgba(250,204,21,0.35)";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(0,groundY+0.5);
  ctx.lineTo(W,groundY+0.5);
  ctx.stroke();
  ctx.restore();

  // reticle
  const size=10*zoom;
  ctx.save();
  ctx.strokeStyle="#facc15";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(retX-size,retY);
  ctx.lineTo(retX+size,retY);
  ctx.moveTo(retX,retY-size);
  ctx.lineTo(retX,retY+size);
  ctx.stroke();
  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.arc(retX,retY,2.5,0,Math.PI*2);
  ctx.fill();
  ctx.font="8px ui-monospace,Menlo,Consolas";
  ctx.fillText("Cam/Player",retX+6,retY-6);
  ctx.restore();

  $('#debugText').textContent = debugOverlay
    ? `camX=${cameraX} zoom=${zoom.toFixed(2)} activeLayer=${activeLayerId} · instances=${instances.length}\n` + dbg.join('\n')
    : '';

  renderHandle = requestAnimationFrame(render);
}

/*** Picking & drag ***/
function pointInPolygon(pt, poly){
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++){
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
      (pt.x < ((xj - xi) * (pt.y - yi)) / ((yj - yi) || 1e-6) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function pickDrumSkinAt(clientX, clientY){
  if (!lastDrumSkinQuads.length) return null;
  const rect = canvas.getBoundingClientRect();
  const px = clientX - rect.left;
  const py = clientY - rect.top;
  for (let i = lastDrumSkinQuads.length - 1; i >= 0; i--){
    const quad = lastDrumSkinQuads[i];
    const { minX, maxX, minY, maxY } = quad.bounds;
    if (px < minX || px > maxX || py < minY || py > maxY) continue;
    if (pointInPolygon({ x: px, y: py }, quad.points)) return quad.drum;
  }
  return null;
}

function pickInstanceAt(clientX,clientY){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const py=clientY-rect.top;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  const candidates=instances
    .filter(i=>i.layerId===activeLayerId)
    .map(inst=>{
      const layer=findLayer(inst.layerId);
      const prefab=prefabs[inst.prefabId];
      return layer && (prefab || isPlayerSpawn(inst)) ? {inst,layer,prefab}:null;
    })
    .filter(Boolean);

  candidates.sort((a,b)=>layerDrawOrder(b.layer)-layerDrawOrder(a.layer));

  for(const {inst,layer,prefab} of candidates){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    if(isPlayerSpawn(inst)){
      const radius = 12 * zoom;
      const centerX = rootScreenX;
      const centerY = rootScreenY - 20 * zoom;
      const left = centerX - radius;
      const right = centerX + radius;
      const top = centerY - radius;
      const bottom = centerY + radius;
      if(px>=left && px<=right && py>=top && py<=bottom) return inst;
      continue;
    }

    let part;
    if(prefab.isImage) part=prefab.parts[0];
    else part=prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!part) continue;
    const t=part.propTemplate||{};
    const w=t.w || 100;
    const h=t.h || 100;
    const {ax,ay}=computeAnchor(t);
    const sc=layerScale*zoom*scale.x;

    const left=rootScreenX - ax*sc;
    const top =rootScreenY - h*sc;
    const right=left + w*sc;
    const bottom=top + h*sc;
    if(px>=left && px<=right && py>=top && py<=bottom) return inst;
  }
  return null;
}

let draggingCamera=false;
let draggingInst=null;
let lastX=0;
let draggingInstOffset=0;

function pointerClientToWorldX(clientX, layer){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const par=layer?.parallax ?? 1;
  const baseOffset=(px - W/2)/zoom;
  return baseOffset + cameraX*par;
}

function pointerClientToGroundOffset(clientY){
  const rect = canvas.getBoundingClientRect();
  const py = clientY - rect.top;
  const dpr = window.devicePixelRatio || 1;
  const H = canvas.height / dpr;
  const groundY = H - getGroundOffset();
  const scale = zoom || 1;
  return (py - groundY) / scale;
}

function pickColliderAt(clientX, clientY){
  if (!colliders.length) return null;
  const worldX = pointerClientToWorldX(clientX, { parallax: 1 });
  const offsetY = pointerClientToGroundOffset(clientY);
  for (let i = colliders.length - 1; i >= 0; i--){
    const col = colliders[i];
    const left = toNumber(col.left, 0);
    const width = Math.max(0, toNumber(col.width, 0));
    const topOffset = toNumber(col.topOffset, 0);
    const height = Math.max(0, toNumber(col.height, 0));
    const right = left + width;
    const bottomOffset = topOffset + height;
    if (worldX >= left && worldX <= right && offsetY >= topOffset && offsetY <= bottomOffset){
      return col;
    }
  }
  return null;
}

function pointerDown(ev){
  const t=ev.touches?ev.touches[0]:ev;
  lastX=t.clientX;
  if(spawnPlacementMode){
    const spawn = ensurePlayerSpawn();
    const layer = findLayer(spawn.layerId) || findLayer(getDefaultSpawnLayerId());
    if(layer){
      pushHistory();
      const worldX = pointerClientToWorldX(t.clientX, layer);
      const grid = GRID_UNIT || 0;
      const snapped = grid > 0 ? Math.round(worldX / grid) * grid : worldX;
      spawn.position = normalizePosition(spawn.position);
      spawn.position.x = snapped;
      spawn.locked = true;
      selectedInstId = spawn.id;
    refreshInstanceList();
  }
    exitSpawnPlacement();
    return;
  }
  if (behaviorPlacement && editorMode === 'behavior'){
    const target = behaviorPlacement.kind === 'pathTarget'
      ? behaviorPathTargets.find((tgt) => tgt.targetId === behaviorPlacement.id)
      : behaviorSpawners.find((spawner) => spawner.spawnerId === behaviorPlacement.id);
    const layer = target ? findLayer(target.layerId) || findLayer(getDefaultSpawnLayerId()) : null;
    if (target && layer){
      pushHistory();
      const worldX = pointerClientToWorldX(t.clientX, layer);
      const offsetY = pointerClientToGroundOffset(t.clientY);
      const grid = GRID_UNIT || 0;
      const snapped = grid > 0 ? Math.round(worldX / grid) * grid : worldX;
      target.position = normalizePosition(target.position);
      target.position.x = snapped;
      target.position.y = offsetY;
      if (behaviorPlacement.kind === 'pathTarget'){
        refreshPathTargetList();
      } else {
        refreshBehaviorSpawnerList();
      }
      ensureRenderLoop();
    }
    exitBehaviorPlacement();
    return;
  }
  if(colliderPlacementMode){
    const worldX = pointerClientToWorldX(t.clientX, { parallax: 1 });
    const offsetY = pointerClientToGroundOffset(t.clientY);
    pushHistory();
    const id = nextColliderId++;
    const collider = {
      id,
      label: `Collider ${id}`,
      type: 'box',
      left: worldX,
      width: 8,
      topOffset: offsetY,
      height: 8,
      materialType: null,
      meta: {},
    };
    colliders.push(collider);
    selectedColliderId = collider.id;
    activeColliderDrag = { collider, startX: worldX, startOffset: offsetY, mode: 'new' };
    refreshColliderList();
    return;
  }
  const colliderHit = pickColliderAt(t.clientX, t.clientY);
  if (colliderHit){
    selectedColliderId = colliderHit.id;
    refreshColliderList();
    syncColliderFields();
    return;
  }
  const drumHit = pickDrumSkinAt(t.clientX, t.clientY);
  if (drumHit){
    selectedDrumSkinId = drumHit.id;
    refreshDrumSkinList();
    return;
  }
  const hit=pickInstanceAt(t.clientX,t.clientY);
  if(hit){
    selectedInstId=hit.id;
    const inst=getSelectedInstance();
    if(inst && !inst.locked){
      pushHistory();
      draggingInst=inst;
      const layerForDrag = findLayer(inst.layerId);
      if(layerForDrag){
        inst.position = normalizePosition(inst.position);
        draggingInstOffset = pointerClientToWorldX(t.clientX, layerForDrag) - inst.position.x;
      } else {
        draggingInstOffset = 0;
      }
    }
    refreshInstanceList();
  }else{
    pushHistory();
    draggingCamera=true;
  }
}
function pointerMove(ev){
  if(!draggingCamera && !draggingInst && !activeColliderDrag) return;
  const t=ev.touches?ev.touches[0]:ev;
  if(activeColliderDrag){
    const collider = activeColliderDrag.collider;
    if(!collider) { activeColliderDrag = null; return; }
    const worldX = pointerClientToWorldX(t.clientX, { parallax: 1 });
    const offsetY = pointerClientToGroundOffset(t.clientY);
    const minSize = 8;
    const left = Math.min(worldX, activeColliderDrag.startX);
    const width = Math.max(minSize, Math.abs(worldX - activeColliderDrag.startX));
    const topOffset = Math.min(offsetY, activeColliderDrag.startOffset);
    const height = Math.max(minSize, Math.abs(offsetY - activeColliderDrag.startOffset));
    collider.left = left;
    collider.width = width;
    collider.topOffset = topOffset;
    collider.height = height;
    refreshColliderList();
    return;
  }
  const dx=t.clientX-lastX;
  lastX=t.clientX;
  if(draggingInst){
    if(draggingInst.locked){ draggingInst=null; return; }
    const layer=findLayer(draggingInst.layerId);
    if(!layer) return;
    const worldX = pointerClientToWorldX(t.clientX, layer) - draggingInstOffset;
    const grid=GRID_UNIT||0;
    const snapped = grid>0 ? Math.round(worldX/grid)*grid : worldX;
    draggingInst.position = normalizePosition(draggingInst.position);
    if(snapped !== draggingInst.position.x){
      draggingInst.position.x = snapped;
      refreshInstanceList();
    }
  }else if(draggingCamera){
    setCameraX(cameraX - dx*2);
  }
}
function pointerUp(){
  draggingCamera=false;
  draggingInst=null;
  draggingInstOffset=0;
  if(activeColliderDrag){
    activeColliderDrag = null;
    refreshColliderList();
  }
  if(colliderPlacementMode){
    exitColliderPlacement();
  }
}
canvas.addEventListener('mousedown',pointerDown);
canvas.addEventListener('mousemove',pointerMove);
window.addEventListener('mouseup',pointerUp);
canvas.addEventListener('touchstart',e=>{e.preventDefault();pointerDown(e);},{passive:false});
canvas.addEventListener('touchmove', e=>{e.preventDefault();pointerMove(e);},{passive:false});
canvas.addEventListener('touchend',  e=>{e.preventDefault();pointerUp();},{passive:false});

/*** Buttons & toggles ***/
$('#btnPlacePlayerSpawn').addEventListener('click', () => {
  const spawn = ensurePlayerSpawn();
  spawnPlacementMode = true;
  selectedInstId = spawn.id;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('spawn-mode');
  refreshInstanceList();
});
$('#btnJitter').addEventListener('click',()=>{
  pushHistory();
  const posRange=Math.abs(parseFloat($('#jitterRange').value)||0);
  const scaleRange=Math.abs(parseFloat($('#jitterScaleRange').value)||0);
  if(posRange<=0 && scaleRange<=0) return;
  for(const inst of instances){
    if(inst.layerId!==activeLayerId || inst.locked) continue;
    if(posRange>0){
      const delta = (Math.random()*2-1)*posRange;
      inst.position = normalizePosition(inst.position);
      inst.position.x += delta;
      const grid = GRID_UNIT || 0;
      if(grid > 0){
        inst.position.x = Math.round(inst.position.x / grid) * grid;
      }
    }
    if(scaleRange>0){
      const sx=1 + (Math.random()*2-1)*scaleRange;
      const sy=1 + (Math.random()*2-1)*scaleRange;
      inst.scale = normalizeScale(inst.scale);
      inst.scale.x=Math.max(0.1,sx);
      inst.scale.y=Math.max(0.1,sy);
    }
  }
  refreshInstanceList();
});

// POI Management Functions
function refreshPOIList(){
  const list = $('#behaviorPOIList');
  if (!list) return;
  list.innerHTML = '';
  behaviorPOIs.forEach((poi) => {
    const div = document.createElement('div');
    div.className = 'behavior-item' + (poi.id === selectedPOIId ? ' active' : '');
    div.textContent = `${poi.label || poi.name} (${poi.id})`;
    div.onclick = () => { selectedPOIId = poi.id; syncPOIFields(); refreshPOIList(); };
    list.appendChild(div);
  });
}

function syncPOIFields(){
  const poi = behaviorPOIs.find((p) => p.id === selectedPOIId) || null;
  $('#behaviorPOIId').value = poi?.id || '';
  $('#behaviorPOIName').value = poi?.name || '';
  $('#behaviorPOILabel').value = poi?.label || '';
  $('#behaviorPOIType').value = poi?.type || 'box';
  $('#behaviorPOILeft').value = poi?.bounds?.left ?? '';
  $('#behaviorPOIWidth').value = poi?.bounds?.width ?? '';
  $('#behaviorPOITop').value = poi?.bounds?.top ?? '';
  $('#behaviorPOIHeight').value = poi?.bounds?.height ?? '';
  const scheduleHours = Array.isArray(poi?.meta?.scheduleHours) ? poi.meta.scheduleHours.join(',') : '';
  $('#behaviorPOISchedule').value = scheduleHours;
  const deleteBtn = $('#btnDeletePOI');
  if (deleteBtn) deleteBtn.disabled = !poi;
}

function addPOI(){
  pushHistory();
  const newId = `poi_${behaviorPOIs.length + 1}`;
  const newPOI = normalizePOI({ id: newId, name: 'poi', label: 'New POI' }, behaviorPOIs.length + 1);
  behaviorPOIs.push(newPOI);
  selectedPOIId = newPOI.id;
  refreshPOIList();
  syncPOIFields();
}

function deletePOI(){
  const poi = behaviorPOIs.find((p) => p.id === selectedPOIId);
  if (!poi) return;
  pushHistory();
  const idx = behaviorPOIs.indexOf(poi);
  if (idx !== -1) behaviorPOIs.splice(idx, 1);
  selectedPOIId = behaviorPOIs[0]?.id ?? null;
  refreshPOIList();
  syncPOIFields();
}

function updatePOIFromFields(){
  const poi = behaviorPOIs.find((p) => p.id === selectedPOIId);
  if (!poi) return;
  pushHistory();
  poi.id = $('#behaviorPOIId').value.trim() || poi.id;
  poi.name = $('#behaviorPOIName').value.trim() || 'poi';
  poi.label = $('#behaviorPOILabel').value.trim() || poi.name;
  poi.type = $('#behaviorPOIType').value.trim() || 'box';
  poi.bounds.left = parseFloat($('#behaviorPOILeft').value) || 0;
  poi.bounds.width = parseFloat($('#behaviorPOIWidth').value) || 120;
  poi.bounds.top = parseFloat($('#behaviorPOITop').value) || -50;
  poi.bounds.height = parseFloat($('#behaviorPOIHeight').value) || 100;
  const scheduleStr = $('#behaviorPOISchedule').value.trim();
  const scheduleHours = scheduleStr ? scheduleStr.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n)) : [];
  poi.meta.scheduleHours = scheduleHours.length > 0 ? scheduleHours : undefined;
  refreshPOIList();
}

$('#btnDeleteInst').addEventListener('click',deleteSelectedInstance);
$('#btnDuplicateInst').addEventListener('click',duplicateSelectedInstance);
$('#btnUndo').addEventListener('click',undo);
$('#chkDebug').addEventListener('change',e=>{debugOverlay=e.target.checked;});
$('#btnAddDrumSkin').addEventListener('click', addDrumSkin);
const modeLayoutBtn = document.getElementById('btnModeLayout');
if (modeLayoutBtn) modeLayoutBtn.addEventListener('click', () => setEditorMode('layout'));
const modeBehaviorBtn = document.getElementById('btnModeBehavior');
if (modeBehaviorBtn) modeBehaviorBtn.addEventListener('click', () => setEditorMode('behavior'));
const addBehaviorSpawnerBtn = document.getElementById('btnAddBehaviorSpawner');
if (addBehaviorSpawnerBtn) addBehaviorSpawnerBtn.addEventListener('click', addBehaviorSpawner);
const placeBehaviorSpawnerBtn = document.getElementById('btnPlaceBehaviorSpawner');
if (placeBehaviorSpawnerBtn) placeBehaviorSpawnerBtn.addEventListener('click', () => { setEditorMode('behavior'); startBehaviorPlacement('spawner'); });
['behaviorSpawnerId','behaviorSpawnerLayer','behaviorSpawnerX','behaviorSpawnerY','behaviorSpawnerRadius','behaviorSpawnerCount','behaviorSpawnerTemplate','behaviorSpawnerCharacter','behaviorSpawnerRespawn'].forEach((id) => {
  const el = document.getElementById(id);
  if (el){
    ['change','blur'].forEach((evt) => el.addEventListener(evt, updateBehaviorSpawnerFromFields));
  }
});
const addPathTargetBtn = document.getElementById('btnAddPathTarget');
if (addPathTargetBtn) addPathTargetBtn.addEventListener('click', addPathTarget);
const placePathTargetBtn = document.getElementById('btnPlacePathTarget');
if (placePathTargetBtn) placePathTargetBtn.addEventListener('click', () => { setEditorMode('behavior'); startBehaviorPlacement('pathTarget'); });
['behaviorPathName','behaviorPathOrder','behaviorPathLayer','behaviorPathInstanceId','behaviorPathX','behaviorPathY'].forEach((id) => {
  const el = document.getElementById(id);
  if (el){
    ['change','blur'].forEach((evt) => el.addEventListener(evt, updatePathTargetFromFields));
  }
});
const addPOIBtn = document.getElementById('btnAddPOI');
if (addPOIBtn) addPOIBtn.addEventListener('click', addPOI);
const deletePOIBtn = document.getElementById('btnDeletePOI');
if (deletePOIBtn) deletePOIBtn.addEventListener('click', deletePOI);
['behaviorPOIId','behaviorPOIName','behaviorPOILabel','behaviorPOIType','behaviorPOILeft','behaviorPOIWidth','behaviorPOITop','behaviorPOIHeight','behaviorPOISchedule'].forEach((id) => {
  const el = document.getElementById(id);
  if (el){
    ['change','blur'].forEach((evt) => el.addEventListener(evt, updatePOIFromFields));
  }
});
const addInteractionBtn = document.getElementById('btnAddInteractionPoint');
if (addInteractionBtn) addInteractionBtn.addEventListener('click', addInteractionPoint);
['behaviorInteractionId','behaviorInteractionLayer','behaviorInteractionX','behaviorInteractionY','behaviorInteractionAction','behaviorInteractionTarget','behaviorInteractionPrompt'].forEach((id) => {
  const el = document.getElementById(id);
  if (el){
    ['change','blur'].forEach((evt) => el.addEventListener(evt, updateInteractionFromFields));
  }
});
const addArrivalBtn = document.getElementById('btnAddArrivalSpawn');
if (addArrivalBtn) addArrivalBtn.addEventListener('click', addArrivalSpawn);
['behaviorArrivalId','behaviorArrivalLayer','behaviorArrivalX','behaviorArrivalY','behaviorArrivalFrom'].forEach((id) => {
  const el = document.getElementById(id);
  if (el){
    ['change','blur'].forEach((evt) => el.addEventListener(evt, updateArrivalFromFields));
  }
});
$('#btnPlaceRow').addEventListener('click',()=>{
  const pid=$('#libPrefab').value;
  const count=parseInt($('#libCount').value,10)||1;
  if(!prefabs[pid]){ alert('No prefab selected'); return; }
  pushHistory();
  for(let i=0;i<count;i++) addInstance(activeLayerId,pid);
  refreshInstanceList();
});
$('#btnAddParallaxLayer').addEventListener('click',()=>{
  const count=getParallaxLayerCount();
  if(count>=10){ alert('Parallax layer limit reached (10).'); return; }
  pushHistory();
  const id=`bg${count+1}`;
  layers.splice(count,0,{
    id,
    name:`Parallax ${count+1}`,
    type:"parallax",
    parallaxSpeed:0.15 + 0.1*count,
    offsetY:-140 + 20*count,
    separation:220,
    scale:0.6 + 0.05*count,
    meta:{},
  });
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
});

/*** Export / Import map ***/
async function exportLayout(){
  const statusEl = $('#exportStatus');
  const textEl = $('#exportText');
  try{
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      exportedAt: new Date().toISOString(),
    };
    const json=JSON.stringify(area,null,2);
    textEl.value=json;
    const areaId = area.id || area.meta?.areaId || 'map-export';
    const areaName = area.meta?.areaName || areaId;

    let popup=null;
    try {
      popup=window.open('', '_blank');
    } catch (_err) {
      popup=null;
    }

    if(popup){
      const doc=popup.document;
      doc.open();
      doc.write('<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Map export</title><style>body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;margin:24px;background:#0f172a;color:#e2e8f0;} h1{font-size:20px;margin-bottom:16px;} pre{padding:16px;background:#020617;border-radius:8px;border:1px solid #1e293b;max-width:calc(100vw - 48px);overflow:auto;white-space:pre-wrap;word-break:break-word;font-family:"JetBrains Mono","Fira Code",monospace;font-size:13px;line-height:1.6;} button{margin-top:16px;padding:8px 16px;background:#334155;color:#f8fafc;border:1px solid #475569;border-radius:6px;cursor:pointer;} button:hover{background:#1e293b;}</style></head><body></body></html>');
      doc.close();
      doc.title=`${areaName} export`;

      const heading=doc.createElement('h1');
      heading.textContent=`${areaName} JSON export`;

      const pre=doc.createElement('pre');
      pre.textContent=json;

      const copyBtn=doc.createElement('button');
      copyBtn.textContent='Copy JSON to clipboard';
      copyBtn.addEventListener('click',async()=>{
        try {
          await navigator.clipboard.writeText(json);
          copyBtn.textContent='Copied!';
          setTimeout(()=>{ copyBtn.textContent='Copy JSON to clipboard'; }, 2000);
        } catch(_clipboardErr){
          copyBtn.textContent='Copy failed';
          setTimeout(()=>{ copyBtn.textContent='Copy JSON to clipboard'; }, 2000);
        }
      });

      doc.body.append(heading, pre, copyBtn);
      statusEl.style.color='#22c55e';
      statusEl.textContent='Opened area JSON in new tab.';
    }else{
      const blob=new Blob([json],{type:'application/json'});
      const blobUrl=URL.createObjectURL(blob);
      const anchor=document.createElement('a');
      anchor.href=blobUrl;
      anchor.download=`${areaId}.json`;
      anchor.rel='noopener';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      setTimeout(()=>URL.revokeObjectURL(blobUrl),0);
      statusEl.style.color='#22c55e';
      statusEl.textContent='Download started. If blocked, copy JSON below.';
    }
  }catch(err){
    statusEl.style.color='#f97316';
    statusEl.textContent='Export error: '+err.message+' (JSON mirrored below)';
  }
}
$('#btnExportMap').addEventListener('click', exportLayout);

function pruneOldPreviewPayloads(){
  try {
    if (typeof localStorage === 'undefined') return;
    const expiry = Date.now() - 10 * 60 * 1000;
    for (let i = localStorage.length - 1; i >= 0; i--){
      const key = localStorage.key(i);
      if (!key || !key.startsWith(PREVIEW_STORAGE_PREFIX)) continue;
      let remove = false;
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          remove = true;
        } else {
          const payload = JSON.parse(raw);
          if (!payload || typeof payload !== 'object' || !Number.isFinite(payload.createdAt) || payload.createdAt < expiry){
            remove = true;
          }
        }
      } catch (_err) {
        remove = true;
      }
      if (remove) {
        try { localStorage.removeItem(key); } catch (_rmErr) { /* ignore */ }
      }
    }
  } catch (_error) {
    // Ignore storage errors (e.g., privacy mode)
  }
}

function storePreviewPayload(layout){
  const token = `mp${Date.now().toString(36)}${Math.random().toString(36).slice(2,8)}`;
  const safeLayout = JSON.parse(JSON.stringify(layout));
  const payload = {
    createdAt: Date.now(),
    layout: safeLayout,
    version: 1,
  };
  let stored = false;

  if (typeof localStorage !== 'undefined') {
    try {
      pruneOldPreviewPayloads();
      localStorage.setItem(PREVIEW_STORAGE_PREFIX + token, JSON.stringify(payload));
      stored = true;
    } catch (error) {
      console.error('[map-editor] Failed to store preview payload', error);
    }
  }

  return { token, payload, stored };
}

function launchGameplayPreview(){
  try {
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      editorPreview: true,
      exportedAt: new Date().toISOString(),
    };
    const { token, payload, stored } = storePreviewPayload(area);
    if (!token) {
      throw new Error('Failed to create preview token.');
    }
    if (!stored) {
      console.warn('[map-editor] Preview payload could not be persisted; relying on direct preview handshake.');
    }
    const url = new URL('./index.html', window.location.href);
    url.searchParams.set('mode', 'game');
    url.searchParams.set('preview', token);
    const win = window.open(url.toString(), '_blank');
    if (!win) {
      alert('Preview window was blocked. Allow pop-ups for this site to enable gameplay preview.');
      return;
    }
    try {
      const targetOrigin = url.origin || window.location.origin || '*';
      const message = {
        type: 'map-editor-preview',
        token,
        payload,
      };
      win.postMessage(message, targetOrigin);
      setTimeout(() => {
        try {
          win.postMessage(message, targetOrigin);
        } catch (_err) {
          // Ignore follow-up delivery errors.
        }
      }, 50);
    } catch (postError) {
      console.warn('[map-editor] Failed to transmit preview payload to new window', postError);
    }
    win?.focus?.();
  } catch (error) {
    console.error('[map-editor] Failed to launch gameplay preview', error);
    alert('Failed to launch gameplay preview: ' + error.message);
  }
}

const menus = [];
function bindMenu(toggleSelector, menuSelector){
  const toggle = $(toggleSelector);
  const menu = $(menuSelector);
  if (!toggle || !menu) return;
  const close = () => {
    menu.classList.remove('open');
    toggle.setAttribute('aria-expanded','false');
  };
  const open = () => {
    menu.classList.add('open');
    toggle.setAttribute('aria-expanded','true');
  };
  toggle.addEventListener('click', (event) => {
    event.stopPropagation();
    const isOpen = menu.classList.contains('open');
    menus.forEach(item => item.close());
    if (!isOpen) open();
  });
  menu.addEventListener('click', (event) => event.stopPropagation());
  menus.push({ toggle, menu, close });
}

bindMenu('#importMenuToggle', '#importMenu');
bindMenu('#overflowMenuToggle', '#overflowMenu');

document.addEventListener('click', () => menus.forEach(item => item.close()));

$('#btnLoadMap').addEventListener('click', async () => {
  const select = $('#mapRepoSelect');
  const mapId = select?.value || DEFAULT_LAYOUT_META.areaId;
  await loadRepositoryMapById(mapId);
});

const btnLoadMapInline = $('#btnLoadMapInline');
if (btnLoadMapInline){
  btnLoadMapInline.addEventListener('click', () => {
    $('#btnLoadMap')?.click();
    menus.forEach(item => item.close());
  });
}

$('#btnPreviewGameplay').addEventListener('click', launchGameplayPreview);
[
  'bgTileUrl',
  'bgTileScale',
  'bgTileOffsetY',
  'bgTilePortion',
  'bgTileFallback',
  'bgSkyTop',
  'bgSkyMid',
  'bgSkyBottom',
  'bgTime',
].forEach((id) => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('change', () => commitBackgroundFromFields({ pushToHistory: true }));
  el.addEventListener('input', () => commitBackgroundFromFields({ pushToHistory: false }));
});
const spawnHeightField = $('#spawnPosY');
if (spawnHeightField){
  ['change','blur','input'].forEach(evt => {
    spawnHeightField.addEventListener(evt, updateSpawnHeightFromField);
  });
}
const proximityScaleField = $('#proximityScale');
if (proximityScaleField){
  ['change','blur'].forEach((evt) => {
    proximityScaleField.addEventListener(evt, () => pushHistory());
  });
}

/*** Loaders for prefab/image ***/
$('#btnLoadPrefab').addEventListener('click',()=>{
  const inp=document.createElement('input');
  inp.type='file';
  inp.accept='application/json';
  inp.onchange=e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const parsed = JSON.parse(r.result);
        registerPrefab(parsed).catch(err=>{
          console.error('[map-editor] Failed to register prefab', err);
          alert('Invalid JSON: '+(err?.message||err));
        });
      }catch(err){
        alert('Invalid JSON: '+err.message);
      }
    };
    r.readAsText(f);
  };
  inp.click();
});
$('#btnLoadImage').addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';                  // <-- required
  inp.accept = 'image/*';
  inp.onchange = e => {
    const f = e.target.files[0];
    if (!f) return;
    registerImagePrefab(f);
  };
  inp.click();
});

/*** Init ***/
$('#gridSize').value = GRID_UNIT;
$('#gridSize').disabled = true;
$('#gridSize').title = `Grid locked to ${GRID_UNIT}px (configured)`;
populateRepositorySelect();
rebuildActiveLayerSelect();
rebuildLayerStack();
syncActiveLayerFields();
ensurePlayerSpawn();
refreshColliderList();
refreshInstanceList();
refreshDrumSkinList();
refreshBehaviorPanels();
syncBackgroundFields();
setEditorMode('layout');
ensureRenderLoop();

(async () => {
  try {
    await ensureConfiguredPrefabsLoaded();
    const manifest = await loadAssetManifest();
    populateBackgroundTileChoices(manifest);
    await importDrumSkinImagesFromAssetManifest();
    const initialId = layoutMeta.repositoryId || layoutMeta.areaId || DEFAULT_LAYOUT_META.areaId;
    await loadRepositoryMapById(initialId);
  } catch (error) {
    console.error('[map-editor] failed to load initial map', error);
  }
})();
</script>
</body>
</html>
