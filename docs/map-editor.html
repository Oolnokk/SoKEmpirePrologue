<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parallax Map Builder (Layered v15f)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <style>
    :root {
      --bg:#05070a; --panel:#10141a; --card:#151b22;
      --line:#27303c; --muted:#7f8ea3; --text:#e6edf3;
      --btn:#1a2330; --btnHi:#222d3c;
    }
    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      height:100%;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;
      padding-left:env(safe-area-inset-left);
      padding-right:env(safe-area-inset-right);
      padding-bottom:env(safe-area-inset-bottom);
    }

    #app {
      display:grid;
      grid-template-rows:40px auto 1fr;
      grid-template-columns:280px 1fr;
      grid-template-areas:
        "top top"
        "left bar"
        "left right";
      height:100vh;
      max-height:100vh;
      overflow:hidden;
    }

    header {
      grid-area:top;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 8px;
      background:var(--panel);
      border-bottom:1px solid var(--line);
      gap:6px;
      font-size:11px;
    }
    header h1 {
      margin:0;
      font-size:13px;
      font-weight:500;
      color:var(--muted);
    }

    button, select, input {
      background:var(--btn);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:10px;
      padding:4px 8px;
      font-size:16px; /* avoid mobile zoom */
    }
    button:hover { background:var(--btnHi); cursor:pointer; }

    #bar {
      grid-area:bar;
      padding:4px 8px;
      display:flex;
      align-items:center;
      gap:8px;
      background:#111821;
      border-bottom:1px solid var(--line);
      font-size:11px;
      color:var(--muted);
      flex-wrap:wrap;
    }

    #left {
      grid-area:left;
      padding:6px;
      border-right:1px solid var(--line);
      background:var(--panel);
      overflow:auto;
      font-size:11px;
    }

    #right {
      grid-area:right;
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:hidden;
    }

    .card {
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:6px;
      margin-bottom:4px;
    }

    .row {
      display:flex;
      gap:6px;
      margin-top:4px;
    }
    .row label {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:10px;
    }
    label span {
      color:var(--muted);
      font-size:10px;
    }

    #sceneWrap {
      flex:1;
      border-radius:14px;
      border:1px solid var(--line);
      background:transparent;
      overflow:hidden;
      position:relative;
      min-height:0;
    }
    #sceneCanvas {
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }
    #sceneCanvas.spawn-mode {
      cursor:crosshair;
    }

    #instList {
      max-height:160px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
    }
    .inst {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .inst span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .inst.active {
      background:rgba(120,150,255,0.16);
    }

    .pill {
      padding:1px 5px;
      border-radius:999px;
      background:#1c2330;
      color:var(--muted);
      font-size:9px;
    }
    .pill--spawn {
      margin-left:4px;
      background:#0f172a;
      color:#38bdf8;
    }
    .lock-pill {
      margin-left:4px;
      font-size:9px;
      color:#facc15;
    }

    #debugText {
      font-family:ui-monospace,Menlo,Consolas;
      font-size:9px;
      color:var(--muted);
      margin-top:4px;
      white-space:pre;
    }

    #exportStatus {
      font-size:9px;
      margin-top:2px;
    }
    #exportText {
      width:100%;
      height:80px;
      margin-top:4px;
      background:#020308;
      color:#9ca3af;
      border-radius:6px;
      border:1px solid #27303c;
      font-size:9px;
      padding:4px;
      font-family:ui-monospace,Menlo,Consolas;
      resize:vertical;
    }

    .hidden-select {
      display:none;
    }

    .layer-stack {
      display:flex;
      flex-direction:column-reverse; /* top tile = frontmost visually */
      gap:4px;
      margin-top:4px;
    }
    .layer-item {
      padding:4px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:#111823;
      font-size:9px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
    }
    .layer-item span { pointer-events:none; }
    .layer-item.active {
      background:#1f2933;
      border-color:#38bdf8;
      box-shadow:0 0 0 1px rgba(56,189,248,0.25);
    }
    .layer-item.dragging { opacity:0.4; }
    .layer-item-type {
      padding:1px 5px;
      border-radius:999px;
      font-size:8px;
      background:#0f172a;
      color:#9ca3af;
    }

    @media (max-width:900px) {
      #app {
        grid-template-rows:40px auto 40% 1fr;
        grid-template-columns:1fr;
        grid-template-areas:
          "top"
          "bar"
          "right"
          "left";
      }
      #left {
        border-right:none;
        border-top:1px solid var(--line);
      }
    }
  </style>
  <script src="./config/config.js"></script>
</head>
<body>
<div id="app">
  <header>
    <h1>Parallax Map Builder <span style="color:var(--muted)">路 layered v15f</span></h1>
    <div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center">
      <button id="btnLoadPrefab">Load Structure JSON</button>
      <button id="btnLoadImage">Load Image</button>
      <select id="mapRepoSelect" aria-label="Repository Map"></select>
      <button id="btnLoadMap">Load Map</button>
      <button id="btnUndo">Undo</button>
      <button id="btnExportMap">Download Area JSON</button>
    </div>
  </header>

  <div id="bar">
    <span>
      Cam:
      <input id="camSlider" type="range" min="-4000" max="4000" value="0" style="width:120px">
      <input id="camNum" type="number" value="0" style="width:70px">
    </span>
    <span>
      Zoom:
      <input id="zoomSlider" type="range" min="0.5" max="2.0" step="0.05" value="1" style="width:120px">
      <input id="zoomNum" type="number" min="0.5" max="2.0" step="0.05" value="1" style="width:60px">
    </span>
    <label style="display:flex;align-items:center;gap:4px">
      <input id="chkDebug" type="checkbox">
      <span>Debug</span>
    </label>
    <button id="btnAddParallaxLayer">+ Parallax Layer</button>
    <span class="pill">
      Tap layer tiles to select 路 drag to reorder (top = front).
    </span>
  </div>

  <aside id="left">
    <!-- Instances -->
    <div class="card">
      <strong>Instances (active layer only)</strong>
      <div id="instList"></div>
      <div style="display:flex;margin-top:6px">
        <button id="btnPlacePlayerSpawn" style="flex:1">Place Player Spawn</button>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Only instances on the active layer can be picked, dragged or jittered. Use the button above and then click the preview to set the spawn (snaps to the grid unit).
      </small>
    </div>

    <!-- Selected instance -->
    <div class="card">
      <strong>Selected instance</strong>
      <div class="row">
        <label><span>ID</span><input id="instId" readonly></label>
        <label><span>Prefab</span><select id="instPrefab"></select></label>
      </div>
      <div class="row">
        <label>
          <span>Layer</span>
          <select id="instLayer" class="hidden-select"></select>
        </label>
        <label>
          <span>Display X (world)</span>
          <input id="instX" type="number">
        </label>
      </div>
      <div class="row">
        <label style="flex:none;display:flex;align-items:center;gap:4px">
          <input id="instLocked" type="checkbox">
          <span>Lock position</span>
        </label>
        <label><span>Grid (px)</span><input id="gridSize" type="number" value="10"></label>
        <label><span>Delete</span><button id="btnDeleteInst">Remove</button></label>
      </div>
      <div class="row">
        <label><span>Scale X</span><input id="instScaleX" type="number" step="0.05"></label>
        <label><span>Scale Y</span><input id="instScaleY" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>Offset Y (from ground)</span><input id="instOffY" type="number" step="1"></label>
        <label><span>Rot (deg)</span><input id="instRot" type="number" step="1"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateInst">Duplicate</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Duplicate copies all settings; lock blocks drag/jitter, not manual edits.
      </small>
    </div>

    <!-- Prefab library -->
    <div class="card">
      <strong>Prefab Library</strong>
      <div class="row">
        <label>
          <span>Prefab</span>
          <select id="libPrefab"></select>
        </label>
        <label>
          <span>Count</span>
          <input id="libCount" type="number" min="1" max="50" value="8">
        </label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnPlaceRow">Place row on active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Structures & uploads land here; stamp rows onto the active layer.
      </small>
    </div>

    <!-- Layers -->
    <div class="card">
      <strong>Layers</strong>
      <select id="activeLayerSelect" class="hidden-select"></select>
      <div id="layerStack" class="layer-stack"></div>
      <div class="row">
        <label><span>parallax</span><input id="layerParallax" type="number" step="0.05"></label>
        <label><span>y offset (from ground)</span><input id="layerYOffset" type="number"></label>
      </div>
      <div class="row">
        <label><span>separation</span><input id="layerSep" type="number"></label>
        <label><span>scale</span><input id="layerScale" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateLayer">Duplicate active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Drag tiles to change draw order. Top tile renders in front.
      </small>
    </div>

    <!-- Jitter -->
    <div class="card">
      <strong>Jitter (active layer, unlocked only)</strong>
      <div class="row">
        <label><span>Pos range (px)</span><input id="jitterRange" type="number" value="40"></label>
        <label><span>Scale range (卤)</span><input id="jitterScaleRange" type="number" step="0.05" value="0.15"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnJitter">Apply jitter</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Randomizes nudgeX + scaleX/Y for unlocked instances on the active layer.
      </small>
    </div>

    <!-- Global / Export -->
    <div class="card">
      <strong>Global & Export</strong>
      <div class="row">
        <label>
          <span>Ground from bottom (px)</span>
          <input id="groundOffset" type="number" value="140">
        </label>
      </div>
      <div id="exportStatus"></div>
      <textarea id="exportText" readonly
        placeholder="Layout JSON appears here when you export."></textarea>
      <small style="color:var(--muted);display:block;margin-top:4px">
        If the new tab is blocked, long-press here to copy the JSON.
      </small>
    </div>

    <div id="debugText"></div>
  </aside>

  <section id="right">
    <div class="card">
      <strong>Preview</strong>
      <span style="font-size:10px;color:var(--muted);margin-left:6px">
        Screen-space KF 路 select an instance & toggle Debug to see rays.
      </span>
    </div>
    <div id="sceneWrap"><canvas id="sceneCanvas"></canvas></div>
  </section>
</div>

<script>
const $ = s => document.querySelector(s);
const MAP_CONFIG = window.CONFIG?.map || {};
const DEFAULT_CUSTOM_ENTRY = { id: 'custom_area', label: 'Empty Layout', path: null, areaName: 'Custom Area' };
const REPOSITORY_LAYOUTS = (() => {
  const normalized = Array.isArray(MAP_CONFIG.layouts) && MAP_CONFIG.layouts.length
    ? MAP_CONFIG.layouts.map((entry) => ({
        id: entry.id || entry.areaId || entry.path || 'custom_area',
        label: entry.label || entry.areaName || entry.id || 'Map',
        path: entry.path || null,
        areaName: entry.areaName || entry.label || entry.id || 'Map',
      }))
    : [];
  const seen = new Set();
  const result = [];
  const add = (entry) => {
    if (entry && entry.id && !seen.has(entry.id)) {
      result.push(entry);
      seen.add(entry.id);
    }
  };
  add(DEFAULT_CUSTOM_ENTRY);
  normalized.forEach(add);
  return result;
})();
const DEFAULT_LAYOUT_META = {
  areaId: REPOSITORY_LAYOUTS[0]?.id || 'custom_area',
  areaName: REPOSITORY_LAYOUTS[0]?.areaName || REPOSITORY_LAYOUTS[0]?.label || 'Custom Area',
  sourcePath: REPOSITORY_LAYOUTS[0]?.path || null,
  repositoryId: REPOSITORY_LAYOUTS[0]?.id || null,
};
const GRID_UNIT = (Number.isFinite(MAP_CONFIG.gridUnit) && MAP_CONFIG.gridUnit > 0) ? MAP_CONFIG.gridUnit : 10;
const SPAWN_LAYER_ID = MAP_CONFIG.spawnLayerId || 'gameplay';
let runtimeModulePromise = null;

function getRuntimeModule(){
  if (!runtimeModulePromise){
    runtimeModulePromise = import('./js/vendor/map-runtime.js');
  }
  return runtimeModulePromise;
}

function clamp(v,a,b){ return v<a?a:v>b?b:v; }
function lerp(a,b,t){ return a + (b-a)*t; }
function rad(d){ return d * Math.PI/180; }

/*** Undo history ***/
const historyStack = [];
const HISTORY_LIMIT = 50;
let isRestoring = false;
function snapshotState(){
  return JSON.parse(JSON.stringify({
    layers,
    instances,
    cameraX,
    zoom,
    groundOffset: getGroundOffset(),
    activeLayerId,
    nextInstId,
    meta: layoutMeta,
  }));
}
function pushHistory(){
  if(isRestoring) return;
  historyStack.push(snapshotState());
  if(historyStack.length > HISTORY_LIMIT) historyStack.shift();
}
function restoreState(state){
  if(!state) return;
  isRestoring = true;
  exitSpawnPlacement();
  layoutMeta = { ...DEFAULT_LAYOUT_META, ...(state.meta || {}) };
  layers = Array.isArray(state.layers) ? state.layers : createDefaultLayers();
  instances.length = 0;
  (state.instances||[]).forEach((inst) => {
    const clone = JSON.parse(JSON.stringify(inst));
    clone.tags = Array.isArray(clone.tags) ? clone.tags.map((tag) => String(tag)) : [];
    instances.push(clone);
  });
  cameraX = state.cameraX || 0;
  zoom = state.zoom || 1;
  $('#groundOffset').value = state.groundOffset || 140;
  activeLayerId = state.activeLayerId || (layers[0] && layers[0].id) || activeLayerId;
  const maxId = instances.reduce((max, inst) => {
    const num = Number(inst.id);
    return Number.isFinite(num) ? Math.max(max, num) : max;
  }, 0);
  const nextFromState = Number.isFinite(state.nextInstId) ? state.nextInstId : 1;
  nextInstId = Math.max(nextFromState, maxId + 1, 1);
  ensurePlayerSpawn();
  resetSlotCounters();
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
  refreshInstanceList();
  setCameraX(cameraX);
  setZoom(zoom);
  isRestoring = false;
}
function undo(){
  const st = historyStack.pop();
  if(st) restoreState(st);
}

/*** Easing + unified screen-space KF ***/
function ease01(mode, x){
  x = clamp(x,0,1);
  if (mode === 'smoothstep') return x*x*(3 - 2*x);
  if (mode === 'quadInOut')  return x < 0.5
      ? 2*x*x
      : 1 - Math.pow(-2*x + 2, 2) / 2;
  return x; // linear
}

/*
  Step 1: computeTFromDx(kfMeta, dxScreen)

    reticleX = center of screen
    dxScreen = rootScreenX - reticleX    (screen pixels)

    radiusPx = kfMeta.radiusPx || kfMeta.radius || 600
    t        = clamp(-dxScreen / radiusPx, -1, 1)

  This is done ONCE per structure instance (root).
*/
function computeTFromDx(kfMeta, dxScreen){
  const baseRadius =
    (kfMeta && Number.isFinite(kfMeta.radiusPx) && kfMeta.radiusPx > 0) ? kfMeta.radiusPx :
    (kfMeta && Number.isFinite(kfMeta.radius)   && kfMeta.radius   > 0) ? kfMeta.radius   :
    600;
  const radiusPx = Math.max(1, baseRadius);
  const rawT = -dxScreen / radiusPx;
  return {
    t: clamp(rawT, -1, 1),
    radiusPx
  };
}

/*
  Step 2: evalKfPose(kf, t)

  Given a shared t in [-1,1], lerp between left/center/right for this part.
  This matches the "single t, many parts" mental model.
*/
function evalKfPose(kf, t){
  if(!kf){
    return {
      t,
      dx:0, dy:0,
      scaleX:1,
      rotZdeg:0,
      translateSpace:'screen',
      order:'scaleThenRotate'
    };
  }

  const ease = kf.ease || 'smoothstep';
  const L = kf.left   || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const C = kf.center || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const R = kf.right  || {dx:0,dy:0,scaleX:1,rotZdeg:0};

  let from, to, u;
  if(t <= 0){
    // -1..0 : LEFT -> CENTER
    u = ease01(ease, t + 1); // [-1,0] -> [0,1]
    from = L; to = C;
  }else{
    // 0..1 : CENTER -> RIGHT
    u = ease01(ease, t);     // [0,1] -> [0,1]
    from = C; to = R;
  }

  return {
    t,
    dx:      lerp(from.dx      || 0, to.dx      || 0, u),
    dy:      lerp(from.dy      || 0, to.dy      || 0, u),
    scaleX:  lerp(from.scaleX ?? 1, to.scaleX ?? 1, u),
    rotZdeg: lerp(from.rotZdeg || 0, to.rotZdeg || 0, u),
    translateSpace: kf.translateSpace || 'screen',
    order:          kf.transformOrder || 'scaleThenRotate'
  };
}

/*** Apply a pose into current ctx, respecting translateSpace/order */
function applyPose(ctx, pose){
  const dx = pose.dx || 0;
  const dy = pose.dy || 0;
  const sx = (pose.scaleX != null ? pose.scaleX : 1);
  const rot = pose.rotZdeg || 0;
  const space = pose.translateSpace || 'screen';
  const order = pose.order || 'scaleThenRotate';

  // "screen": offsets in current (screen) space, before local scaling/rot.
  if(space === 'screen'){
    ctx.translate(dx, dy);
  }

  if(order === 'scaleThenRotate'){
    if(sx !== 1) ctx.scale(sx, 1);
    if(rot) ctx.rotate(rad(rot));
  }else{
    if(rot) ctx.rotate(rad(rot));
    if(sx !== 1) ctx.scale(sx, 1);
  }

  // "local": offsets after local transform (move in the part's space)
  if(space === 'local'){
    ctx.translate(dx, dy);
  }
}

/*** Anchors ***/
function computeAnchor(t){
  const w = t.w || 100;
  const h = t.h || 100;
  if(t.pivot === 'bottom') return {ax:w*0.5, ay:h};
  if(t.pivot === 'top')    return {ax:w*0.5, ay:0};
  if(t.pivot === 'center') return {ax:w*0.5, ay:h*0.5};
  const ax = (Number.isFinite(t.anchorXPct)? t.anchorXPct : 50) * 0.01 * w;
  const ay = (Number.isFinite(t.anchorYPct)? t.anchorYPct : 100) * 0.01 * h;
  return {ax, ay};
}

/*** Layers ***/
function createDefaultLayers(){
  return [
    { id:"bg1",  name:"Parallax 1", type:"parallax",  parallax:0.2, yOffset:-120, sep:220, scale:0.7 },
    { id:"bg2",  name:"Parallax 2", type:"parallax",  parallax:0.4, yOffset:-90,  sep:220, scale:0.8 },
    { id:"gameplay", name:"Gameplay", type:"gameplay", parallax:1.0, yOffset:-20, sep:180, scale:1.0 },
    { id:"fg1",  name:"Foreground 1", type:"foreground", parallax:1.1, yOffset:-10, sep:180, scale:1.05 },
    { id:"fg2",  name:"Foreground 2", type:"foreground", parallax:1.2, yOffset:0,   sep:180, scale:1.1 }
  ];
}
let layers = createDefaultLayers();
let activeLayerId = SPAWN_LAYER_ID && layers.some((l) => l.id === SPAWN_LAYER_ID) ? SPAWN_LAYER_ID : 'gameplay';
let layoutMeta = { ...DEFAULT_LAYOUT_META };
function getParallaxLayerCount(){ return layers.filter(l=>l.type==="parallax").length; }
function findLayer(id){ return layers.find(l=>l.id===id) || null; }

/*** Prefabs & Instances ***/
const imageCache = new Map();
const prefabs = {};
let selectedPrefabId = null;
let nextInstId = 1;
const instances = [];
let selectedInstId = null;
const nextSlotByLayer = {};
let playerSpawnInstId = null;
let spawnPlacementMode = false;

function resetSlotCounters(){
  for (const key of Object.keys(nextSlotByLayer)) delete nextSlotByLayer[key];
  for (const inst of instances){
    const layerId = inst.layerId || '__unassigned__';
    const slot = Number.isFinite(inst.slot) ? inst.slot : 0;
    const current = nextSlotByLayer[layerId] ?? 0;
    nextSlotByLayer[layerId] = Math.max(current, slot + 1);
  }
}

function isPlayerSpawn(inst){
  return Array.isArray(inst?.tags) && inst.tags.includes('spawn:player');
}

function getDefaultSpawnLayerId(){
  if (findLayer(SPAWN_LAYER_ID)) return SPAWN_LAYER_ID;
  const gameplay = layers.find((layer) => layer.type === 'gameplay');
  return gameplay ? gameplay.id : (layers[0]?.id || 'gameplay');
}

function ensurePlayerSpawn(){
  let spawn = instances.find(isPlayerSpawn);
  const spawnLayerId = getDefaultSpawnLayerId();
  if (!spawn){
    spawn = {
      id: nextInstId++,
      prefabId: 'spawn_player',
      layerId: spawnLayerId,
      slot: 0,
      nudgeX: 0,
      locked: true,
      scaleX: 1,
      scaleY: 1,
      offsetY: 0,
      rot: 0,
      x: 0,
      tags: ['spawn:player'],
    };
    instances.push(spawn);
  } else {
    if (!Array.isArray(spawn.tags)) spawn.tags = [];
    if (!spawn.tags.includes('spawn:player')) spawn.tags.push('spawn:player');
    spawn.layerId = spawn.layerId || spawnLayerId;
  }
  playerSpawnInstId = spawn.id;
  return spawn;
}

function getPlayerSpawnInstance(){
  if (playerSpawnInstId != null){
    const inst = instances.find((item) => item.id === playerSpawnInstId);
    if (inst) return inst;
  }
  const spawn = instances.find(isPlayerSpawn) || null;
  if (spawn) playerSpawnInstId = spawn.id;
  return spawn;
}

function exitSpawnPlacement(){
  spawnPlacementMode = false;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('spawn-mode');
}

function toNumber(value, fallback){
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function sanitizeLayout(layout, context = {}){
  const clone = layout && typeof layout === 'object' ? JSON.parse(JSON.stringify(layout)) : {};
  clone.layers = Array.isArray(clone.layers) && clone.layers.length ? clone.layers : createDefaultLayers();
  clone.instances = Array.isArray(clone.instances) ? clone.instances : [];
  clone.cameraX = toNumber(clone.cameraX ?? clone.cameraStartX, 0);
  clone.zoom = toNumber(clone.zoom ?? clone.zoomStart, 1);
  clone.groundOffset = toNumber(clone.groundOffset, 140);
  clone.activeLayerId = clone.activeLayerId || clone.meta?.activeLayerId || (clone.layers[0]?.id) || getDefaultSpawnLayerId();
  clone.instances = clone.instances.map((inst) => {
    const c = JSON.parse(JSON.stringify(inst));
    c.tags = Array.isArray(c.tags) ? c.tags.map((tag) => String(tag)) : [];
    return c;
  });
  clone.meta = {
    areaId: clone.meta?.areaId || clone.areaId || clone.id || context.areaId || DEFAULT_LAYOUT_META.areaId,
    areaName: clone.meta?.areaName || clone.areaName || clone.name || context.areaName || DEFAULT_LAYOUT_META.areaName,
    sourcePath: context.sourcePath ?? clone.meta?.sourcePath ?? null,
    repositoryId: context.repositoryId ?? clone.meta?.repositoryId ?? null,
  };
  return clone;
}

function convertAreaToLayout(area, context = {}){
  const layersList = Array.isArray(area.layers) && area.layers.length
    ? area.layers.map((layer, index) => ({
        id: layer.id || `layer_${index}`,
        name: layer.name || `Layer ${index + 1}`,
        type: layer.type || 'gameplay',
        parallax: toNumber(layer.parallaxSpeed ?? layer.parallax, 1),
        scale: toNumber(layer.scale, 1),
        yOffset: toNumber(layer.offsetY ?? layer.yOffset, 0),
        sep: toNumber(layer.separation ?? layer.sep, 0),
      }))
    : createDefaultLayers();

  const instancesList = Array.isArray(area.instances) ? area.instances : [];
  let fallbackId = 1;
  const layoutInstances = instancesList.map((inst) => {
    const original = (inst.meta && typeof inst.meta.original === 'object') ? inst.meta.original : {};
    const tags = Array.isArray(inst.tags) ? inst.tags.map((tag) => String(tag))
      : Array.isArray(original.tags) ? original.tags.map((tag) => String(tag)) : [];
    const layoutInst = {
      id: inst.id ?? original.id ?? fallbackId++,
      prefabId: inst.prefabId ?? original.prefabId ?? 'unknown_prefab',
      layerId: inst.layerId ?? original.layerId ?? getDefaultSpawnLayerId(),
      slot: toNumber(original.slot, 0),
      nudgeX: toNumber(original.nudgeX, 0),
      locked: original.locked ?? !!inst.locked,
      scaleX: toNumber(original.scaleX, inst.scale?.x ?? 1),
      scaleY: toNumber(original.scaleY, inst.scale?.y ?? inst.scale?.x ?? 1),
      offsetY: toNumber(original.offsetY, -(toNumber(inst.position?.y, 0))),
      rot: toNumber(original.rot, toNumber(inst.rotationDeg, 0)),
      tags,
    };
    const originalX = toNumber(original.x, NaN);
    const areaX = toNumber(inst.position?.x, NaN);
    if (Number.isFinite(originalX)) layoutInst.x = originalX;
    else if (Number.isFinite(areaX)) layoutInst.x = areaX;
    return layoutInst;
  });

  const layout = {
    layers: layersList,
    instances: layoutInstances,
    cameraX: toNumber(area.camera?.startX, 0),
    zoom: toNumber(area.camera?.startZoom, 1),
    groundOffset: toNumber(area.ground?.offset, 140),
    activeLayerId: area.meta?.activeLayerId || area.meta?.original?.activeLayerId || layersList[0]?.id || getDefaultSpawnLayerId(),
    meta: {
      areaId: area.id || context.areaId || DEFAULT_LAYOUT_META.areaId,
      areaName: area.name || context.areaName || DEFAULT_LAYOUT_META.areaName,
      sourcePath: context.sourcePath ?? null,
      repositoryId: context.repositoryId ?? null,
    },
  };

  return sanitizeLayout(layout, layout.meta);
}

function interpretIncomingLayout(data, context = {}){
  if (data && typeof data === 'object'){
    if (data.camera || (Array.isArray(data.instances) && data.instances.some((inst) => inst && typeof inst === 'object' && (inst.position || inst.scale)))){
      return convertAreaToLayout(data, context);
    }
    return sanitizeLayout(data, context);
  }
  return sanitizeLayout({}, context);
}

function getRepositoryEntry(mapId){
  return REPOSITORY_LAYOUTS.find((entry) => entry.id === mapId) || null;
}

async function loadRepositoryMapById(mapId){
  const entry = getRepositoryEntry(mapId) || getRepositoryEntry(DEFAULT_LAYOUT_META.areaId);
  const context = {
    areaId: entry?.id || DEFAULT_LAYOUT_META.areaId,
    areaName: entry?.areaName || entry?.label || DEFAULT_LAYOUT_META.areaName,
    sourcePath: entry?.path || null,
    repositoryId: entry?.id || null,
  };

  if (!entry?.path){
    restoreState(interpretIncomingLayout({}, context));
    historyStack.length = 0;
    pushHistory();
    return;
  }

  try {
    const response = await fetch(entry.path, { cache: 'no-cache' });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const json = await response.json();
    restoreState(interpretIncomingLayout(json, context));
  } catch (error) {
    console.error('[map-editor] failed to load map from repository', error);
    restoreState(interpretIncomingLayout({}, context));
    alert(`Failed to load map: ${error.message}. Loaded empty layout instead.`);
  }
  historyStack.length = 0;
  pushHistory();
  const select = $('#mapRepoSelect');
  if (select) select.value = context.repositoryId || select.value;
}

function populateRepositorySelect(){
  const select = $('#mapRepoSelect');
  if (!select) return;
  select.innerHTML = '';
  REPOSITORY_LAYOUTS.forEach((entry) => {
    const opt = document.createElement('option');
    opt.value = entry.id;
    opt.textContent = entry.label;
    select.appendChild(opt);
  });
  const targetId = layoutMeta.repositoryId || DEFAULT_LAYOUT_META.repositoryId;
  if (targetId) select.value = targetId;
}

let cameraX = 0;
let zoom = 1;
let debugOverlay = false;

function getGroundOffset(){
  return parseFloat($('#groundOffset').value) || 140;
}

/*** Layer UI & stack ***/
function rebuildActiveLayerSelect(){
  const sel = $('#activeLayerSelect');
  const instLayerSel = $('#instLayer');
  sel.innerHTML = '';
  instLayerSel.innerHTML = '';
  layers.forEach(layer=>{
    const o = document.createElement('option');
    o.value = layer.id; o.textContent = layer.name;
    sel.appendChild(o);
    const o2 = document.createElement('option');
    o2.value = layer.id; o2.textContent = layer.name;
    instLayerSel.appendChild(o2);
  });
  if(!findLayer(activeLayerId) && layers.length){
    activeLayerId = layers[0].id;
  }
  sel.value = activeLayerId;
}
function rebuildLayerStack(){
  const stack = $('#layerStack');
  stack.innerHTML = '';
  layers.forEach(layer=>{
    const div = document.createElement('div');
    div.className = 'layer-item' + (layer.id===activeLayerId ? ' active' : '');
    div.draggable = true;
    div.dataset.layerId = layer.id;
    div.innerHTML = `
      <span>${layer.name}</span>
      <span class="layer-item-type">${layer.type}</span>
    `;
    div.addEventListener('click', () => setActiveLayer(layer.id));
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', layer.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
    });
    div.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    div.addEventListener('drop', e => {
      e.preventDefault();
      const srcId = e.dataTransfer.getData('text/plain');
      const dstId = layer.id;
      if(!srcId || srcId === dstId) return;
      pushHistory();
      const srcIndex = layers.findIndex(l=>l.id===srcId);
      const dstIndex = layers.findIndex(l=>l.id===dstId);
      if(srcIndex<0 || dstIndex<0) return;
      const [moved] = layers.splice(srcIndex,1);
      const insertIndex = srcIndex < dstIndex ? dstIndex-1 : dstIndex;
      layers.splice(insertIndex,0,moved);
      rebuildActiveLayerSelect();
      rebuildLayerStack();
    });
    stack.appendChild(div);
  });
}
function syncActiveLayerFields(){
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  $('#layerParallax').value = layer.parallax;
  $('#layerYOffset').value = layer.yOffset;
  $('#layerSep').value = layer.sep;
  $('#layerScale').value = layer.scale;
  rebuildLayerStack();
}
function setActiveLayer(id){
  if(!findLayer(id)) return;
  activeLayerId = id;
  $('#activeLayerSelect').value = id;
  syncActiveLayerFields();
  const first = instances.find(i=>i.layerId === activeLayerId);
  selectedInstId = first ? first.id : null;
  refreshInstanceList();
}
['layerParallax','layerYOffset','layerSep','layerScale'].forEach(id=>{
  $(`#${id}`).addEventListener('input', e=>{
    const layer = findLayer(activeLayerId);
    if(!layer) return;
    const v = parseFloat(e.target.value);
    if(!Number.isFinite(v)) return;
    pushHistory();
    if(id==='layerParallax') layer.parallax=v;
    if(id==='layerYOffset') layer.yOffset=v;
    if(id==='layerSep')      layer.sep=v;
    if(id==='layerScale')    layer.scale=v;
  });
});

/*** Duplicate layer ***/
$('#btnDuplicateLayer').addEventListener('click',()=>{
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  pushHistory();
  let baseId = layer.id + '_copy';
  let n = 1;
  while(findLayer(baseId)) baseId = layer.id + '_copy' + (n++);
  const newLayer = JSON.parse(JSON.stringify(layer));
  newLayer.id = baseId;
  newLayer.name = layer.name + ' copy';
  const idx = layers.indexOf(layer);
  layers.splice(idx+1,0,newLayer);
  const clones = instances
    .filter(inst=>inst.layerId===layer.id)
    .map(inst=>{
      const c = JSON.parse(JSON.stringify(inst));
      c.id = nextInstId++;
      c.layerId = newLayer.id;
      return c;
    });
  instances.push(...clones);
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  activeLayerId = newLayer.id;
  syncActiveLayerFields();
  refreshInstanceList();
});

/*** Slots & baseX ***/
function computeLayerSlotStats(){
  const stats = {};
  layers.forEach(l=>stats[l.id]={min:null,max:null});
  instances.forEach(inst=>{
    const s = stats[inst.layerId]; if(!s) return;
    const sl = inst.slot ?? 0;
    if(s.min===null || sl<s.min) s.min=sl;
    if(s.max===null || sl>s.max) s.max=sl;
  });
  return stats;
}
function baseXFor(inst, stats){
  if (Number.isFinite(inst?.x)) return inst.x;
  const layer = findLayer(inst.layerId);
  if(!layer) return 0;
  const sep = layer.sep || 180;
  const slot = inst.slot ?? 0;
  const s = stats[inst.layerId];
  let center = slot;
  if(s && s.min!==null) center = (s.min + s.max)/2;
  return (slot - center)*sep + (inst.nudgeX || 0);
}

/*** Image loading ***/
function loadImage(url){
  return new Promise(res=>{
    if(!url) return res(null);
    if(imageCache.has(url)) return res(imageCache.get(url));
    const img=new Image();
    img.crossOrigin='anonymous';
    img.onload=()=>{ imageCache.set(url,img); res(img); };
    img.onerror=()=>res(null);
    img.src=url;
  });
}

/*** Prefabs ***/
async function registerPrefab(obj){
  if(!obj || !obj.structureId || !Array.isArray(obj.parts)){
    alert('Invalid structure JSON'); return;
  }
  prefabs[obj.structureId]=obj;
  if(!selectedPrefabId) selectedPrefabId=obj.structureId;
  for(const part of obj.parts){
    const t=part.propTemplate||{};
    if(t.url) await loadImage(t.url);
  }
  rebuildPrefabSelect();
  if(!instances.length && activeLayerId){
    pushHistory();
    addRowOnLayer(activeLayerId,8,obj.structureId);
    refreshInstanceList();
  }
}
function registerImagePrefab(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.onload=()=>{
    const base=(file.name||'img').replace(/\.[^/.]+$/,'')||'img';
    let id=`img_${base}`, c=1;
    while(prefabs[id]) id=`img_${base}_${c++}`;
    prefabs[id]={
      structureId:id,
      isImage:true,
      parts:[{
        name:id,
        layer:'near',
        relX:0,
        relY:0,
        propTemplate:{
          id,
          w:img.width,
          h:img.height,
          url:url,
          pivot:'bottom',
          anchorXPct:50,
          anchorYPct:100
        }
      }]
    };
    imageCache.set(url,img);
    selectedPrefabId=id;
    rebuildPrefabSelect();
    refreshLibrarySelect();
  };
  img.onerror=()=>alert('Failed to load image');
  img.src=url;
}
function rebuildPrefabSelect(){
  const instSel=$('#instPrefab');
  instSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    instSel.appendChild(o);
  });
  if(selectedPrefabId) instSel.value=selectedPrefabId;
  refreshLibrarySelect();
}
function refreshLibrarySelect(){
  const libSel=$('#libPrefab');
  libSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    libSel.appendChild(o);
  });
  if(selectedPrefabId) libSel.value=selectedPrefabId;
}

/*** Instances ***/
function allocSlot(layerId){
  const n=nextSlotByLayer[layerId] ?? 0;
  nextSlotByLayer[layerId]=n+1;
  return n;
}
function makeInstance(layerId,prefabId){
  return {
    id:nextInstId++,
    prefabId,
    layerId,
    slot:allocSlot(layerId),
    nudgeX:0,
    locked:false,
    scaleX:1,
    scaleY:1,
    offsetY:0,
    rot:0,
    tags:[],
  };
}
function addInstance(layerId,prefabId){
  const layer=findLayer(layerId);
  if(!layer) return;
  const pid=prefabId || selectedPrefabId || Object.keys(prefabs)[0];
  if(!prefabs[pid]) return;
  const inst=makeInstance(layerId,pid);
  instances.push(inst);
  if(layerId===activeLayerId) selectedInstId=inst.id;
}
function addRowOnLayer(layerId,count,prefabId){
  for(let i=0;i<count;i++) addInstance(layerId,prefabId);
}
function getSelectedInstance(){
  return instances.find(i=>i.id===selectedInstId) || null;
}
function deleteSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be removed. Use the placement button to reposition it.');
    return;
  }
  pushHistory();
  const idx=instances.findIndex(i=>i.id===inst.id);
  if(idx>=0) instances.splice(idx,1);
  selectedInstId=null;
  refreshInstanceList();
}
function duplicateSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be duplicated.');
    return;
  }
  pushHistory();
  const dup = JSON.parse(JSON.stringify(inst));
  dup.id = nextInstId++;
  dup.slot = (inst.slot ?? 0) + 1;
  instances.push(dup);
  selectedInstId = dup.id;
  refreshInstanceList();
}
function refreshInstanceList(){
  const stats=computeLayerSlotStats();
  const list=$('#instList');
  list.innerHTML='';
  const visible=instances.filter(i=>i.layerId===activeLayerId);
  for(const inst of visible){
    const layer=findLayer(inst.layerId);
    if(!layer) continue;
    const div=document.createElement('div');
    div.className='inst'+(inst.id===selectedInstId?' active':'');
    const span=document.createElement('span');
    const x=baseXFor(inst,stats).toFixed(1);
    span.textContent=`${inst.id} 路 ${inst.prefabId} 路 x=${x}`;
    if(inst.locked){
      const lp=document.createElement('span');
      lp.className='lock-pill';
      lp.textContent='';
      span.appendChild(lp);
    }
    if(isPlayerSpawn(inst)){
      const spawnPill=document.createElement('span');
      spawnPill.className='pill pill--spawn';
      spawnPill.textContent='Player Spawn';
      span.appendChild(spawnPill);
    }
    const pill=document.createElement('span');
    pill.className='pill';
    pill.textContent=layer.name;
    div.appendChild(span);
    div.appendChild(pill);
    div.onclick=()=>{ selectedInstId=inst.id; fillInstEditor(); refreshInstanceList(); };
    list.appendChild(div);
  }
  fillInstEditor();
}
function fillInstEditor(){
  const stats=computeLayerSlotStats();
  const inst=getSelectedInstance();
  if(!inst || inst.layerId!==activeLayerId){
    $('#instId').value='';
    $('#instX').value='';
    $('#instLayer').value=activeLayerId||'';
    $('#instLocked').checked=false;
    $('#instScaleX').value='';
    $('#instScaleY').value='';
    $('#instOffY').value='';
    $('#instRot').value='';
    return;
  }
  $('#instId').value=inst.id;
  $('#instPrefab').value=inst.prefabId;
  $('#instLayer').value=inst.layerId;
  $('#instX').value=baseXFor(inst,stats).toFixed(1);
  $('#instLocked').checked=!!inst.locked;
  $('#instScaleX').value=inst.scaleX;
  $('#instScaleY').value=inst.scaleY;
  $('#instOffY').value=inst.offsetY;
  $('#instRot').value=inst.rot;
}

/*** Instance editor bindings ***/
function updateSelectedInstanceFromFields(){
  const inst = getSelectedInstance();
  if(!inst || inst.layerId !== activeLayerId) return;

  let changed = false;

  const pid = $('#instPrefab').value;
  if(prefabs[pid] && pid !== inst.prefabId){
    if(!changed) pushHistory();
    changed = true;
    inst.prefabId = pid;
  }

  const newLayerId = $('#instLayer').value;
  if(findLayer(newLayerId) && newLayerId !== inst.layerId){
    if(!changed) pushHistory();
    changed = true;
    inst.layerId = newLayerId;
  }

  const locked = $('#instLocked').checked;
  if(locked !== !!inst.locked){
    if(!changed) pushHistory();
    changed = true;
    inst.locked = locked;
  }

  const sx = parseFloat($('#instScaleX').value);
  if(Number.isFinite(sx) && sx !== inst.scaleX){
    if(!changed) pushHistory();
    changed = true;
    inst.scaleX = Math.max(0.05, sx);
  }

  const sy = parseFloat($('#instScaleY').value);
  if(Number.isFinite(sy) && sy !== inst.scaleY){
    if(!changed) pushHistory();
    changed = true;
    inst.scaleY = Math.max(0.05, sy);
  }

  const offY = parseFloat($('#instOffY').value);
  if(Number.isFinite(offY) && offY !== inst.offsetY){
    if(!changed) pushHistory();
    changed = true;
    inst.offsetY = offY;
  }

  const rot = parseFloat($('#instRot').value);
  if(Number.isFinite(rot) && rot !== inst.rot){
    if(!changed) pushHistory();
    changed = true;
    inst.rot = rot;
  }

  const xVal = parseFloat($('#instX').value);
  if(Number.isFinite(xVal)){
    const grid = GRID_UNIT || 0;
    let target = xVal;
    if(grid > 0){
      target = Math.round(target / grid) * grid;
      $('#instX').value = target.toFixed(1);
    }
    if(isPlayerSpawn(inst)){
      if(!changed) pushHistory();
      changed = true;
      inst.x = target;
      inst.nudgeX = 0;
      inst.slot = 0;
    } else {
      const stats = computeLayerSlotStats();
      const layerStats = stats[inst.layerId];
      const layer = findLayer(inst.layerId);
      if(layer){
        const sep = layer.sep || 180;
        const slot = inst.slot ?? 0;
        let center = slot;
        if(layerStats && layerStats.min !== null){
          center = (layerStats.min + layerStats.max) / 2;
        }
        const newNudge = target - (slot - center) * sep;
        if(newNudge !== inst.nudgeX){
          if(!changed) pushHistory();
          changed = true;
          inst.nudgeX = newNudge;
        }
      }
    }
  }

  if(changed){
    refreshInstanceList();
  }
}

['instPrefab','instLayer','instLocked',
 'instScaleX','instScaleY','instOffY','instRot','instX'
].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedInstanceFromFields);
  el.addEventListener('blur', updateSelectedInstanceFromFields);
});

/*** Camera & Zoom ***/
function setCameraX(v){
  cameraX=clamp(v,-4000,4000);
  $('#camSlider').value=cameraX;
  $('#camNum').value=cameraX;
}
function setZoom(v){
  zoom=clamp(v,0.5,2.0);
  $('#zoomSlider').value=zoom;
  $('#zoomNum').value=zoom.toFixed(2);
}
$('#camSlider').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#camNum').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#zoomSlider').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));
$('#zoomNum').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));

/*** Canvas & Render ***/
const canvas=document.getElementById('sceneCanvas');
const ctx=canvas.getContext('2d',{alpha:true,desynchronized:true});

function resizeCanvas(){
  const rect=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const w=Math.max(1,rect.width*dpr);
  const h=Math.max(1,rect.height*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
  }
}
function layerDrawOrder(layer){
  return layers.indexOf(layer);
}
function partOrder(part){
  if(part.layer==='far') return 0;
  if(part.layer==='near') return 2;
  return 1;
}

function render(){
  resizeCanvas();
  const dpr=window.devicePixelRatio||1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();
  const stats=computeLayerSlotStats();

  ctx.clearRect(0,0,W,H);

  // sky
  const sky=ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,"rgba(59,63,69,0.9)");
  sky.addColorStop(0.5,"rgba(80,89,96,0.5)");
  sky.addColorStop(1,"rgba(32,38,50,0.0)");
  ctx.fillStyle=sky;
  ctx.fillRect(0,0,W,H);

  // treeline
  ctx.save();
  ctx.translate(0,H*0.46);
  ctx.beginPath();
  ctx.moveTo(0,20);
  const steps=24, step=W/steps;
  for(let i=0;i<=steps;i++){
    const h=(i%2===0)?-28:-46;
    ctx.lineTo(i*step,h);
  }
  ctx.lineTo(W,20);
  ctx.closePath();
  ctx.fillStyle="rgba(22,51,33,0.9)";
  ctx.fill();
  ctx.restore();

  const dbg=[];
  const renderList=[];
  for(const inst of instances){
    const layer=findLayer(inst.layerId);
    const prefab=prefabs[inst.prefabId];
    if(!layer) continue;
    if(!prefab && !isPlayerSpawn(inst)) continue;
    renderList.push({inst,layer,prefab});
  }
  renderList.sort((a,b)=>layerDrawOrder(a.layer)-layerDrawOrder(b.layer));

  const retX=W/2;
  const retY=groundY - 8*zoom;

  for(const {inst,layer,prefab} of renderList){
    const objX=baseXFor(inst,stats);
    const par=layer.parallax ?? 1;
    const layerScale=layer.scale || 1;
    const instScaleX=inst.scaleX || 1;
    const instScaleY=inst.scaleY || instScaleX;
    const instOffsetY=inst.offsetY || 0;
    const instRot=inst.rot || 0;

    if(isPlayerSpawn(inst)){
      const baseOffset=(objX - cameraX*par)*zoom;
      const rootScreenX=W/2 + baseOffset;
      const rootScreenY=groundY + (layer.yOffset||0)*zoom - instOffsetY*zoom;

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - 20*zoom);
      ctx.strokeStyle='#38bdf8';
      ctx.fillStyle='rgba(56,189,248,0.18)';
      ctx.lineWidth=1.2;
      const radius=10*zoom;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-radius,0);
      ctx.lineTo(radius,0);
      ctx.moveTo(0,-radius);
      ctx.lineTo(0,radius);
      ctx.stroke();
      ctx.fillStyle='#38bdf8';
      ctx.font=`${10*zoom}px ui-monospace,Menlo,Consolas`;
      ctx.textAlign='center';
      ctx.fillText('Player Spawn',0,-radius-6);
      ctx.restore();

      if(debugOverlay){
        dbg.push(`spawn @${layer.name} x=${objX.toFixed(1)}`);
      }
      continue;
    }

    const baseOffset=(objX - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.yOffset||0)*zoom - instOffsetY*zoom;

    const dxScreen = rootScreenX - retX;

    if(prefab.isImage){
      const part=prefab.parts[0];
      const t=part.propTemplate||{};
      const img=imageCache.get(t.url);
      if(!img) continue;
      const w=t.w || img.width;
      const h=t.h || img.height;
      const {ax,ay}=computeAnchor(t);
      ctx.save();
      ctx.translate(rootScreenX,rootScreenY);
      ctx.scale(layerScale*zoom*instScaleX,
                layerScale*zoom*instScaleY);
      if(instRot) ctx.rotate(rad(instRot));
      ctx.drawImage(img,-ax,-ay,w,h);
      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.2:0.7;
        ctx.strokeRect(-ax,-ay,w,h);
        dbg.push(`img ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)}`);
      }
      ctx.restore();
      continue;
    }

    // Structured prefab: compute shared t from root part
    const rootPart = prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!rootPart) continue;
    const rootT = rootPart.propTemplate || {};
    const rootRelY = rootPart.relY || 0;

    const {t: sharedT, radiusPx} = computeTFromDx(rootT.kf || {}, dxScreen);
    const rootPose = evalKfPose(rootT.kf || {}, sharedT);

    const parts=[...prefab.parts].sort((a,b)=>
      (partOrder(a)-partOrder(b)) || ((a.z||0)-(b.z||0))
    );

    for(const part of parts){
      const t = part.propTemplate || {};
      const img = imageCache.get(t.url);
      const relX = part.relX || 0;
      const relY = part.relY || 0;

      const partPose = evalKfPose(t.kf || {}, sharedT);

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - rootRelY*layerScale*zoom);
      ctx.scale(layerScale*zoom*instScaleX,
                layerScale*zoom*instScaleY);
      if(instRot) ctx.rotate(rad(instRot));

      // apply root pose
      applyPose(ctx, rootPose);

      // part local offset
      ctx.translate(relX, -relY);

      // apply part pose
      applyPose(ctx, partPose);

      const w = t.w || 100;
      const h = t.h || 100;
      const {ax,ay} = computeAnchor(t);

      if(img && img.complete && img.naturalWidth){
        ctx.drawImage(img,-ax,-ay,w,h);
      } else {
        ctx.fillStyle="rgba(148,163,253,0.18)";
        ctx.fillRect(-ax,-ay,w,h);
      }

      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.1:0.6;
        ctx.strokeRect(-ax,-ay,w,h);
        ctx.fillStyle="#e5e7eb";
        ctx.font="7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`${part.name}`, -ax, -ay-3);
      }

      ctx.restore();
    }

    if(debugOverlay){
      const isSel = inst.id === selectedInstId;
      dbg.push(
        `struct ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)} t=${sharedT.toFixed(3)} rPx=${radiusPx.toFixed(1)}${inst.locked?' ':''}`
      );

      if (isSel && rootT.kf){
        const towerY = rootScreenY - rootRelY*layerScale*zoom;

        ctx.save();
        ctx.lineWidth = 0.8;

        // Ray from reticle to tower horizontally
        ctx.strokeStyle = "rgba(56,189,248,0.9)";
        ctx.beginPath();
        ctx.moveTo(retX, retY);
        ctx.lineTo(rootScreenX, retY);
        ctx.stroke();

        // Down to tower
        ctx.beginPath();
        ctx.moveTo(rootScreenX, retY);
        ctx.lineTo(rootScreenX, towerY);
        ctx.stroke();

        // Radius band around reticle in screen-space
        const r = radiusPx;
        ctx.strokeStyle = "rgba(148,163,253,0.35)";
        ctx.beginPath();
        ctx.moveTo(retX - r, retY);
        ctx.lineTo(retX + r, retY);
        ctx.stroke();

        // Labels
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`dx=${dxScreen.toFixed(1)}px`, rootScreenX+4, towerY-18);
        ctx.fillText(`t=${sharedT.toFixed(2)}`, rootScreenX+4, towerY-9);
        ctx.fillText(`rPx=${r.toFixed(1)}`, retX+4, retY+12);

        ctx.restore();
      }
    }
  }

  // ground line
  ctx.save();
  ctx.strokeStyle="rgba(250,204,21,0.35)";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(0,groundY+0.5);
  ctx.lineTo(W,groundY+0.5);
  ctx.stroke();
  ctx.restore();

  // reticle
  const size=10*zoom;
  ctx.save();
  ctx.strokeStyle="#facc15";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(retX-size,retY);
  ctx.lineTo(retX+size,retY);
  ctx.moveTo(retX,retY-size);
  ctx.lineTo(retX,retY+size);
  ctx.stroke();
  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.arc(retX,retY,2.5,0,Math.PI*2);
  ctx.fill();
  ctx.font="8px ui-monospace,Menlo,Consolas";
  ctx.fillText("Cam/Player",retX+6,retY-6);
  ctx.restore();

  $('#debugText').textContent = debugOverlay
    ? `camX=${cameraX} zoom=${zoom.toFixed(2)} activeLayer=${activeLayerId} 路 instances=${instances.length}\n` + dbg.join('\n')
    : '';

  requestAnimationFrame(render);
}

/*** Picking & drag ***/
function pickInstanceAt(clientX,clientY){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const py=clientY-rect.top;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();
  const stats=computeLayerSlotStats();

  const candidates=instances
    .filter(i=>i.layerId===activeLayerId)
    .map(inst=>{
      const layer=findLayer(inst.layerId);
      const prefab=prefabs[inst.prefabId];
      return layer && (prefab || isPlayerSpawn(inst)) ? {inst,layer,prefab}:null;
    })
    .filter(Boolean);

  candidates.sort((a,b)=>layerDrawOrder(b.layer)-layerDrawOrder(a.layer));

  for(const {inst,layer,prefab} of candidates){
    const objX=baseXFor(inst,stats);
    const par=layer.parallax ?? 1;
    const layerScale=layer.scale || 1;
    const instScaleX=inst.scaleX || 1;
    const instOffsetY=inst.offsetY || 0;
    const baseOffset=(objX - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.yOffset||0)*zoom - instOffsetY*zoom;

    if(isPlayerSpawn(inst)){
      const radius = 12 * zoom;
      const centerX = rootScreenX;
      const centerY = rootScreenY - 20 * zoom;
      const left = centerX - radius;
      const right = centerX + radius;
      const top = centerY - radius;
      const bottom = centerY + radius;
      if(px>=left && px<=right && py>=top && py<=bottom) return inst;
      continue;
    }

    let part;
    if(prefab.isImage) part=prefab.parts[0];
    else part=prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!part) continue;
    const t=part.propTemplate||{};
    const w=t.w || 100;
    const h=t.h || 100;
    const {ax,ay}=computeAnchor(t);
    const sc=layerScale*zoom*instScaleX;

    const left=rootScreenX - ax*sc;
    const top =rootScreenY - h*sc;
    const right=left + w*sc;
    const bottom=top + h*sc;
    if(px>=left && px<=right && py>=top && py<=bottom) return inst;
  }
  return null;
}

let draggingCamera=false;
let draggingInst=null;
let lastX=0;

function pointerClientToWorldX(clientX, layer){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const par=layer?.parallax ?? 1;
  const baseOffset=(px - W/2)/zoom;
  return baseOffset + cameraX*par;
}

function pointerDown(ev){
  const t=ev.touches?ev.touches[0]:ev;
  lastX=t.clientX;
  if(spawnPlacementMode){
    const spawn = ensurePlayerSpawn();
    const layer = findLayer(spawn.layerId) || findLayer(getDefaultSpawnLayerId());
    if(layer){
      pushHistory();
      const worldX = pointerClientToWorldX(t.clientX, layer);
      const grid = GRID_UNIT || 0;
      const snapped = grid > 0 ? Math.round(worldX / grid) * grid : worldX;
      spawn.x = snapped;
      spawn.slot = 0;
      spawn.nudgeX = 0;
      spawn.locked = true;
      selectedInstId = spawn.id;
      refreshInstanceList();
    }
    exitSpawnPlacement();
    return;
  }
  const hit=pickInstanceAt(t.clientX,t.clientY);
  if(hit){
    selectedInstId=hit.id;
    const inst=getSelectedInstance();
    if(inst && !inst.locked){
      pushHistory();
      draggingInst=inst;
    }
    refreshInstanceList();
  }else{
    pushHistory();
    draggingCamera=true;
  }
}
function pointerMove(ev){
  if(!draggingCamera && !draggingInst) return;
  const t=ev.touches?ev.touches[0]:ev;
  const dx=t.clientX-lastX;
  lastX=t.clientX;
  if(draggingInst){
    if(draggingInst.locked){ draggingInst=null; return; }
    const layer=findLayer(draggingInst.layerId);
    if(!layer) return;
    const grid=GRID_UNIT||1;
    const effPar=Math.max(0.01,layer.parallax || 1);
    draggingInst.nudgeX += dx/(effPar*zoom);
    if(grid>1){
      const stats=computeLayerSlotStats();
      const cur=baseXFor(draggingInst,stats);
      const snapped=Math.round(cur/grid)*grid;
      draggingInst.nudgeX += (snapped-cur);
    }
    refreshInstanceList();
  }else if(draggingCamera){
    setCameraX(cameraX - dx*2);
  }
}
function pointerUp(){
  draggingCamera=false;
  draggingInst=null;
}
canvas.addEventListener('mousedown',pointerDown);
canvas.addEventListener('mousemove',pointerMove);
window.addEventListener('mouseup',pointerUp);
canvas.addEventListener('touchstart',e=>{e.preventDefault();pointerDown(e);},{passive:false});
canvas.addEventListener('touchmove', e=>{e.preventDefault();pointerMove(e);},{passive:false});
canvas.addEventListener('touchend',  e=>{e.preventDefault();pointerUp();},{passive:false});

/*** Buttons & toggles ***/
$('#btnPlacePlayerSpawn').addEventListener('click', () => {
  const spawn = ensurePlayerSpawn();
  spawnPlacementMode = true;
  selectedInstId = spawn.id;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('spawn-mode');
  refreshInstanceList();
});
$('#btnJitter').addEventListener('click',()=>{
  pushHistory();
  const posRange=Math.abs(parseFloat($('#jitterRange').value)||0);
  const scaleRange=Math.abs(parseFloat($('#jitterScaleRange').value)||0);
  if(posRange<=0 && scaleRange<=0) return;
  for(const inst of instances){
    if(inst.layerId!==activeLayerId || inst.locked) continue;
    if(posRange>0){
      inst.nudgeX=(Math.random()*2-1)*posRange;
    }
    if(scaleRange>0){
      const sx=1 + (Math.random()*2-1)*scaleRange;
      const sy=1 + (Math.random()*2-1)*scaleRange;
      inst.scaleX=Math.max(0.1,sx);
      inst.scaleY=Math.max(0.1,sy);
    }
  }
  refreshInstanceList();
});
$('#btnDeleteInst').addEventListener('click',deleteSelectedInstance);
$('#btnDuplicateInst').addEventListener('click',duplicateSelectedInstance);
$('#btnUndo').addEventListener('click',undo);
$('#chkDebug').addEventListener('change',e=>{debugOverlay=e.target.checked;});
$('#btnPlaceRow').addEventListener('click',()=>{
  const pid=$('#libPrefab').value;
  const count=parseInt($('#libCount').value,10)||1;
  if(!prefabs[pid]){ alert('No prefab selected'); return; }
  pushHistory();
  for(let i=0;i<count;i++) addInstance(activeLayerId,pid);
  refreshInstanceList();
});
$('#btnAddParallaxLayer').addEventListener('click',()=>{
  const count=getParallaxLayerCount();
  if(count>=10){ alert('Parallax layer limit reached (10).'); return; }
  pushHistory();
  const id=`bg${count+1}`;
  layers.splice(count,0,{
    id,
    name:`Parallax ${count+1}`,
    type:"parallax",
    parallax:0.15 + 0.1*count,
    yOffset:-140 + 20*count,
    sep:220,
    scale:0.6 + 0.05*count
  });
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
});

/*** Export / Import map ***/
async function exportLayout(){
  const statusEl = $('#exportStatus');
  const textEl = $('#exportText');
  try{
    const stats=computeLayerSlotStats();
    const layout={
      areaId: layoutMeta.areaId,
      areaName: layoutMeta.areaName,
      cameraStartX:cameraX,
      zoomStart:zoom,
      groundOffset:getGroundOffset(),
      activeLayerId,
      layers:JSON.parse(JSON.stringify(layers)),
      instances:instances.map(inst=>{
        const copy=JSON.parse(JSON.stringify(inst));
        const computedX = baseXFor(inst,stats);
        if(!Number.isFinite(copy.x)) copy.x = computedX;
        return copy;
      }),
      meta:{
        ...layoutMeta,
        exportedAt: new Date().toISOString(),
      }
    };
    const runtime = await getRuntimeModule();
    const area=runtime.convertLayoutToArea(layout,{
      areaId: layoutMeta.areaId,
      areaName: layoutMeta.areaName,
    });
    const json=JSON.stringify(area,null,2);
    textEl.value=json;
    const dataUrl='data:application/json;charset=utf-8,'+encodeURIComponent(json);
    window.open(dataUrl,'_blank');
    statusEl.style.color='#22c55e';
    statusEl.textContent='Opened area JSON in new tab. If blocked, copy JSON below.';
  }catch(err){
    statusEl.style.color='#f97316';
    statusEl.textContent='Export error: '+err.message+' (JSON mirrored below)';
  }
}
$('#btnExportMap').addEventListener('click', exportLayout);

$('#btnLoadMap').addEventListener('click', async () => {
  const select = $('#mapRepoSelect');
  const mapId = select?.value || DEFAULT_LAYOUT_META.areaId;
  await loadRepositoryMapById(mapId);
});

/*** Loaders for prefab/image ***/
$('#btnLoadPrefab').addEventListener('click',()=>{
  const inp=document.createElement('input');
  inp.type='file';
  inp.accept='application/json';
  inp.onchange=e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
      try{ registerPrefab(JSON.parse(r.result)); }
      catch(err){ alert('Invalid JSON: '+err.message); }
    };
    r.readAsText(f);
  };
  inp.click();
});
$('#btnLoadImage').addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';                  // <-- required
  inp.accept = 'image/*';
  inp.onchange = e => {
    const f = e.target.files[0];
    if (!f) return;
    registerImagePrefab(f);
  };
  inp.click();
});

/*** Init ***/
$('#gridSize').value = GRID_UNIT;
$('#gridSize').disabled = true;
$('#gridSize').title = `Grid locked to ${GRID_UNIT}px (configured)`;
populateRepositorySelect();
rebuildActiveLayerSelect();
rebuildLayerStack();
syncActiveLayerFields();
ensurePlayerSpawn();
resetSlotCounters();
rebuildPrefabSelect();
refreshInstanceList();
setCameraX(0);
setZoom(1);
pushHistory();
requestAnimationFrame(render);
</script>
</body>
</html>
