<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parallax Map Builder (Layered v15f)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <style>
    :root {
      --bg:#05070a; --panel:#10141a; --card:#151b22;
      --line:#27303c; --muted:#7f8ea3; --text:#e6edf3;
      --btn:#1a2330; --btnHi:#222d3c;
    }
    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      height:100%;
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;
      padding-left:env(safe-area-inset-left);
      padding-right:env(safe-area-inset-right);
      padding-bottom:env(safe-area-inset-bottom);
    }

    #app {
      display:grid;
      grid-template-rows:40px auto 1fr;
      grid-template-columns:280px 1fr;
      grid-template-areas:
        "top top"
        "left bar"
        "left right";
      height:100vh;
      max-height:100vh;
      overflow:hidden;
    }

    header {
      grid-area:top;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 8px;
      background:var(--panel);
      border-bottom:1px solid var(--line);
      gap:6px;
      font-size:11px;
    }
    header h1 {
      margin:0;
      font-size:13px;
      font-weight:500;
      color:var(--muted);
    }

    button, select, input {
      background:var(--btn);
      color:var(--text);
      border:1px solid var(--line);
      border-radius:10px;
      padding:4px 8px;
      font-size:16px; /* avoid mobile zoom */
    }
    button:hover { background:var(--btnHi); cursor:pointer; }

    #bar {
      grid-area:bar;
      padding:4px 8px;
      display:flex;
      align-items:center;
      gap:8px;
      background:#111821;
      border-bottom:1px solid var(--line);
      font-size:11px;
      color:var(--muted);
      flex-wrap:wrap;
    }

    #left {
      grid-area:left;
      padding:6px;
      border-right:1px solid var(--line);
      background:var(--panel);
      overflow:auto;
      font-size:11px;
    }

    #right {
      grid-area:right;
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:6px;
      overflow:hidden;
    }

    .card {
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:6px;
      margin-bottom:4px;
    }

    .row {
      display:flex;
      gap:6px;
      margin-top:4px;
    }
    .row label {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:2px;
      font-size:10px;
    }
    label span {
      color:var(--muted);
      font-size:10px;
    }

    #sceneWrap {
      flex:1;
      border-radius:14px;
      border:1px solid var(--line);
      background:transparent;
      overflow:hidden;
      position:relative;
      min-height:0;
    }
    #sceneCanvas {
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }
    #sceneCanvas.spawn-mode {
      cursor:crosshair;
    }

    #instList {
      max-height:160px;
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--line);
      padding:4px;
      font-size:10px;
    }
    .inst {
      padding:2px 4px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:center;
    }
    .inst span {
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .inst.active {
      background:rgba(120,150,255,0.16);
    }

    .pill {
      padding:1px 5px;
      border-radius:999px;
      background:#1c2330;
      color:var(--muted);
      font-size:9px;
    }
    .pill--spawn {
      margin-left:4px;
      background:#0f172a;
      color:#38bdf8;
    }
    .lock-pill {
      margin-left:4px;
      font-size:9px;
      color:#facc15;
    }

    #debugText {
      font-family:ui-monospace,Menlo,Consolas;
      font-size:9px;
      color:var(--muted);
      margin-top:4px;
      white-space:pre;
    }

    #exportStatus {
      font-size:9px;
      margin-top:2px;
    }
    #exportText {
      width:100%;
      height:80px;
      margin-top:4px;
      background:#020308;
      color:#9ca3af;
      border-radius:6px;
      border:1px solid #27303c;
      font-size:9px;
      padding:4px;
      font-family:ui-monospace,Menlo,Consolas;
      resize:vertical;
    }

    .hidden-select {
      display:none;
    }

    .layer-stack {
      display:flex;
      flex-direction:column-reverse; /* top tile = frontmost visually */
      gap:4px;
      margin-top:4px;
    }
    .layer-item {
      padding:4px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:#111823;
      font-size:9px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
    }
    .layer-item span { pointer-events:none; }
    .layer-item.active {
      background:#1f2933;
      border-color:#38bdf8;
      box-shadow:0 0 0 1px rgba(56,189,248,0.25);
    }
    .layer-item.dragging { opacity:0.4; }
    .layer-item-type {
      padding:1px 5px;
      border-radius:999px;
      font-size:8px;
      background:#0f172a;
      color:#9ca3af;
    }

    @media (max-width:900px) {
      #app {
        grid-template-rows:40px auto 40% 1fr;
        grid-template-columns:1fr;
        grid-template-areas:
          "top"
          "bar"
          "right"
          "left";
      }
      #left {
        border-right:none;
        border-top:1px solid var(--line);
      }
    }
  </style>
  <script src="./config/config.js"></script>
</head>
<body>
<div id="app">
  <header>
    <h1>Parallax Map Builder <span style="color:var(--muted)">路 layered v15f</span></h1>
    <div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center">
      <button id="btnLoadPrefab">Load Structure JSON</button>
      <button id="btnLoadImage">Load Image</button>
      <select id="mapRepoSelect" aria-label="Repository Map"></select>
      <button id="btnLoadMap">Load Map</button>
      <button id="btnUndo">Undo</button>
      <button id="btnPreviewGameplay">Preview Gameplay</button>
      <button id="btnExportMap">Download Area JSON</button>
    </div>
  </header>

  <div id="bar">
    <span>
      Cam:
      <input id="camSlider" type="range" min="-4000" max="4000" value="0" style="width:120px">
      <input id="camNum" type="number" value="0" style="width:70px">
    </span>
    <span>
      Zoom:
      <input id="zoomSlider" type="range" min="0.5" max="2.0" step="0.05" value="1" style="width:120px">
      <input id="zoomNum" type="number" min="0.5" max="2.0" step="0.05" value="1" style="width:60px">
    </span>
    <label style="display:flex;align-items:center;gap:4px">
      <input id="chkDebug" type="checkbox">
      <span>Debug</span>
    </label>
    <button id="btnAddParallaxLayer">+ Parallax Layer</button>
    <span class="pill">
      Tap layer tiles to select 路 drag to reorder (top = front).
    </span>
  </div>

  <aside id="left">
    <!-- Instances -->
    <div class="card">
      <strong>Instances (active layer only)</strong>
      <div id="instList"></div>
      <div style="display:flex;margin-top:6px">
        <button id="btnPlacePlayerSpawn" style="flex:1">Place Player Spawn</button>
      </div>
      <div class="row">
        <label><span>Spawn Height (px)</span><input id="spawnPosY" type="number" step="1"></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Positive values push the spawn below ground; negative lifts it above.
      </small>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Only instances on the active layer can be picked, dragged or jittered. Use the button above and then click the preview to set the spawn (snaps to the grid unit).
      </small>
    </div>

    <!-- Selected instance -->
    <div class="card">
      <strong>Selected instance</strong>
      <div class="row">
        <label><span>ID</span><input id="instId" readonly></label>
        <label><span>Prefab</span><select id="instPrefab"></select></label>
      </div>
      <div class="row">
        <label>
          <span>Layer</span>
          <select id="instLayer" class="hidden-select"></select>
        </label>
        <label>
          <span>Display X (world)</span>
          <input id="instX" type="number">
        </label>
      </div>
      <div class="row">
        <label style="flex:none;display:flex;align-items:center;gap:4px">
          <input id="instLocked" type="checkbox">
          <span>Lock position</span>
        </label>
        <label><span>Grid (px)</span><input id="gridSize" type="number" value="10"></label>
        <label><span>Delete</span><button id="btnDeleteInst">Remove</button></label>
      </div>
      <div class="row">
        <label><span>Scale X</span><input id="instScaleX" type="number" step="0.05"></label>
        <label><span>Scale Y</span><input id="instScaleY" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>Position Y (from ground)</span><input id="instOffY" type="number" step="1"></label>
        <label><span>Rot (deg)</span><input id="instRot" type="number" step="1"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateInst">Duplicate</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Duplicate copies all settings; lock blocks drag/jitter, not manual edits.
      </small>
    </div>

    <!-- Prefab library -->
    <div class="card">
      <strong>Prefab Library</strong>
      <div class="row">
        <label>
          <span>Prefab</span>
          <select id="libPrefab"></select>
        </label>
        <label>
          <span>Count</span>
          <input id="libCount" type="number" min="1" max="50" value="8">
        </label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnPlaceRow">Place row on active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Structures & uploads land here; stamp rows onto the active layer.
      </small>
    </div>

    <!-- Layers -->
    <div class="card">
      <strong>Layers</strong>
      <select id="activeLayerSelect" class="hidden-select"></select>
      <div id="layerStack" class="layer-stack"></div>
      <div class="row">
        <label><span>parallax</span><input id="layerParallax" type="number" step="0.05"></label>
        <label><span>y offset (from ground)</span><input id="layerYOffset" type="number"></label>
      </div>
      <div class="row">
        <label><span>separation</span><input id="layerSep" type="number"></label>
        <label><span>scale</span><input id="layerScale" type="number" step="0.05"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnDuplicateLayer">Duplicate active layer</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Drag tiles to change draw order. Top tile renders in front.
      </small>
    </div>

    <!-- Jitter -->
    <div class="card">
      <strong>Jitter (active layer, unlocked only)</strong>
      <div class="row">
        <label><span>Pos range (px)</span><input id="jitterRange" type="number" value="40"></label>
        <label><span>Scale range (卤)</span><input id="jitterScaleRange" type="number" step="0.05" value="0.15"></label>
      </div>
      <div class="row">
        <label><span>&nbsp;</span><button id="btnJitter">Apply jitter</button></label>
      </div>
      <small style="color:var(--muted);display:block;margin-top:4px">
        Randomizes horizontal position (snapped to the grid) and scale for unlocked instances on the active layer.
      </small>
    </div>

    <!-- Global / Export -->
    <div class="card">
      <strong>Global & Export</strong>
      <div class="row">
        <label>
          <span>Ground from bottom (px)</span>
          <input id="groundOffset" type="number" value="140">
        </label>
      </div>
      <div id="exportStatus"></div>
      <textarea id="exportText" readonly
        placeholder="Layout JSON appears here when you export."></textarea>
      <small style="color:var(--muted);display:block;margin-top:4px">
        If the new tab is blocked, long-press here to copy the JSON.
      </small>
    </div>

    <div id="debugText"></div>
  </aside>

  <section id="right">
    <div class="card">
      <strong>Preview</strong>
      <span style="font-size:10px;color:var(--muted);margin-left:6px">
        Screen-space KF 路 select an instance & toggle Debug to see rays.
      </span>
    </div>
    <div id="sceneWrap"><canvas id="sceneCanvas"></canvas></div>
  </section>
</div>

<script>
const $ = s => document.querySelector(s);
const ROOT_CONFIG = window.CONFIG || {};
const MAP_CONFIG = ROOT_CONFIG.map || {};
const DEFAULT_CANVAS_HEIGHT = Number.isFinite(ROOT_CONFIG.canvas?.h) && ROOT_CONFIG.canvas.h > 0
  ? ROOT_CONFIG.canvas.h
  : 460;
const DEFAULT_GROUND_OFFSET = (() => {
  const configGround = ROOT_CONFIG.ground;
  const configuredOffset = configGround && typeof configGround === 'object' ? Number(configGround.offset) : NaN;
  if (Number.isFinite(configuredOffset)) {
    return Math.max(0, configuredOffset);
  }
  const ratio = Number(ROOT_CONFIG.groundRatio);
  if (Number.isFinite(ratio) && ratio > 0 && ratio < 1 && DEFAULT_CANVAS_HEIGHT > 0) {
    return Math.max(0, Math.round(DEFAULT_CANVAS_HEIGHT * (1 - ratio)));
  }
  return 140;
})();
const DEFAULT_CUSTOM_ENTRY = { id: 'custom_area', label: 'Empty Layout', path: null, areaName: 'Custom Area' };
const REPOSITORY_LAYOUTS = (() => {
  const normalized = Array.isArray(MAP_CONFIG.layouts) && MAP_CONFIG.layouts.length
    ? MAP_CONFIG.layouts.map((entry) => ({
        id: entry.id || entry.areaId || entry.path || 'custom_area',
        label: entry.label || entry.areaName || entry.id || 'Map',
        path: entry.path || null,
        areaName: entry.areaName || entry.label || entry.id || 'Map',
      }))
    : [];
  const seen = new Set();
  const result = [];
  const add = (entry) => {
    if (entry && entry.id && !seen.has(entry.id)) {
      result.push(entry);
      seen.add(entry.id);
    }
  };
  add(DEFAULT_CUSTOM_ENTRY);
  normalized.forEach(add);
  return result;
})();
const DEFAULT_LAYOUT_META = (() => {
  const fallback = {
    areaId: DEFAULT_CUSTOM_ENTRY.id,
    areaName: DEFAULT_CUSTOM_ENTRY.areaName || DEFAULT_CUSTOM_ENTRY.label || 'Custom Area',
    sourcePath: DEFAULT_CUSTOM_ENTRY.path,
    repositoryId: DEFAULT_CUSTOM_ENTRY.id,
  };
  const preferredId = typeof MAP_CONFIG.defaultLayoutId === 'string' && MAP_CONFIG.defaultLayoutId.trim()
    ? MAP_CONFIG.defaultLayoutId.trim()
    : null;
  const findEntryById = (id) => REPOSITORY_LAYOUTS.find((entry) => entry.id === id) || null;
  const preferred = preferredId ? findEntryById(preferredId) : null;
  const examplestreet = findEntryById('examplestreet');
  const firstRepository = REPOSITORY_LAYOUTS.find((entry) => entry.id && entry.id !== DEFAULT_CUSTOM_ENTRY.id) || null;
  const chosen = preferred || examplestreet || firstRepository;
  if (!chosen) return fallback;
  return {
    areaId: chosen.id || fallback.areaId,
    areaName: chosen.areaName || chosen.label || chosen.id || fallback.areaName,
    sourcePath: chosen.path || fallback.sourcePath,
    repositoryId: chosen.id || fallback.repositoryId,
  };
})();
const GRID_UNIT = (Number.isFinite(MAP_CONFIG.gridUnit) && MAP_CONFIG.gridUnit > 0) ? MAP_CONFIG.gridUnit : 10;
const SPAWN_LAYER_ID = MAP_CONFIG.spawnLayerId || 'gameplay';
const PREFAB_MANIFESTS = Array.isArray(MAP_CONFIG.prefabManifests)
  ? MAP_CONFIG.prefabManifests.filter((entry) => typeof entry === 'string' && entry.trim())
  : [];
const PREVIEW_STORAGE_PREFIX = 'sok-map-editor-preview:';
let runtimeModulePromise = null;
let prefabBootstrapPromise = null;

$('#groundOffset').value = DEFAULT_GROUND_OFFSET;

function getRuntimeModule(){
  if (!runtimeModulePromise){
    runtimeModulePromise = import('./js/vendor/map-runtime.js');
  }
  return runtimeModulePromise;
}

function clamp(v,a,b){ return v<a?a:v>b?b:v; }
function lerp(a,b,t){ return a + (b-a)*t; }
function rad(d){ return d * Math.PI/180; }

/*** Undo history ***/
const historyStack = [];
const HISTORY_LIMIT = 50;
let isRestoring = false;
function snapshotState(){
  return JSON.parse(JSON.stringify({
    ...buildAreaDescriptor(),
    activeLayerId,
  }));
}
function pushHistory(){
  if(isRestoring) return;
  historyStack.push(snapshotState());
  if(historyStack.length > HISTORY_LIMIT) historyStack.shift();
}
function restoreState(state){
  if(!state) return;
  isRestoring = true;
  exitSpawnPlacement();

  const adopted = adoptAreaState(state, state.meta || {});
  layoutMeta = { ...DEFAULT_LAYOUT_META, ...(adopted.meta || {}) };

  layers = adopted.layers.map((layer, index) => normalizeLayer(layer, index));
  instances.length = 0;
  nextInstId = 1;
  for (const inst of adopted.instances){
    const normalized = normalizeInstance(inst, nextInstId);
    if (normalized.id == null){
      normalized.id = nextInstId++;
    } else {
      nextInstId = Math.max(nextInstId, normalized.id + 1);
    }
    normalized.tags = Array.isArray(normalized.tags) ? normalized.tags : [];
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    instances.push(normalized);
  }

  const spawn = ensurePlayerSpawn();
  if (spawn && spawn.id >= nextInstId){
    nextInstId = spawn.id + 1;
  }

  activeLayerId = adopted.activeLayerId || layoutMeta.activeLayerId || getDefaultSpawnLayerId();
  cameraX = toNumber(adopted.camera?.startX, 0);
  zoom = toNumber(adopted.camera?.startZoom, 1);
  $('#groundOffset').value = toNumber(adopted.ground?.offset, DEFAULT_GROUND_OFFSET);
  selectedInstId = getPlayerSpawnInstance()?.id || (instances[0]?.id ?? null);

  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
  refreshInstanceList();
  setCameraX(cameraX);
  setZoom(zoom);

  isRestoring = false;
}
function undo(){
  const st = historyStack.pop();
  if(st) restoreState(st);
}

/*** Easing + unified screen-space KF ***/
function ease01(mode, x){
  x = clamp(x,0,1);
  if (mode === 'smoothstep') return x*x*(3 - 2*x);
  if (mode === 'quadInOut')  return x < 0.5
      ? 2*x*x
      : 1 - Math.pow(-2*x + 2, 2) / 2;
  return x; // linear
}

/*
  Step 1: computeTFromDx(kfMeta, dxScreen)

    reticleX = center of screen
    dxScreen = rootScreenX - reticleX    (screen pixels)

    radiusPx = kfMeta.radiusPx || kfMeta.radius || 600
    t        = clamp(-dxScreen / radiusPx, -1, 1)

  This is done ONCE per structure instance (root).
*/
function computeTFromDx(kfMeta, dxScreen){
  const baseRadius =
    (kfMeta && Number.isFinite(kfMeta.radiusPx) && kfMeta.radiusPx > 0) ? kfMeta.radiusPx :
    (kfMeta && Number.isFinite(kfMeta.radius)   && kfMeta.radius   > 0) ? kfMeta.radius   :
    600;
  const radiusPx = Math.max(1, baseRadius);
  const rawT = -dxScreen / radiusPx;
  return {
    t: clamp(rawT, -1, 1),
    radiusPx
  };
}

/*
  Step 2: evalKfPose(kf, t)

  Given a shared t in [-1,1], lerp between left/center/right for this part.
  This matches the "single t, many parts" mental model.
*/
function evalKfPose(kf, t){
  if(!kf){
    return {
      t,
      dx:0, dy:0,
      scaleX:1,
      rotZdeg:0,
      translateSpace:'screen',
      order:'scaleThenRotate'
    };
  }

  const ease = kf.ease || 'smoothstep';
  const L = kf.left   || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const C = kf.center || {dx:0,dy:0,scaleX:1,rotZdeg:0};
  const R = kf.right  || {dx:0,dy:0,scaleX:1,rotZdeg:0};

  let from, to, u;
  if(t <= 0){
    // -1..0 : LEFT -> CENTER
    u = ease01(ease, t + 1); // [-1,0] -> [0,1]
    from = L; to = C;
  }else{
    // 0..1 : CENTER -> RIGHT
    u = ease01(ease, t);     // [0,1] -> [0,1]
    from = C; to = R;
  }

  return {
    t,
    dx:      lerp(from.dx      || 0, to.dx      || 0, u),
    dy:      lerp(from.dy      || 0, to.dy      || 0, u),
    scaleX:  lerp(from.scaleX ?? 1, to.scaleX ?? 1, u),
    rotZdeg: lerp(from.rotZdeg || 0, to.rotZdeg || 0, u),
    translateSpace: kf.translateSpace || 'screen',
    order:          kf.transformOrder || 'scaleThenRotate'
  };
}

/*** Apply a pose into current ctx, respecting translateSpace/order */
function applyPose(ctx, pose){
  const dx = pose.dx || 0;
  const dy = pose.dy || 0;
  const sx = (pose.scaleX != null ? pose.scaleX : 1);
  const rot = pose.rotZdeg || 0;
  const space = pose.translateSpace || 'screen';
  const order = pose.order || 'scaleThenRotate';

  // "screen": offsets in current (screen) space, before local scaling/rot.
  if(space === 'screen'){
    ctx.translate(dx, dy);
  }

  if(order === 'scaleThenRotate'){
    if(sx !== 1) ctx.scale(sx, 1);
    if(rot) ctx.rotate(rad(rot));
  }else{
    if(rot) ctx.rotate(rad(rot));
    if(sx !== 1) ctx.scale(sx, 1);
  }

  // "local": offsets after local transform (move in the part's space)
  if(space === 'local'){
    ctx.translate(dx, dy);
  }
}

/*** Anchors ***/
function computeAnchor(t){
  const w = t.w || 100;
  const h = t.h || 100;
  if(t.pivot === 'bottom') return {ax:w*0.5, ay:h};
  if(t.pivot === 'top')    return {ax:w*0.5, ay:0};
  if(t.pivot === 'center') return {ax:w*0.5, ay:h*0.5};
  const ax = (Number.isFinite(t.anchorXPct)? t.anchorXPct : 50) * 0.01 * w;
  const ay = (Number.isFinite(t.anchorYPct)? t.anchorYPct : 100) * 0.01 * h;
  return {ax, ay};
}

/*** Layers ***/
function createDefaultLayers(){
  return [
    { id:"bg1",  name:"Parallax 1", type:"parallax",  parallaxSpeed:0.2, offsetY:-120, separation:220, scale:0.7, meta:{} },
    { id:"bg2",  name:"Parallax 2", type:"parallax",  parallaxSpeed:0.4, offsetY:-90,  separation:220, scale:0.8, meta:{} },
    { id:"gameplay", name:"Gameplay", type:"gameplay", parallaxSpeed:1.0, offsetY:-20, separation:180, scale:1.0, meta:{} },
    { id:"fg1",  name:"Foreground 1", type:"foreground", parallaxSpeed:1.1, offsetY:-10, separation:180, scale:1.05, meta:{} },
    { id:"fg2",  name:"Foreground 2", type:"foreground", parallaxSpeed:1.2, offsetY:0,   separation:180, scale:1.1, meta:{} }
  ];
}
let layers = createDefaultLayers();
let activeLayerId = SPAWN_LAYER_ID && layers.some((l) => l.id === SPAWN_LAYER_ID) ? SPAWN_LAYER_ID : 'gameplay';
let layoutMeta = { ...DEFAULT_LAYOUT_META };
function getParallaxLayerCount(){ return layers.filter(l=>l.type==="parallax").length; }
function findLayer(id){ return layers.find(l=>l.id===id) || null; }

/*** Prefabs & Instances ***/
const imageCache = new Map();
const prefabs = {};
let selectedPrefabId = null;
let nextInstId = 1;
const instances = [];
let selectedInstId = null;
let playerSpawnInstId = null;
let spawnPlacementMode = false;

function isPlayerSpawn(inst){
  return Array.isArray(inst?.tags) && inst.tags.includes('spawn:player');
}

function getDefaultSpawnLayerId(){
  if (findLayer(SPAWN_LAYER_ID)) return SPAWN_LAYER_ID;
  const gameplay = layers.find((layer) => layer.type === 'gameplay');
  return gameplay ? gameplay.id : (layers[0]?.id || 'gameplay');
}

function ensurePlayerSpawn(){
  let spawn = instances.find(isPlayerSpawn);
  const spawnLayerId = getDefaultSpawnLayerId();
  if (!spawn){
    spawn = {
      id: nextInstId++,
      prefabId: 'spawn_player',
      layerId: spawnLayerId,
      position: { x: 0, y: 0 },
      scale: { x: 1, y: 1 },
      rotationDeg: 0,
      locked: true,
      tags: ['spawn:player'],
      meta: {},
    };
    instances.push(spawn);
  } else {
    if (!Array.isArray(spawn.tags)) spawn.tags = [];
    if (!spawn.tags.includes('spawn:player')) spawn.tags.push('spawn:player');
    spawn.layerId = spawn.layerId || spawnLayerId;
    spawn.position = normalizePosition(spawn.position);
    spawn.scale = normalizeScale(spawn.scale);
    spawn.rotationDeg = Number.isFinite(spawn.rotationDeg) ? spawn.rotationDeg : 0;
    spawn.meta = spawn.meta && typeof spawn.meta === 'object' ? spawn.meta : {};
  }
  playerSpawnInstId = spawn.id;
  return spawn;
}

function getPlayerSpawnInstance(){
  if (playerSpawnInstId != null){
    const inst = instances.find((item) => item.id === playerSpawnInstId);
    if (inst) return inst;
  }
  const spawn = instances.find(isPlayerSpawn) || null;
  if (spawn) playerSpawnInstId = spawn.id;
  return spawn;
}

function exitSpawnPlacement(){
  spawnPlacementMode = false;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.remove('spawn-mode');
}

function syncSpawnHeightField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = getPlayerSpawnInstance();
  if (!spawn){
    field.value = '';
    return;
  }
  const pos = normalizePosition(spawn.position);
  field.value = Number.isFinite(pos.y) ? pos.y : 0;
}

function updateSpawnHeightFromField(){
  const field = $('#spawnPosY');
  if (!field) return;
  const spawn = ensurePlayerSpawn();
  if (!spawn) return;
  const val = parseFloat(field.value);
  if (!Number.isFinite(val)) {
    syncSpawnHeightField();
    return;
  }
  spawn.position = normalizePosition(spawn.position);
  if (spawn.position.y === val) return;
  pushHistory();
  spawn.position.y = val;
  refreshInstanceList();
}

function toNumber(value, fallback){
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function normalizePosition(position){
  if (!position || typeof position !== 'object'){
    return { x: 0, y: 0 };
  }
  const x = toNumber(position.x, 0);
  const y = toNumber(position.y, 0);
  return { x, y };
}

function normalizeScale(scale){
  if (!scale || typeof scale !== 'object'){
    return { x: 1, y: 1 };
  }
  const x = toNumber(scale.x, 1) || 1;
  const y = toNumber(scale.y, scale.x ?? 1) || 1;
  return { x, y };
}

function normalizeLayer(layer, index = 0){
  const safe = layer && typeof layer === 'object' ? JSON.parse(JSON.stringify(layer)) : {};
  const id = safe.id || `layer_${index}`;
  const name = safe.name || `Layer ${index + 1}`;
  const type = safe.type || 'gameplay';
  const parallaxSpeed = toNumber(safe.parallaxSpeed ?? safe.parallax, 1);
  const offsetY = toNumber(safe.offsetY ?? safe.yOffset, 0);
  const separation = toNumber(safe.separation ?? safe.sep, 0);
  const scale = toNumber(safe.scale, 1);
  const source = safe.source ?? null;
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, name, type, parallaxSpeed, offsetY, separation, scale, source, meta };
}

function normalizeInstance(inst, fallbackId = 0){
  const safe = inst && typeof inst === 'object' ? JSON.parse(JSON.stringify(inst)) : {};
  const id = safe.id ?? safe.meta?.original?.id ?? fallbackId;
  const prefabId = safe.prefabId ?? safe.meta?.original?.prefabId ?? 'unknown_prefab';
  const layerId = safe.layerId ?? safe.meta?.original?.layerId ?? getDefaultSpawnLayerId();
  const position = normalizePosition(safe.position ?? { x: safe.x, y: safe.y ?? (safe.offsetY != null ? -safe.offsetY : 0) });
  const scale = normalizeScale(safe.scale ?? { x: safe.scaleX, y: safe.scaleY });
  const rotationDeg = toNumber(safe.rotationDeg ?? safe.rot, 0);
  const locked = !!(safe.locked ?? safe.meta?.original?.locked);
  const tags = Array.isArray(safe.tags)
    ? safe.tags.map((tag) => String(tag))
    : Array.isArray(safe.meta?.original?.tags)
      ? safe.meta.original.tags.map((tag) => String(tag))
      : [];
  const meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
  return { id, prefabId, layerId, position, scale, rotationDeg, locked, tags, meta };
}

function adoptAreaState(area, context = {}){
  const raw = area && typeof area === 'object' ? JSON.parse(JSON.stringify(area)) : {};
  const id = raw.id || raw.areaId || context.areaId || DEFAULT_LAYOUT_META.areaId;
  const name = raw.name || raw.areaName || context.areaName || DEFAULT_LAYOUT_META.areaName;
  const camera = {
    startX: toNumber(raw.camera?.startX ?? raw.cameraStartX, 0),
    startZoom: toNumber(raw.camera?.startZoom ?? raw.zoomStart, 1),
  };
  const ground = {
    offset: toNumber(raw.ground?.offset ?? raw.groundOffset, DEFAULT_GROUND_OFFSET),
  };
  const layersList = Array.isArray(raw.layers) && raw.layers.length
    ? raw.layers.map((layer, index) => normalizeLayer(layer, index))
    : createDefaultLayers();
  const instancesList = Array.isArray(raw.instances) ? raw.instances : [];
  const normalizedInstances = [];
  let fallbackId = 1;
  for (const inst of instancesList){
    const normalized = normalizeInstance(inst, fallbackId);
    if (normalized.id == null){
      normalized.id = fallbackId;
    }
    fallbackId = Math.max(fallbackId + 1, normalized.id + 1);
    normalizedInstances.push(normalized);
  }

  const meta = raw.meta && typeof raw.meta === 'object' ? { ...raw.meta } : {};
  const activeLayerId = raw.activeLayerId
    || meta.activeLayerId
    || layersList[0]?.id
    || getDefaultSpawnLayerId();

  return {
    id,
    name,
    camera,
    ground,
    layers: layersList,
    instances: normalizedInstances,
    meta: {
      ...meta,
      areaId: id,
      areaName: name,
      sourcePath: context.sourcePath ?? meta.sourcePath ?? null,
      repositoryId: context.repositoryId ?? meta.repositoryId ?? null,
    },
    activeLayerId,
  };
}

function buildAreaDescriptor(){
  ensurePlayerSpawn();
  const clonedLayers = layers.map((layer, index) => {
    const normalized = normalizeLayer(layer, index);
    return {
      id: normalized.id,
      name: normalized.name,
      type: normalized.type,
      parallaxSpeed: normalized.parallaxSpeed,
      offsetY: normalized.offsetY,
      separation: normalized.separation,
      scale: normalized.scale,
      source: normalized.source ?? null,
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const clonedInstances = instances.map((inst, index) => {
    const normalized = normalizeInstance(inst, inst.id ?? index + 1);
    normalized.position = normalizePosition(normalized.position);
    normalized.scale = normalizeScale(normalized.scale);
    return {
      id: normalized.id ?? index + 1,
      prefabId: normalized.prefabId,
      layerId: normalized.layerId,
      position: normalized.position,
      scale: normalized.scale,
      rotationDeg: toNumber(normalized.rotationDeg, 0),
      locked: !!normalized.locked,
      tags: Array.isArray(normalized.tags) ? normalized.tags.map((tag) => String(tag)) : [],
      meta: normalized.meta ? JSON.parse(JSON.stringify(normalized.meta)) : {},
    };
  });

  const meta = {
    ...layoutMeta,
    activeLayerId,
  };

  return {
    id: meta.areaId || DEFAULT_LAYOUT_META.areaId,
    name: meta.areaName || DEFAULT_LAYOUT_META.areaName,
    source: 'map-editor',
    camera: {
      startX: cameraX,
      startZoom: zoom,
    },
    ground: {
      offset: getGroundOffset(),
    },
    layers: clonedLayers,
    instances: clonedInstances,
    meta,
  };
}

async function convertDataToArea(data, context = {}){
  const runtime = await getRuntimeModule();
  return runtime.convertLayoutToArea(data || {}, {
    areaId: context.areaId || context.meta?.areaId || DEFAULT_LAYOUT_META.areaId,
    areaName: context.areaName || context.meta?.areaName || DEFAULT_LAYOUT_META.areaName,
    prefabResolver: (prefabId) => {
      const prefab = prefabs[prefabId];
      return prefab ? JSON.parse(JSON.stringify(prefab)) : null;
    },
  });
}

function getRepositoryEntry(mapId){
  return REPOSITORY_LAYOUTS.find((entry) => entry.id === mapId) || null;
}

async function loadRepositoryMapById(mapId){
  const entry = getRepositoryEntry(mapId) || getRepositoryEntry(DEFAULT_LAYOUT_META.areaId);
  const context = {
    areaId: entry?.id || DEFAULT_LAYOUT_META.areaId,
    areaName: entry?.areaName || entry?.label || DEFAULT_LAYOUT_META.areaName,
    sourcePath: entry?.path || null,
    repositoryId: entry?.id || null,
  };

  await ensureConfiguredPrefabsLoaded();

  try {
    const areaData = entry?.path
      ? await (async () => {
          const response = await fetch(entry.path, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const json = await response.json();
          return convertDataToArea(json, context);
        })()
      : await convertDataToArea({}, context);
    restoreState(areaData);
  } catch (error) {
    console.error('[map-editor] failed to load map from repository', error);
    const fallbackArea = await convertDataToArea({}, context);
    restoreState(fallbackArea);
    alert(`Failed to load map: ${error.message}. Loaded empty layout instead.`);
  }
  historyStack.length = 0;
  pushHistory();
  const select = $('#mapRepoSelect');
  if (select) select.value = context.repositoryId || select.value;
}

function populateRepositorySelect(){
  const select = $('#mapRepoSelect');
  if (!select) return;
  select.innerHTML = '';
  REPOSITORY_LAYOUTS.forEach((entry) => {
    const opt = document.createElement('option');
    opt.value = entry.id;
    opt.textContent = entry.label;
    select.appendChild(opt);
  });
  const targetId = layoutMeta.repositoryId || DEFAULT_LAYOUT_META.repositoryId;
  if (targetId) select.value = targetId;
}

let cameraX = 0;
let zoom = 1;
let debugOverlay = false;

function getGroundOffset(){
  return parseFloat($('#groundOffset').value) || DEFAULT_GROUND_OFFSET;
}

/*** Layer UI & stack ***/
function rebuildActiveLayerSelect(){
  const sel = $('#activeLayerSelect');
  const instLayerSel = $('#instLayer');
  sel.innerHTML = '';
  instLayerSel.innerHTML = '';
  layers.forEach(layer=>{
    const o = document.createElement('option');
    o.value = layer.id; o.textContent = layer.name;
    sel.appendChild(o);
    const o2 = document.createElement('option');
    o2.value = layer.id; o2.textContent = layer.name;
    instLayerSel.appendChild(o2);
  });
  if(!findLayer(activeLayerId) && layers.length){
    activeLayerId = layers[0].id;
  }
  sel.value = activeLayerId;
}
function rebuildLayerStack(){
  const stack = $('#layerStack');
  stack.innerHTML = '';
  layers.forEach(layer=>{
    const div = document.createElement('div');
    div.className = 'layer-item' + (layer.id===activeLayerId ? ' active' : '');
    div.draggable = true;
    div.dataset.layerId = layer.id;
    div.innerHTML = `
      <span>${layer.name}</span>
      <span class="layer-item-type">${layer.type}</span>
    `;
    div.addEventListener('click', () => setActiveLayer(layer.id));
    div.addEventListener('dragstart', e => {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', layer.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => {
      div.classList.remove('dragging');
    });
    div.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    div.addEventListener('drop', e => {
      e.preventDefault();
      const srcId = e.dataTransfer.getData('text/plain');
      const dstId = layer.id;
      if(!srcId || srcId === dstId) return;
      pushHistory();
      const srcIndex = layers.findIndex(l=>l.id===srcId);
      const dstIndex = layers.findIndex(l=>l.id===dstId);
      if(srcIndex<0 || dstIndex<0) return;
      const [moved] = layers.splice(srcIndex,1);
      const insertIndex = srcIndex < dstIndex ? dstIndex-1 : dstIndex;
      layers.splice(insertIndex,0,moved);
      rebuildActiveLayerSelect();
      rebuildLayerStack();
    });
    stack.appendChild(div);
  });
}
function syncActiveLayerFields(){
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  $('#layerParallax').value = layer.parallaxSpeed;
  $('#layerYOffset').value = layer.offsetY;
  $('#layerSep').value = layer.separation;
  $('#layerScale').value = layer.scale;
  rebuildLayerStack();
}
function setActiveLayer(id){
  if(!findLayer(id)) return;
  activeLayerId = id;
  $('#activeLayerSelect').value = id;
  syncActiveLayerFields();
  const first = instances.find(i=>i.layerId === activeLayerId);
  selectedInstId = first ? first.id : null;
  refreshInstanceList();
}
['layerParallax','layerYOffset','layerSep','layerScale'].forEach(id=>{
  $(`#${id}`).addEventListener('input', e=>{
    const layer = findLayer(activeLayerId);
    if(!layer) return;
    const v = parseFloat(e.target.value);
    if(!Number.isFinite(v)) return;
    pushHistory();
    if(id==='layerParallax') layer.parallaxSpeed=v;
    if(id==='layerYOffset') layer.offsetY=v;
    if(id==='layerSep')      layer.separation=v;
    if(id==='layerScale')    layer.scale=v;
  });
});

/*** Duplicate layer ***/
$('#btnDuplicateLayer').addEventListener('click',()=>{
  const layer = findLayer(activeLayerId);
  if(!layer) return;
  pushHistory();
  let baseId = layer.id + '_copy';
  let n = 1;
  while(findLayer(baseId)) baseId = layer.id + '_copy' + (n++);
  const newLayer = JSON.parse(JSON.stringify(layer));
  newLayer.id = baseId;
  newLayer.name = layer.name + ' copy';
  const idx = layers.indexOf(layer);
  layers.splice(idx+1,0,newLayer);
  const clones = instances
    .filter(inst=>inst.layerId===layer.id)
    .map(inst=>{
      const c = JSON.parse(JSON.stringify(inst));
      c.id = nextInstId++;
      c.layerId = newLayer.id;
      return c;
    });
  instances.push(...clones);
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  activeLayerId = newLayer.id;
  syncActiveLayerFields();
  refreshInstanceList();
});

/*** Image loading ***/
function loadImage(url){
  return new Promise(res=>{
    if(!url) return res(null);
    if(imageCache.has(url)) return res(imageCache.get(url));
    const img=new Image();
    img.crossOrigin='anonymous';
    img.onload=()=>{ imageCache.set(url,img); res(img); };
    img.onerror=()=>res(null);
    img.src=url;
  });
}

/*** Prefabs ***/
async function registerPrefab(obj, options = {}){
  const { select = true, autoPopulate = true, silent = false, deferRefresh = false } = options;
  const prefab = obj && typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : null;
  if(!prefab || !prefab.structureId || !Array.isArray(prefab.parts)){
    const message = 'Invalid structure JSON';
    if(!silent) alert(message);
    throw new Error(message);
  }

  prefabs[prefab.structureId]=prefab;
  if(select && !selectedPrefabId) selectedPrefabId=prefab.structureId;

  for(const part of prefab.parts){
    const t=part.propTemplate||{};
    if(t.url) await loadImage(t.url);
  }

  if(!deferRefresh){
    rebuildPrefabSelect();
  }

  if(autoPopulate && !instances.length && activeLayerId){
    pushHistory();
    addRowOnLayer(activeLayerId,8,prefab.structureId);
    refreshInstanceList();
  }

  return prefab.structureId;
}

async function ensureConfiguredPrefabsLoaded(){
  if(prefabBootstrapPromise) return prefabBootstrapPromise;
  prefabBootstrapPromise = (async () => {
    if(!PREFAB_MANIFESTS.length) return { loaded: 0, registered: 0, errors: [] };
    try{
      const module = await import('./js/prefab-catalog.js');
      const loader = module.loadPrefabsFromManifests;
      if(typeof loader !== 'function'){
        throw new Error('Prefab catalog loader unavailable');
      }
      const { prefabs: prefabMap, errors } = await loader(PREFAB_MANIFESTS);
      let registered = 0;
      for(const [id, prefab] of prefabMap.entries()){
        const already = !!prefabs[id];
        await registerPrefab(prefab, {
          select: !selectedPrefabId && !already,
          autoPopulate: false,
          silent: true,
          deferRefresh: true,
        });
        if(!already) registered++;
      }
      rebuildPrefabSelect();
      if(errors?.length){
        const summarize = typeof module.summarizeLoadErrors === 'function'
          ? module.summarizeLoadErrors(errors)
          : null;
        if(summarize){
          console.warn('[map-editor] Some prefabs failed to load\n' + summarize);
        }
      }
      return { loaded: prefabMap.size, registered, errors: errors || [] };
    }catch(error){
      console.error('[map-editor] Failed to load configured prefabs', error);
      return { loaded: 0, registered: 0, errors: [{ type: 'bootstrap', error }] };
    }
  })();
  return prefabBootstrapPromise;
}
function registerImagePrefab(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.onload=()=>{
    const base=(file.name||'img').replace(/\.[^/.]+$/,'')||'img';
    let id=`img_${base}`, c=1;
    while(prefabs[id]) id=`img_${base}_${c++}`;
    prefabs[id]={
      structureId:id,
      isImage:true,
      parts:[{
        name:id,
        layer:'near',
        relX:0,
        relY:0,
        propTemplate:{
          id,
          w:img.width,
          h:img.height,
          url:url,
          pivot:'bottom',
          anchorXPct:50,
          anchorYPct:100
        }
      }]
    };
    imageCache.set(url,img);
    selectedPrefabId=id;
    rebuildPrefabSelect();
    refreshLibrarySelect();
  };
  img.onerror=()=>alert('Failed to load image');
  img.src=url;
}
function rebuildPrefabSelect(){
  const instSel=$('#instPrefab');
  instSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    instSel.appendChild(o);
  });
  if(selectedPrefabId) instSel.value=selectedPrefabId;
  refreshLibrarySelect();
}
function refreshLibrarySelect(){
  const libSel=$('#libPrefab');
  libSel.innerHTML='';
  Object.keys(prefabs).forEach(id=>{
    const o=document.createElement('option');
    o.value=id; o.textContent=id;
    libSel.appendChild(o);
  });
  if(selectedPrefabId) libSel.value=selectedPrefabId;
}

/*** Instances ***/
function allocSlot(layerId){
  const n=nextSlotByLayer[layerId] ?? 0;
  nextSlotByLayer[layerId]=n+1;
  return n;
}
function makeInstance(layerId,prefabId){
  const grid = GRID_UNIT || 0;
  const existing = instances.filter((inst) => inst.layerId === layerId);
  const baseX = existing.length ? Math.max(...existing.map((inst) => inst.position?.x ?? 0)) + (grid || 100) : 0;
  return {
    id:nextInstId++,
    prefabId,
    layerId,
    position:{ x: Number.isFinite(baseX) ? baseX : 0, y: 0 },
    scale:{ x:1, y:1 },
    rotationDeg:0,
    locked:false,
    tags:[],
    meta:{},
  };
}
function addInstance(layerId,prefabId){
  const layer=findLayer(layerId);
  if(!layer) return;
  const pid=prefabId || selectedPrefabId || Object.keys(prefabs)[0];
  if(!prefabs[pid]) return;
  const inst=makeInstance(layerId,pid);
  instances.push(inst);
  if(layerId===activeLayerId) selectedInstId=inst.id;
}
function addRowOnLayer(layerId,count,prefabId){
  for(let i=0;i<count;i++) addInstance(layerId,prefabId);
}
function getSelectedInstance(){
  return instances.find(i=>i.id===selectedInstId) || null;
}
function deleteSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be removed. Use the placement button to reposition it.');
    return;
  }
  pushHistory();
  const idx=instances.findIndex(i=>i.id===inst.id);
  if(idx>=0) instances.splice(idx,1);
  selectedInstId=null;
  refreshInstanceList();
}
function duplicateSelectedInstance(){
  const inst=getSelectedInstance();
  if(!inst) return;
  if(isPlayerSpawn(inst)){
    alert('Player spawn cannot be duplicated.');
    return;
  }
  pushHistory();
  const dup = JSON.parse(JSON.stringify(inst));
  dup.id = nextInstId++;
  dup.position = normalizePosition(dup.position);
  const grid = GRID_UNIT || 0;
  dup.position.x += grid > 0 ? grid : 50;
  instances.push(dup);
  selectedInstId = dup.id;
  refreshInstanceList();
}
function refreshInstanceList(){
  const list=$('#instList');
  list.innerHTML='';
  const visible=instances.filter(i=>i.layerId===activeLayerId);
  for(const inst of visible){
    const layer=findLayer(inst.layerId);
    if(!layer) continue;
    const div=document.createElement('div');
    div.className='inst'+(inst.id===selectedInstId?' active':'');
    const span=document.createElement('span');
    const pos = normalizePosition(inst.position);
    span.textContent=`${inst.id} 路 ${inst.prefabId} 路 x=${pos.x.toFixed(1)}`;
    if(inst.locked){
      const lp=document.createElement('span');
      lp.className='lock-pill';
      lp.textContent='';
      span.appendChild(lp);
    }
    if(isPlayerSpawn(inst)){
      const spawnPill=document.createElement('span');
      spawnPill.className='pill pill--spawn';
      spawnPill.textContent='Player Spawn';
      span.appendChild(spawnPill);
    }
    const pill=document.createElement('span');
    pill.className='pill';
    pill.textContent=layer.name;
    div.appendChild(span);
    div.appendChild(pill);
    div.onclick=()=>{ selectedInstId=inst.id; fillInstEditor(); refreshInstanceList(); };
    list.appendChild(div);
  }
  fillInstEditor();
  syncSpawnHeightField();
}
function fillInstEditor(){
  const inst=getSelectedInstance();
  if(!inst || inst.layerId!==activeLayerId){
    $('#instId').value='';
    $('#instX').value='';
    $('#instLayer').value=activeLayerId||'';
    $('#instLocked').checked=false;
    $('#instScaleX').value='';
    $('#instScaleY').value='';
    $('#instOffY').value='';
    $('#instRot').value='';
    return;
  }
  $('#instId').value=inst.id;
  $('#instPrefab').value=inst.prefabId;
  $('#instLayer').value=inst.layerId;
  const pos = normalizePosition(inst.position);
  $('#instX').value=pos.x.toFixed(1);
  $('#instLocked').checked=!!inst.locked;
  const scale = normalizeScale(inst.scale);
  $('#instScaleX').value=scale.x;
  $('#instScaleY').value=scale.y;
  $('#instOffY').value=pos.y;
  $('#instRot').value=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;
}

/*** Instance editor bindings ***/
function updateSelectedInstanceFromFields(){
  const inst = getSelectedInstance();
  if(!inst || inst.layerId !== activeLayerId) return;

  let changed = false;

  const pid = $('#instPrefab').value;
  if(prefabs[pid] && pid !== inst.prefabId){
    if(!changed) pushHistory();
    changed = true;
    inst.prefabId = pid;
  }

  const newLayerId = $('#instLayer').value;
  if(findLayer(newLayerId) && newLayerId !== inst.layerId){
    if(!changed) pushHistory();
    changed = true;
    inst.layerId = newLayerId;
  }

  const locked = $('#instLocked').checked;
  if(locked !== !!inst.locked){
    if(!changed) pushHistory();
    changed = true;
    inst.locked = locked;
  }

  inst.scale = normalizeScale(inst.scale);
  inst.position = normalizePosition(inst.position);

  const sx = parseFloat($('#instScaleX').value);
  if(Number.isFinite(sx) && sx !== inst.scale.x){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.x = Math.max(0.05, sx);
  }

  const sy = parseFloat($('#instScaleY').value);
  if(Number.isFinite(sy) && sy !== inst.scale.y){
    if(!changed) pushHistory();
    changed = true;
    inst.scale.y = Math.max(0.05, sy);
  }

  const offY = parseFloat($('#instOffY').value);
  if(Number.isFinite(offY) && offY !== inst.position.y){
    if(!changed) pushHistory();
    changed = true;
    inst.position.y = offY;
  }

  const rot = parseFloat($('#instRot').value);
  if(Number.isFinite(rot) && rot !== inst.rotationDeg){
    if(!changed) pushHistory();
    changed = true;
    inst.rotationDeg = rot;
  }

  const xVal = parseFloat($('#instX').value);
  if(Number.isFinite(xVal)){
    const grid = GRID_UNIT || 0;
    let target = xVal;
    if(grid > 0){
      target = Math.round(target / grid) * grid;
      $('#instX').value = target.toFixed(1);
    }
    if(target !== inst.position.x){
      if(!changed) pushHistory();
      changed = true;
      inst.position.x = target;
    }
  }

  if(changed){
    refreshInstanceList();
  }
}

['instPrefab','instLayer','instLocked',
 'instScaleX','instScaleY','instOffY','instRot','instX'
].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', updateSelectedInstanceFromFields);
  el.addEventListener('blur', updateSelectedInstanceFromFields);
});

/*** Camera & Zoom ***/
function setCameraX(v){
  cameraX=clamp(v,-4000,4000);
  $('#camSlider').value=cameraX;
  $('#camNum').value=cameraX;
}
function setZoom(v){
  zoom=clamp(v,0.5,2.0);
  $('#zoomSlider').value=zoom;
  $('#zoomNum').value=zoom.toFixed(2);
}
$('#camSlider').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#camNum').addEventListener('input',e=> setCameraX(parseFloat(e.target.value)||0));
$('#zoomSlider').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));
$('#zoomNum').addEventListener('input',e=> setZoom(parseFloat(e.target.value)||1));

/*** Canvas & Render ***/
const canvas=document.getElementById('sceneCanvas');
const ctx=canvas.getContext('2d',{alpha:true,desynchronized:true});

function resizeCanvas(){
  const rect=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const w=Math.max(1,rect.width*dpr);
  const h=Math.max(1,rect.height*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
  }
}
function layerDrawOrder(layer){
  return layers.indexOf(layer);
}
function partOrder(part){
  if(part.layer==='far') return 0;
  if(part.layer==='near') return 2;
  return 1;
}

function render(){
  resizeCanvas();
  const dpr=window.devicePixelRatio||1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  ctx.clearRect(0,0,W,H);

  // sky
  const sky=ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,"rgba(59,63,69,0.9)");
  sky.addColorStop(0.5,"rgba(80,89,96,0.5)");
  sky.addColorStop(1,"rgba(32,38,50,0.0)");
  ctx.fillStyle=sky;
  ctx.fillRect(0,0,W,H);

  // treeline
  ctx.save();
  ctx.translate(0,H*0.46);
  ctx.beginPath();
  ctx.moveTo(0,20);
  const steps=24, step=W/steps;
  for(let i=0;i<=steps;i++){
    const h=(i%2===0)?-28:-46;
    ctx.lineTo(i*step,h);
  }
  ctx.lineTo(W,20);
  ctx.closePath();
  ctx.fillStyle="rgba(22,51,33,0.9)";
  ctx.fill();
  ctx.restore();

  const dbg=[];
  const renderList=[];
  for(const inst of instances){
    const layer=findLayer(inst.layerId);
    const prefab=prefabs[inst.prefabId];
    if(!layer) continue;
    if(!prefab && !isPlayerSpawn(inst)) continue;
    renderList.push({inst,layer,prefab});
  }
  renderList.sort((a,b)=>layerDrawOrder(a.layer)-layerDrawOrder(b.layer));

  const retX=W/2;
  const retY=groundY - 8*zoom;

  for(const {inst,layer,prefab} of renderList){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const instRot=Number.isFinite(inst.rotationDeg) ? inst.rotationDeg : 0;

    if(isPlayerSpawn(inst)){
      const baseOffset=(pos.x - cameraX*par)*zoom;
      const rootScreenX=W/2 + baseOffset;
      const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - 20*zoom);
      ctx.strokeStyle='#38bdf8';
      ctx.fillStyle='rgba(56,189,248,0.18)';
      ctx.lineWidth=1.2;
      const radius=10*zoom;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-radius,0);
      ctx.lineTo(radius,0);
      ctx.moveTo(0,-radius);
      ctx.lineTo(0,radius);
      ctx.stroke();
      ctx.fillStyle='#38bdf8';
      ctx.font=`${10*zoom}px ui-monospace,Menlo,Consolas`;
      ctx.textAlign='center';
      ctx.fillText('Player Spawn',0,-radius-6);
      ctx.restore();

      if(debugOverlay){
        dbg.push(`spawn @${layer.name} x=${pos.x.toFixed(1)}`);
      }
      continue;
    }

    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    const dxScreen = rootScreenX - retX;

    if(prefab.isImage){
      const part=prefab.parts[0];
      const t=part.propTemplate||{};
      const img=imageCache.get(t.url);
      if(!img) continue;
      const w=t.w || img.width;
      const h=t.h || img.height;
      const {ax,ay}=computeAnchor(t);
      ctx.save();
      ctx.translate(rootScreenX,rootScreenY);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));
      ctx.drawImage(img,-ax,-ay,w,h);
      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.2:0.7;
        ctx.strokeRect(-ax,-ay,w,h);
        dbg.push(`img ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)}`);
      }
      ctx.restore();
      continue;
    }

    // Structured prefab: compute shared t from root part
    const rootPart = prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!rootPart) continue;
    const rootT = rootPart.propTemplate || {};
    const rootRelY = rootPart.relY || 0;

    const {t: sharedT, radiusPx} = computeTFromDx(rootT.kf || {}, dxScreen);
    const rootPose = evalKfPose(rootT.kf || {}, sharedT);

    const parts=[...prefab.parts].sort((a,b)=>
      (partOrder(a)-partOrder(b)) || ((a.z||0)-(b.z||0))
    );

    for(const part of parts){
      const t = part.propTemplate || {};
      const img = imageCache.get(t.url);
      const relX = part.relX || 0;
      const relY = part.relY || 0;

      const partPose = evalKfPose(t.kf || {}, sharedT);

      ctx.save();
      ctx.translate(rootScreenX, rootScreenY - rootRelY*layerScale*zoom);
      ctx.scale(layerScale*zoom*scale.x,
                layerScale*zoom*scale.y);
      if(instRot) ctx.rotate(rad(instRot));

      // apply root pose
      applyPose(ctx, rootPose);

      // part local offset
      ctx.translate(relX, -relY);

      // apply part pose
      applyPose(ctx, partPose);

      const w = t.w || 100;
      const h = t.h || 100;
      const {ax,ay} = computeAnchor(t);

      if(img && img.complete && img.naturalWidth){
        ctx.drawImage(img,-ax,-ay,w,h);
      } else {
        ctx.fillStyle="rgba(148,163,253,0.18)";
        ctx.fillRect(-ax,-ay,w,h);
      }

      if(debugOverlay){
        const isSel=inst.id===selectedInstId;
        ctx.strokeStyle=isSel?"#22c55e":"#9ca3af";
        ctx.lineWidth=isSel?1.1:0.6;
        ctx.strokeRect(-ax,-ay,w,h);
        ctx.fillStyle="#e5e7eb";
        ctx.font="7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`${part.name}`, -ax, -ay-3);
      }

      ctx.restore();
    }

    if(debugOverlay){
      const isSel = inst.id === selectedInstId;
      dbg.push(
        `struct ${inst.id} @${layer.name} dx=${dxScreen.toFixed(1)} t=${sharedT.toFixed(3)} rPx=${radiusPx.toFixed(1)}${inst.locked?' ':''}`
      );

      if (isSel && rootT.kf){
        const towerY = rootScreenY - rootRelY*layerScale*zoom;

        ctx.save();
        ctx.lineWidth = 0.8;

        // Ray from reticle to tower horizontally
        ctx.strokeStyle = "rgba(56,189,248,0.9)";
        ctx.beginPath();
        ctx.moveTo(retX, retY);
        ctx.lineTo(rootScreenX, retY);
        ctx.stroke();

        // Down to tower
        ctx.beginPath();
        ctx.moveTo(rootScreenX, retY);
        ctx.lineTo(rootScreenX, towerY);
        ctx.stroke();

        // Radius band around reticle in screen-space
        const r = radiusPx;
        ctx.strokeStyle = "rgba(148,163,253,0.35)";
        ctx.beginPath();
        ctx.moveTo(retX - r, retY);
        ctx.lineTo(retX + r, retY);
        ctx.stroke();

        // Labels
        ctx.fillStyle = "#e5e7eb";
        ctx.font = "7px ui-monospace,Menlo,Consolas";
        ctx.fillText(`dx=${dxScreen.toFixed(1)}px`, rootScreenX+4, towerY-18);
        ctx.fillText(`t=${sharedT.toFixed(2)}`, rootScreenX+4, towerY-9);
        ctx.fillText(`rPx=${r.toFixed(1)}`, retX+4, retY+12);

        ctx.restore();
      }
    }
  }

  // ground line
  ctx.save();
  ctx.strokeStyle="rgba(250,204,21,0.35)";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(0,groundY+0.5);
  ctx.lineTo(W,groundY+0.5);
  ctx.stroke();
  ctx.restore();

  // reticle
  const size=10*zoom;
  ctx.save();
  ctx.strokeStyle="#facc15";
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(retX-size,retY);
  ctx.lineTo(retX+size,retY);
  ctx.moveTo(retX,retY-size);
  ctx.lineTo(retX,retY+size);
  ctx.stroke();
  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.arc(retX,retY,2.5,0,Math.PI*2);
  ctx.fill();
  ctx.font="8px ui-monospace,Menlo,Consolas";
  ctx.fillText("Cam/Player",retX+6,retY-6);
  ctx.restore();

  $('#debugText').textContent = debugOverlay
    ? `camX=${cameraX} zoom=${zoom.toFixed(2)} activeLayer=${activeLayerId} 路 instances=${instances.length}\n` + dbg.join('\n')
    : '';

  requestAnimationFrame(render);
}

/*** Picking & drag ***/
function pickInstanceAt(clientX,clientY){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const py=clientY-rect.top;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const H=canvas.height/dpr;
  const groundY=H-getGroundOffset();

  const candidates=instances
    .filter(i=>i.layerId===activeLayerId)
    .map(inst=>{
      const layer=findLayer(inst.layerId);
      const prefab=prefabs[inst.prefabId];
      return layer && (prefab || isPlayerSpawn(inst)) ? {inst,layer,prefab}:null;
    })
    .filter(Boolean);

  candidates.sort((a,b)=>layerDrawOrder(b.layer)-layerDrawOrder(a.layer));

  for(const {inst,layer,prefab} of candidates){
    const pos = normalizePosition(inst.position);
    const scale = normalizeScale(inst.scale);
    const par=layer.parallaxSpeed ?? 1;
    const layerScale=layer.scale || 1;
    const baseOffset=(pos.x - cameraX*par)*zoom;
    const rootScreenX=W/2 + baseOffset;
    const rootScreenY=groundY + (layer.offsetY||0)*zoom + pos.y*zoom;

    if(isPlayerSpawn(inst)){
      const radius = 12 * zoom;
      const centerX = rootScreenX;
      const centerY = rootScreenY - 20 * zoom;
      const left = centerX - radius;
      const right = centerX + radius;
      const top = centerY - radius;
      const bottom = centerY + radius;
      if(px>=left && px<=right && py>=top && py<=bottom) return inst;
      continue;
    }

    let part;
    if(prefab.isImage) part=prefab.parts[0];
    else part=prefab.parts.find(p=>p.layer==='near') || prefab.parts[0];
    if(!part) continue;
    const t=part.propTemplate||{};
    const w=t.w || 100;
    const h=t.h || 100;
    const {ax,ay}=computeAnchor(t);
    const sc=layerScale*zoom*scale.x;

    const left=rootScreenX - ax*sc;
    const top =rootScreenY - h*sc;
    const right=left + w*sc;
    const bottom=top + h*sc;
    if(px>=left && px<=right && py>=top && py<=bottom) return inst;
  }
  return null;
}

let draggingCamera=false;
let draggingInst=null;
let lastX=0;
let draggingInstOffset=0;

function pointerClientToWorldX(clientX, layer){
  const rect=canvas.getBoundingClientRect();
  const px=clientX-rect.left;
  const dpr=window.devicePixelRatio||1;
  const W=canvas.width/dpr;
  const par=layer?.parallax ?? 1;
  const baseOffset=(px - W/2)/zoom;
  return baseOffset + cameraX*par;
}

function pointerDown(ev){
  const t=ev.touches?ev.touches[0]:ev;
  lastX=t.clientX;
  if(spawnPlacementMode){
    const spawn = ensurePlayerSpawn();
    const layer = findLayer(spawn.layerId) || findLayer(getDefaultSpawnLayerId());
    if(layer){
      pushHistory();
      const worldX = pointerClientToWorldX(t.clientX, layer);
      const grid = GRID_UNIT || 0;
      const snapped = grid > 0 ? Math.round(worldX / grid) * grid : worldX;
      spawn.position = normalizePosition(spawn.position);
      spawn.position.x = snapped;
      spawn.locked = true;
      selectedInstId = spawn.id;
      refreshInstanceList();
    }
    exitSpawnPlacement();
    return;
  }
  const hit=pickInstanceAt(t.clientX,t.clientY);
  if(hit){
    selectedInstId=hit.id;
    const inst=getSelectedInstance();
    if(inst && !inst.locked){
      pushHistory();
      draggingInst=inst;
      const layerForDrag = findLayer(inst.layerId);
      if(layerForDrag){
        inst.position = normalizePosition(inst.position);
        draggingInstOffset = pointerClientToWorldX(t.clientX, layerForDrag) - inst.position.x;
      } else {
        draggingInstOffset = 0;
      }
    }
    refreshInstanceList();
  }else{
    pushHistory();
    draggingCamera=true;
  }
}
function pointerMove(ev){
  if(!draggingCamera && !draggingInst) return;
  const t=ev.touches?ev.touches[0]:ev;
  const dx=t.clientX-lastX;
  lastX=t.clientX;
  if(draggingInst){
    if(draggingInst.locked){ draggingInst=null; return; }
    const layer=findLayer(draggingInst.layerId);
    if(!layer) return;
    const worldX = pointerClientToWorldX(t.clientX, layer) - draggingInstOffset;
    const grid=GRID_UNIT||0;
    const snapped = grid>0 ? Math.round(worldX/grid)*grid : worldX;
    draggingInst.position = normalizePosition(draggingInst.position);
    if(snapped !== draggingInst.position.x){
      draggingInst.position.x = snapped;
      refreshInstanceList();
    }
  }else if(draggingCamera){
    setCameraX(cameraX - dx*2);
  }
}
function pointerUp(){
  draggingCamera=false;
  draggingInst=null;
  draggingInstOffset=0;
}
canvas.addEventListener('mousedown',pointerDown);
canvas.addEventListener('mousemove',pointerMove);
window.addEventListener('mouseup',pointerUp);
canvas.addEventListener('touchstart',e=>{e.preventDefault();pointerDown(e);},{passive:false});
canvas.addEventListener('touchmove', e=>{e.preventDefault();pointerMove(e);},{passive:false});
canvas.addEventListener('touchend',  e=>{e.preventDefault();pointerUp();},{passive:false});

/*** Buttons & toggles ***/
$('#btnPlacePlayerSpawn').addEventListener('click', () => {
  const spawn = ensurePlayerSpawn();
  spawnPlacementMode = true;
  selectedInstId = spawn.id;
  const canvasEl = document.getElementById('sceneCanvas');
  canvasEl?.classList.add('spawn-mode');
  refreshInstanceList();
});
$('#btnJitter').addEventListener('click',()=>{
  pushHistory();
  const posRange=Math.abs(parseFloat($('#jitterRange').value)||0);
  const scaleRange=Math.abs(parseFloat($('#jitterScaleRange').value)||0);
  if(posRange<=0 && scaleRange<=0) return;
  for(const inst of instances){
    if(inst.layerId!==activeLayerId || inst.locked) continue;
    if(posRange>0){
      const delta = (Math.random()*2-1)*posRange;
      inst.position = normalizePosition(inst.position);
      inst.position.x += delta;
      const grid = GRID_UNIT || 0;
      if(grid > 0){
        inst.position.x = Math.round(inst.position.x / grid) * grid;
      }
    }
    if(scaleRange>0){
      const sx=1 + (Math.random()*2-1)*scaleRange;
      const sy=1 + (Math.random()*2-1)*scaleRange;
      inst.scale = normalizeScale(inst.scale);
      inst.scale.x=Math.max(0.1,sx);
      inst.scale.y=Math.max(0.1,sy);
    }
  }
  refreshInstanceList();
});
$('#btnDeleteInst').addEventListener('click',deleteSelectedInstance);
$('#btnDuplicateInst').addEventListener('click',duplicateSelectedInstance);
$('#btnUndo').addEventListener('click',undo);
$('#chkDebug').addEventListener('change',e=>{debugOverlay=e.target.checked;});
$('#btnPlaceRow').addEventListener('click',()=>{
  const pid=$('#libPrefab').value;
  const count=parseInt($('#libCount').value,10)||1;
  if(!prefabs[pid]){ alert('No prefab selected'); return; }
  pushHistory();
  for(let i=0;i<count;i++) addInstance(activeLayerId,pid);
  refreshInstanceList();
});
$('#btnAddParallaxLayer').addEventListener('click',()=>{
  const count=getParallaxLayerCount();
  if(count>=10){ alert('Parallax layer limit reached (10).'); return; }
  pushHistory();
  const id=`bg${count+1}`;
  layers.splice(count,0,{
    id,
    name:`Parallax ${count+1}`,
    type:"parallax",
    parallaxSpeed:0.15 + 0.1*count,
    offsetY:-140 + 20*count,
    separation:220,
    scale:0.6 + 0.05*count,
    meta:{},
  });
  rebuildActiveLayerSelect();
  rebuildLayerStack();
  syncActiveLayerFields();
});

/*** Export / Import map ***/
async function exportLayout(){
  const statusEl = $('#exportStatus');
  const textEl = $('#exportText');
  try{
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      exportedAt: new Date().toISOString(),
    };
    const json=JSON.stringify(area,null,2);
    textEl.value=json;
    const dataUrl='data:application/json;charset=utf-8,'+encodeURIComponent(json);
    window.open(dataUrl,'_blank');
    statusEl.style.color='#22c55e';
    statusEl.textContent='Opened area JSON in new tab. If blocked, copy JSON below.';
  }catch(err){
    statusEl.style.color='#f97316';
    statusEl.textContent='Export error: '+err.message+' (JSON mirrored below)';
  }
}
$('#btnExportMap').addEventListener('click', exportLayout);

function pruneOldPreviewPayloads(){
  try {
    if (typeof localStorage === 'undefined') return;
    const expiry = Date.now() - 10 * 60 * 1000;
    for (let i = localStorage.length - 1; i >= 0; i--){
      const key = localStorage.key(i);
      if (!key || !key.startsWith(PREVIEW_STORAGE_PREFIX)) continue;
      let remove = false;
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          remove = true;
        } else {
          const payload = JSON.parse(raw);
          if (!payload || typeof payload !== 'object' || !Number.isFinite(payload.createdAt) || payload.createdAt < expiry){
            remove = true;
          }
        }
      } catch (_err) {
        remove = true;
      }
      if (remove) {
        try { localStorage.removeItem(key); } catch (_rmErr) { /* ignore */ }
      }
    }
  } catch (_error) {
    // Ignore storage errors (e.g., privacy mode)
  }
}

function storePreviewPayload(layout){
  const token = `mp${Date.now().toString(36)}${Math.random().toString(36).slice(2,8)}`;
  const safeLayout = JSON.parse(JSON.stringify(layout));
  const payload = {
    createdAt: Date.now(),
    layout: safeLayout,
    version: 1,
  };
  let stored = false;

  if (typeof localStorage !== 'undefined') {
    try {
      pruneOldPreviewPayloads();
      localStorage.setItem(PREVIEW_STORAGE_PREFIX + token, JSON.stringify(payload));
      stored = true;
    } catch (error) {
      console.error('[map-editor] Failed to store preview payload', error);
    }
  }

  return { token, payload, stored };
}

function launchGameplayPreview(){
  try {
    const area = buildAreaDescriptor();
    area.meta = {
      ...area.meta,
      editorPreview: true,
      exportedAt: new Date().toISOString(),
    };
    const { token, payload, stored } = storePreviewPayload(area);
    if (!token) {
      throw new Error('Failed to create preview token.');
    }
    if (!stored) {
      console.warn('[map-editor] Preview payload could not be persisted; relying on direct preview handshake.');
    }
    const url = new URL('./index.html', window.location.href);
    url.searchParams.set('mode', 'game');
    url.searchParams.set('preview', token);
    const win = window.open(url.toString(), '_blank');
    if (!win) {
      alert('Preview window was blocked. Allow pop-ups for this site to enable gameplay preview.');
      return;
    }
    try {
      const targetOrigin = url.origin || window.location.origin || '*';
      const message = {
        type: 'map-editor-preview',
        token,
        payload,
      };
      win.postMessage(message, targetOrigin);
      setTimeout(() => {
        try {
          win.postMessage(message, targetOrigin);
        } catch (_err) {
          // Ignore follow-up delivery errors.
        }
      }, 50);
    } catch (postError) {
      console.warn('[map-editor] Failed to transmit preview payload to new window', postError);
    }
    win?.focus?.();
  } catch (error) {
    console.error('[map-editor] Failed to launch gameplay preview', error);
    alert('Failed to launch gameplay preview: ' + error.message);
  }
}

$('#btnLoadMap').addEventListener('click', async () => {
  const select = $('#mapRepoSelect');
  const mapId = select?.value || DEFAULT_LAYOUT_META.areaId;
  await loadRepositoryMapById(mapId);
});

$('#btnPreviewGameplay').addEventListener('click', launchGameplayPreview);
const spawnHeightField = $('#spawnPosY');
if (spawnHeightField){
  ['change','blur','input'].forEach(evt => {
    spawnHeightField.addEventListener(evt, updateSpawnHeightFromField);
  });
}

/*** Loaders for prefab/image ***/
$('#btnLoadPrefab').addEventListener('click',()=>{
  const inp=document.createElement('input');
  inp.type='file';
  inp.accept='application/json';
  inp.onchange=e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
      try{
        const parsed = JSON.parse(r.result);
        registerPrefab(parsed).catch(err=>{
          console.error('[map-editor] Failed to register prefab', err);
          alert('Invalid JSON: '+(err?.message||err));
        });
      }catch(err){
        alert('Invalid JSON: '+err.message);
      }
    };
    r.readAsText(f);
  };
  inp.click();
});
$('#btnLoadImage').addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';                  // <-- required
  inp.accept = 'image/*';
  inp.onchange = e => {
    const f = e.target.files[0];
    if (!f) return;
    registerImagePrefab(f);
  };
  inp.click();
});

/*** Init ***/
$('#gridSize').value = GRID_UNIT;
$('#gridSize').disabled = true;
$('#gridSize').title = `Grid locked to ${GRID_UNIT}px (configured)`;
populateRepositorySelect();
rebuildActiveLayerSelect();
rebuildLayerStack();
syncActiveLayerFields();
ensurePlayerSpawn();
refreshInstanceList();
requestAnimationFrame(render);

(async () => {
  try {
    await ensureConfiguredPrefabsLoaded();
    const initialId = layoutMeta.repositoryId || layoutMeta.areaId || DEFAULT_LAYOUT_META.areaId;
    await loadRepositoryMapById(initialId);
  } catch (error) {
    console.error('[map-editor] failed to load initial map', error);
  }
})();
</script>
</body>
</html>
