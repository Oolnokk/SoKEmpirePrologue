<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>KHY Stage Game - Fixed Version</title>
  <style>
    :root{
      --controls-gap: clamp(10px, 2vw, 20px);
      --action-size: 180px; /* used for action button grid size */
      --interact-gap: 12px;   /* visual gap between action grid and E/interact */

      --page-max: 1280px; --gap: 20px; --pad: 16px; --card-br: 16px; --border: 1px solid #232325;
      --glass: #0f0f10cc; --overlay-bg: linear-gradient(to top, rgba(0,0,0,0.55), rgba(0,0,0,0.15) 60%, transparent);
      --stage-h: clamp(320px, 60vh, 720px); --muted: #9aa6b2;
    }
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #f5f5f6; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    main.stack { display: flex; flex-direction: column; gap: var(--gap); max-width: var(--page-max); margin-inline: auto; padding: var(--pad); }
    .widget { position: relative; background: var(--glass); border: var(--border); border-radius: var(--card-br); padding: clamp(12px, 2.6vw, 24px); }
    .widget--clear { background: transparent; border: 0; padding: 0; }
    /* Ensure the stage always fills the available width. By explicitly setting
       width:100% the stage container will adapt to mobile screen sizes instead
       of retaining intrinsic width from its content. */
    .stage { position: relative; width: 100%; height: var(--stage-h); border-radius: var(--card-br); overflow: hidden; background: #0c0d10; outline: 1px solid #232325; isolation: isolate; display: grid; place-items: center; }
    canvas#game { width: 100%; height: 100%; display: block; image-rendering: pixelated; }
    .controls-overlay { position: absolute; left: 0; right: 0; bottom: 0; top: 0; z-index: 3; pointer-events: none; }
    
    /* Virtual Joystick */
    .joystick-area {
      position: absolute;
      left: 20px;
      bottom: 20px;
      width: 140px;
      height: 140px;
      pointer-events: auto;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      backdrop-filter: blur(4px);
    }
    
    .joystick-stick {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease-out;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .joystick-stick.active {
      background: rgba(100, 200, 255, 0.5);
      border-color: rgba(100, 200, 255, 0.8);
      box-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
    }
    
    /* Action Buttons */
    .action-buttons {
      position: absolute;
      right: 20px;
      bottom: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 15px;
      width: 180px;
      height: 180px;
      pointer-events: auto;
    }
    
    .action-btn {
      border: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      color: #f5f5f6;
      font-weight: 700;
      font-size: 18px;
      outline: 2px solid rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(4px);
      cursor: pointer;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      touch-action: manipulation;
    }
    
    .action-btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.25);
      outline-width: 3px;
    }
    
    .action-btn.attack-a {
      grid-column: 2;
      grid-row: 1;
      background: rgba(239, 68, 68, 0.2);
      outline-color: rgba(239, 68, 68, 0.4);
    }
    
    .action-btn.attack-a:active {
      background: rgba(239, 68, 68, 0.35);
    }
    
    .action-btn.attack-b {
      grid-column: 2;
      grid-row: 2;
      background: rgba(249, 115, 22, 0.2);
      outline-color: rgba(249, 115, 22, 0.4);
    }
    
    .action-btn.attack-b:active {
      background: rgba(249, 115, 22, 0.35);
    }
    
    .action-btn.jump {
      grid-column: 1;
      grid-row: 1 / 3;
      background: rgba(34, 197, 94, 0.2);
      outline-color: rgba(34, 197, 94, 0.4);
      font-size: 24px;
    }
    
    .action-btn.jump:active {
      background: rgba(34, 197, 94, 0.35);
    }
    
    /* Interact Button */
    .interact-btn {
      position: absolute;
      bottom: 220px;
      right: 20px;
      width: 80px;
      height: 80px;
      border: 0;
      border-radius: 50%;
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
      font-weight: 700;
      font-size: 32px;
      outline: 2px solid rgba(34, 197, 94, 0.4);
      backdrop-filter: blur(4px);
      cursor: pointer;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      touch-action: manipulation;
    }
    
    .interact-btn:active {
      transform: scale(0.95);
      background: rgba(34, 197, 94, 0.35);
    }
    
    /* Top UI Bar */
    .top-ui {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
      pointer-events: auto;
      z-index: 4;
    }
    
    .ui-btn {
      border: 0;
      border-radius: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.08);
      color: #f5f5f6;
      font-weight: 700;
      font-size: 14px;
      outline: 1px solid rgba(255, 255, 255, 0.14);
      cursor: pointer;
      backdrop-filter: blur(4px);
      transition: all 0.1s;
      touch-action: manipulation;
    }
    
    .ui-btn:active {
      transform: translateY(1px);
      background: rgba(255, 255, 255, 0.15);
    }
    
    .help-panel {
      position: absolute;
      top: 50px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      color: #ccc;
      max-width: 220px;
      pointer-events: auto;
      display: none;
    }
    
    .help-panel.visible {
      display: block;
    }
    
    .help-panel h4 {
      margin: 0 0 8px 0;
      color: #fff;
      font-size: 13px;
    }
    
    .help-panel div {
      margin: 4px 0;
    }
    
    .help-panel .key {
      color: #86efac;
      font-weight: bold;
    }
    .settings { display: grid; gap: clamp(10px, 2vw, 14px); grid-template-columns: 1fr; }
    .box { padding: clamp(10px, 1.6vw, 16px); border-radius: 14px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.05); backdrop-filter: blur(4px); line-height: 1.5; min-height: 44px; }
    .label { font-size: 12px; opacity: 0.65; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
    .fields { display: grid; gap: 10px; grid-template-columns: repeat(2, minmax(180px, 1fr)); }
    .fields label { font-size: 12px; color: var(--muted); display: grid; gap: 6px; }
    .fields input[type="range"]{ width: 100%; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .pill { font-size: 12px; color: var(--muted); border: 1px solid #2b3947; border-radius: 999px; padding: 2px 8px; }
    @media (orientation: landscape) {
      :root { --stage-h: clamp(360px, 72vh, 760px); }
      .control-pad button { font-size: 18px; }
    }
    .sprite-debug { position: absolute; inset: 10px auto auto 10px; z-index: 5; font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #e5e7eb; background: rgba(17,24,39,0.76); border: 1px solid rgba(255,255,255,0.16); border-radius: 10px; padding: 8px 10px; max-width: 42ch; backdrop-filter: blur(4px); }
    .sprite-debug h4 { margin: 0 0 6px 0; font-size: 12px; letter-spacing: .2px; opacity: .85; }
    .sprite-debug .grid { display: grid; grid-template-columns: auto auto; gap: 6px 12px; align-items: start; }
    .sprite-debug .ok { color: #86efac; }
    .sprite-debug .bad { color: #fca5a5; }
    .sprite-debug .warn { color: #fbbf24; }
    .sprite-debug .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .controls-info { 
      position: absolute; 
      top: 10px; 
      right: 10px; 
      z-index: 10; 
      background: rgba(0,0,0,0.8); 
      border: 1px solid #333; 
      border-radius: 8px; 
      padding: 10px; 
      font-size: 11px; 
      color: #ccc;
      max-width: 200px;
    }
    .controls-info h4 { margin: 0 0 5px 0; color: #fff; font-size: 12px; }
    .controls-info div { margin: 2px 0; }
    .controls-info .key { color: #86efac; font-weight: bold; }
    
    /* Health bar styles */
    .health-bar {
      position: absolute;
      top: 32px;
      left: 14px;
      z-index: 10;
      width: 200px;
      height: 20px;
      background: rgba(0,0,0,0.8);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 2px;
      backdrop-filter: blur(4px);
    }
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ef4444 0%, #f87171 50%, #ef4444 100%);
      border-radius: 8px;
      transition: width 0.15s ease-out;
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
    .health-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      font-weight: bold;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
    }
    
    /* Stamina bar styles - now 1/3 width and positioned at footing text location */
    .stamina-bar {
      position: absolute;
      top: 55px;
      left: 14px;
      z-index: 10;
      width: 200px;
      height: 20px;
      background: rgba(0,0,0,0.8);
      border: 2px solid #333;
      border-radius: 10px;
      padding: 2px;
      backdrop-filter: blur(4px);
    }
    .stamina-fill {
      height: 100%;
      background: linear-gradient(90deg, #22c55e 0%, #86efac 50%, #22c55e 100%);
      border-radius: 8px;
      transition: width 0.15s ease-out, background 0.2s;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }
    .stamina-fill.low {
      background: linear-gradient(90deg, #ef4444 0%, #fca5a5 50%, #ef4444 100%);
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
    .stamina-fill.dashing {
      background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #3b82f6 100%);
      box-shadow: 0 0 12px rgba(59, 130, 246, 0.8);
      animation: pulse 0.3s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { opacity: 0.8; }
      to { opacity: 1; }
    }
    .stamina-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      font-weight: bold;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
    }
    
    /* Footing bar styles - below stamina */
    .footing-bar {
      position: absolute;
      top: 78px;
      left: 14px;
      z-index: 10;
      width: 200px;
      height: 16px;
      background: rgba(0,0,0,0.8);
      border: 2px solid #333;
      border-radius: 8px;
      padding: 2px;
      backdrop-filter: blur(4px);
    }
    .footing-fill {
      height: 100%;
      background: linear-gradient(90deg, #d4d4d8 0%, #f4f4f5 50%, #d4d4d8 100%);
      border-radius: 6px;
      transition: width 0.15s ease-out;
      box-shadow: 0 0 6px rgba(212, 212, 216, 0.5);
    }
    .footing-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 9px;
      font-weight: bold;
      color: #27272a;
      text-shadow: 0 1px 1px rgba(255,255,255,0.5);
      pointer-events: none;
    }
  
    @media (max-width: 768px) {
      :root { --stage-h: clamp(340px, 70vh, 760px); }
      
      .control-pad { width: 100%; gap: 8px; }
      .control-pad button { padding: 12px 10px; font-size: 15px; }
    }
    @media (max-width: 480px) {
      :root { --stage-h: clamp(360px, 74vh, 780px); }
      .controls-info { display: none; }
    }

    /* On very small screens, allow the main stack container to use the full
       available width instead of clamping to a desktop max. This prevents
       horizontal scrolling on mobile devices. */
    @media (max-width: 768px) {
      main.stack { max-width: 100%; }
    }
    
    /* Parallax interaction prompt styles */
    .interact-prompt {
      position: absolute;
      z-index: 15;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #22c55e;
      border-radius: 12px;
      padding: 12px 18px;
      font-size: 14px;
      font-weight: bold;
      color: #22c55e;
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
      animation: promptPulse 1s ease-in-out infinite;
      pointer-events: none;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
      display: none;
    }
    
    @keyframes promptPulse {
      0%, 100% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
    }
    
    /* Area transition overlay */
    .transition-overlay {
      position: absolute;
      inset: 0;
      background: black;
      z-index: 20;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    
    .transition-overlay.active {
      opacity: 1;
    }
    
    /* Area name display */
    .area-name {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 25;
      font-size: 32px;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      pointer-events: none;
    }
    
    .area-name.visible {
      opacity: 1;
    }

    /* Styles for the fullscreen toggle button. It now sits near the bottom
       right of the controls overlay with its own pointer events so it can be
       tapped on mobile. We repositioned it and added pointer-events: auto
       because the parent overlay has pointer-events: none. */
    .fullscreen-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      right: auto;
      bottom: auto;
      z-index: 4;
      border: 0;
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.08);
      color: #f5f5f6;
      font-weight: 700;
      font-size: 14px;
      outline: 1px solid rgba(255,255,255,0.14);
      cursor: pointer;
      backdrop-filter: blur(4px);
      transition: all 0.1s;
      /* enable interaction despite the parent overlay having pointer-events:none */
      pointer-events: auto;
    }
    .fullscreen-btn:active {
      transform: translateY(1px);
      background: rgba(255,255,255,0.15);
    }
    
  </style>

  
<!-- removed obsolete style block: Controls pinned to bottom of the viewport (safe-area aware) -->


  
<!-- removed obsolete style block: Lock all control overlays to the viewport (top-right) -->


  <style>

  /* === Lock controls to the child viewport (.stage), not the window === */
  .stage{ position: relative; }

  /* Override previous fixed positioning */
  .stage .joystick-area,
  .stage .action-buttons,
  .stage .interact-btn,
  .stage .top-ui{
    position: absolute !important;
    z-index: 1000;
  }
  .stage .joystick-area{
    left: var(--controls-gap);
    bottom: var(--controls-gap);
  }
  .stage .action-buttons{
    right: var(--controls-gap);
    bottom: var(--controls-gap);
  }
  /* Interact sits above the action cluster */
  .stage .interact-btn{
    right: var(--controls-gap);
    bottom: calc(220px + var(--controls-gap));
  }
  /* Top-right overlay inside the stage area */
  .stage .top-ui{
    top: var(--controls-gap);
    right: var(--controls-gap);
  }

  /* Remove page-level bottom padding that we added for window-fixed controls */
  main.stack{ padding-bottom: 0 !important; }

  </style>

  <style>

  /* === Controls v2: anchored near .stage bottom, 75% size, circular Jump === */
  :root{
    /* Scale used across joystick + action cluster + interact */
    --control-scale: 0.75; /* used by joystick/action/interact (JS: n/a) */
    --stage-bottom-offset: clamp(10px, 1.4vw, 14px); /* visual gap above .stage bottom */
  }

  /* Keep .stage as the positioning context */
  .stage{ position: relative; }

  /* Joystick: anchor bottom-left, scale from bottom-left so gap stays constant */
  .stage .joystick-area{
    left: var(--controls-gap);
    bottom: var(--stage-bottom-offset);
    transform: scale(var(--control-scale));
    transform-origin: bottom left;
  }

  /* Action cluster: anchor bottom-right, scale from bottom-right */
  .stage .action-buttons{
    right: var(--controls-gap);
    bottom: var(--stage-bottom-offset);
    transform: scale(var(--control-scale));
    transform-origin: bottom right;
  }

  /* Interact button: sits above the action cluster; scale and keep spacing proportional */
  .stage .interact-btn{
    right: var(--controls-gap);
    transform: scale(var(--control-scale));
    transform-origin: bottom right;
    bottom: calc(var(--stage-bottom-offset) + 220px * var(--control-scale));
  }
  /* Fallback if the browser doesn't support calc() multiplication */
  @supports not (bottom: calc(10px * 0.5)){
    .stage .interact-btn{ bottom: calc(var(--stage-bottom-offset) + 144px); } /* (action-size + interact-gap) * control-scale default = (180+12)*0.75 = 144px */
  }

  /* Make Jump a true circle by keeping it in a single grid cell */
  .action-btn.jump{
    grid-column: 1;
    grid-row: 2; /* bottom-left cell for easier reach */
  }

  </style>

  <style>

  /* === Overlay aligned to stage + bottom offset + 75% scale + round Jump === */
  /* removed duplicate :root for --stage-bottom-offset; single source of truth kept above */

  /* Make the common parent of .stage and .controls-overlay a positioning context */
  .widget.widget--clear{ position: relative; }

  /* Pin overlay to the stage area (since it's a sibling, not a child) */
  .controls-overlay{
    position: absolute !important;
    inset: 0;
    pointer-events: none; /* children re-enable */
    z-index: 20;
  }

  /* Place and scale controls inside the overlay; keep bottom gap consistent */
  .controls-overlay .joystick-area,
  .controls-overlay .action-buttons,
  .controls-overlay .interact-btn{
    position: absolute !important;
    pointer-events: auto;
    z-index: 1000;
  }
  .controls-overlay .joystick-area{
    left: var(--controls-gap);
    bottom: var(--stage-bottom-offset);
    transform: scale(var(--control-scale));
    transform-origin: bottom left;
  }
  .controls-overlay .action-buttons{
    right: var(--controls-gap);
    bottom: var(--stage-bottom-offset);
    transform: scale(var(--control-scale));
    transform-origin: bottom right;
  }
  .controls-overlay .interact-btn{
    right: var(--controls-gap);
    bottom: calc(var(--stage-bottom-offset) + (var(--action-size) * var(--control-scale)) + (var(--interact-gap) * var(--control-scale)));
    transform: scale(var(--control-scale));
    transform-origin: bottom right;
  }
  @supports not (bottom: calc(10px * 0.5)){
    .controls-overlay .interact-btn{ bottom: calc(var(--stage-bottom-offset) + 144px); } /* (action-size + interact-gap) * control-scale default = (180+12)*0.75 = 144px */
  }

  /* Keep Jump a true circle (single grid cell) */
  .action-btn.jump{
    grid-column: 1;
    grid-row: 2;
    border-radius: 50%;
  }

  </style>
</head>
<body>
  <main class="stack">
    <section class="widget widget--clear">
      <div class="stage" id="gameStage">
        <canvas id="game" width="720" height="460" aria-label="Stick figure canvas"></canvas>
        
        <!-- Keyboard controls info panel -->
        <!-- Health bar -->
        <div class="health-bar">
          <div class="health-fill" id="healthFill"></div>
          <div class="health-label" id="healthLabel">HP: 100</div>
        </div>
        
        <!-- Stamina bar -->
        <div class="stamina-bar">
          <div class="stamina-fill" id="staminaFill"></div>
          <div class="stamina-label" id="staminaLabel">STAMINA</div>
        </div>
        
        <!-- Footing bar -->
        <div class="footing-bar">
          <div class="footing-fill" id="footingFill"></div>
          <div class="footing-label" id="footingLabel">FOOTING</div>
        </div>
        
        <!-- Door Interaction Prompt -->
        <div class="interact-prompt" id="interactPrompt">
          Press E to Enter
        </div>
        
        <!-- Transition Overlay -->
        <div class="transition-overlay" id="transitionOverlay"></div>
        <div class="area-name" id="areaName"></div>
        
        <div class="controls-overlay">
          <!-- Top UI Bar -->
          <div class="top-ui">
            <button type="button" id="btnHelp" class="ui-btn">‚ùì Help</button>
            <button type="button" id="btnFullscreen" class="ui-btn">‚§¢ Full</button>
          </div>
          
          <!-- Help Panel (hidden by default) -->
          <div class="help-panel" id="helpPanel">
            <h4>Controls</h4>
            <div><span class="key">Joystick</span> - Move & Aim</div>
            <div><span class="key">Green</span> - Jump</div>
            <div><span class="key">Red</span> - Attack A (Combo)</div>
            <div><span class="key">Orange</span> - Attack B (Quick)</div>
            <div><span class="key">E Button</span> - Interact</div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #444;">
              <span class="key">Keyboard:</span> WASD move, E/F attack
            </div>
          </div>
          
          <!-- Virtual Joystick -->
          <div class="joystick-area" id="joystickArea">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
          </div>
          
          <!-- Action Buttons -->
          <div class="action-buttons">
            <button type="button" id="btnJump" class="action-btn jump">‚Üë</button>
            <button type="button" id="btnAttackA" class="action-btn attack-a">A</button>
            <button type="button" id="btnAttackB" class="action-btn attack-b">B</button>
          </div>
          
          <!-- Interact Button -->
          <button type="button" id="btnInteract" class="interact-btn">E</button>
        </div>
      </div>
    
    <div id="aiHud" style="position:absolute; top:8px; left:8px; z-index:50; padding:6px 8px; background:rgba(10,10,14,.7); color:#7dd3fc; font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; border:1px solid rgba(125,211,252,.3); border-radius:8px; display:none; pointer-events:none;">
      NPC HUD
    </div>
    </section>

    <section class="widget">
      <div class="settings" id="settingsGrid">
        <div class="box" id="appSettingsBox">
          <div class="label">App Settings</div>
          <div class="fields">
            <label>Fighter <select id="fighterSelect"></select></label>
            <label>Character scale <input id="actorScale" type="range" min="0.50" max="1.10" step="0.02" value="0.70"></label>
            <label>Ground height <input id="groundRatio" type="range" min="0.60" max="0.92" step="0.01" value="0.70"></label>
            <label>Hand collider size <input id="handMultiplier" type="range" min="1.0" max="4.0" step="0.1" value="2.0"></label>
            <label>Foot collider size <input id="footMultiplier" type="range" min="0.5" max="2.0" step="0.1" value="1.0"></label>
            <label>Authored weight <input id="wAuth" type="range" min="0" max="1" step="0.05" value="0.6"></label>
            <label>Physics weight <input id="wPhys" type="range" min="0" max="1" step="0.05" value="0.4"></label>
            <label class="row">Calves-only IK <input id="ikCalvesOnly" type="checkbox" checked style="margin-left:auto;"></label>
            <label class="row">Facing locks during attack <input id="lockFacing" type="checkbox" checked style="margin-left:auto;"></label>
          </div>
          <div class="row" style="margin-top:6px;">
            <span class="pill">Walk overwrites Stance + lerps back</span>
            <span class="pill">Flip on direction (initial press)</span>
            <span class="pill">Calf ragdoll mid-air (non-attack)</span>
          </div>
        </div>
        <div class="box" id="statusBox">
          <div class="label">Game Status</div>
          <div id="statusInfo" style="font-size: 12px; color: #86efac;">
            Game initialized successfully! All systems operational.
          </div>
        </div>

    <!-- Combo configuration box -->
    <div class="box" id="comboBox">
      <div class="label">Combo Settings</div>
      <div id="comboFields" class="fields"></div>
    </div>

    <!-- Manual hit count slider -->
    <div class="box" id="hitBox">
      <div class="label">Manual Hit Count</div>
      <input id="hitSlider" type="range" min="0" max="4" step="1" value="0" style="width: 100%;">
    </div>
      </div>
    </section>
  </main>

  <script>
  'use strict';
  
  // ====== PARALLAX ENVIRONMENT SYSTEM ======
  const PARALLAX = {
    layers: [],
    currentAreaId: 'main_hall',
    areas: {}
  };
  
  // Define areas with their parallax layers and door locations
  function initParallaxSystem() {
    // Main Hall Area
    PARALLAX.areas.main_hall = {
      name: 'Main Hall',
      layers: [
        { 
          url: 'https://i.imgur.com/placeholder1.jpg', // Replace with your imgur URLs
          parallaxSpeed: 0.02,  // Almost no movement for far background
          z: 0,
          repeat: true
        },
        { 
          url: 'https://i.imgur.com/placeholder2.jpg',
          parallaxSpeed: 0.15,
          z: 1,
          repeat: true
        },
        { 
          url: 'https://i.imgur.com/placeholder3.jpg',
          parallaxSpeed: 0.4,
          z: 2,
          repeat: true
        }
      ],
      doors: [
        {
          x: 800,     // World X position
          y: -50,     // World Y position  
          width: 120,
          height: 180,
          targetArea: 'training_room',
          spawnX: 100,  // Where player spawns in target area
          spawnY: 0
        }
      ]
    };
    
    // Training Room Area
    PARALLAX.areas.training_room = {
      name: 'Training Room',
      layers: [
        { 
          url: 'https://i.imgur.com/placeholder4.jpg',
          parallaxSpeed: 0.03,
          z: 0,
          repeat: true
        },
        { 
          url: 'https://i.imgur.com/placeholder5.jpg',
          parallaxSpeed: 0.2,
          z: 1,
          repeat: true
        }
      ],
      doors: [
        {
          x: 100,
          y: -50,
          width: 120,
          height: 180,
          targetArea: 'main_hall',
          spawnX: 750,
          spawnY: 0
        }
      ]
    };
    
    loadParallaxLayers(PARALLAX.currentAreaId);
  }
  
  // Load images for parallax layers
  function loadParallaxLayers(areaId) {
    const area = PARALLAX.areas[areaId];
    if (!area) return;
    
    PARALLAX.layers = [];
    area.layers.forEach((layerData, index) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        console.log(`Parallax layer ${index} loaded for ${areaId}`);
        PARALLAX.layers[index].loaded = true;
      };
      img.onerror = () => {
        console.warn(`Failed to load parallax layer ${index} for ${areaId}, using fallback`);
      };
      img.src = layerData.url;
      
      PARALLAX.layers.push({
        image: img,
        parallaxSpeed: layerData.parallaxSpeed,
        z: layerData.z,
        repeat: layerData.repeat,
        loaded: false
      });
    });
  }
  
  // Draw parallax background
  function drawParallaxBackground(cx, cameraX, cameraY) {
    // Sort layers by z-index
    const sortedLayers = [...PARALLAX.layers].sort((a, b) => a.z - b.z);
    
    sortedLayers.forEach(layer => {
      if (!layer.loaded || !layer.image.complete) {
        // Draw placeholder
        cx.fillStyle = `rgba(${20 + layer.z * 15}, ${30 + layer.z * 15}, ${40 + layer.z * 15}, 0.5)`;
        cx.save();
const __prevAlpha_cx = cx.globalAlpha;
cx.globalAlpha = (typeof __prevAlpha_cx==='number' ? __prevAlpha_cx : 1) * 0.7;
cx.fillRect(0,0,cx.canvas.width,cx.canvas.height);
cx.globalAlpha = __prevAlpha_cx;
cx.restore();;
        return;
      }
      
      const offsetX = cameraX * layer.parallaxSpeed;
      const offsetY = cameraY * layer.parallaxSpeed * 0.5; // Less vertical parallax
      
      const imgWidth = layer.image.width;
      const imgHeight = layer.image.height;
      
      // Scale to fit canvas height
      const scale = cx.canvas.height / imgHeight;
      const scaledWidth = imgWidth * scale;
      const scaledHeight = cx.canvas.height;
      
      if (layer.repeat) {
        // Repeating pattern
        const startX = Math.floor(-offsetX / scaledWidth) * scaledWidth - offsetX;
        const numRepeats = Math.ceil(cx.canvas.width / scaledWidth) + 2;
        
        for (let i = 0; i < numRepeats; i++) {
          cx.drawImage(
            layer.image,
            startX + i * scaledWidth,
            -offsetY,
            scaledWidth,
            scaledHeight
          );
        }
      } else {
        // Single image
        cx.drawImage(
          layer.image,
          -offsetX,
          -offsetY,
          scaledWidth,
          scaledHeight
        );
      }
    });
  }
  
  // Check if player is near a door
  function checkDoorProximity() {
    const area = PARALLAX.areas[PARALLAX.currentAreaId];
    if (!area || !area.doors) return null;
    
    const playerX = MOVE.pos.x;
    const playerY = MOVE.pos.y;
    
    for (const door of area.doors) {
      const dx = Math.abs(playerX - (door.x + door.width / 2));
      const dy = Math.abs(playerY - (door.y + door.height / 2));
      
      if (dx < door.width / 2 + 40 && dy < door.height / 2 + 60) {
        return door;
      }
    }
    return null;
  }
  
  // Transition to new area
  function transitionToArea(targetAreaId, spawnX, spawnY) {
    const overlay = document.getElementById('transitionOverlay');
    const areaName = document.getElementById('areaName');
    const targetArea = PARALLAX.areas[targetAreaId];
    
    if (!targetArea) return;
    
    // Fade out
    overlay.classList.add('active');
    
    setTimeout(() => {
      // Change area
      PARALLAX.currentAreaId = targetAreaId;
      loadParallaxLayers(targetAreaId);
      
      // Move player
      MOVE.pos.x = spawnX;
      MOVE.pos.y = spawnY;
      MOVE.vel.x = 0;
      MOVE.vel.y = 0;
      
      // Show area name
      areaName.textContent = targetArea.name;
      areaName.classList.add('visible');
      
      setTimeout(() => {
        // Fade in
        overlay.classList.remove('active');
        
        setTimeout(() => {
          areaName.classList.remove('visible');
        }, 2000);
      }, 500);
    }, 500);
  }
  
  // Update interaction prompt
  function updateInteractPrompt() {
    const prompt = document.getElementById('interactPrompt');
    const nearDoor = checkDoorProximity();
    
    if (nearDoor && !INTERACTION.transitioning) {
      prompt.style.display = 'block';
      
      // Position prompt in screen space (not world space)
      const stage = document.getElementById('gameStage');
      const stageRect = stage.getBoundingClientRect();
      
      const cam = (typeof CAMERA !== 'undefined' ? CAMERA : (typeof CAM !== 'undefined' ? CAM : { x: 0, y: 0 }));
// Calculate screen position based on camera
      const screenX = (stageRect.width / 2) + ((nearDoor.x + nearDoor.width / 2) - cam.x);
      const screenY = (stageRect.height / 2) + ((nearDoor.y + nearDoor.height / 2) - cam.y) - 100;
      
      prompt.style.left = `${screenX}px`;
      prompt.style.top = `${screenY}px`;
      prompt.style.transform = 'translate(-50%, -100%)';
    } else {
      prompt.style.display = 'none';
    }
  }
  
  // Draw door visualization (in world space)
  function drawDoors(cx) {
    const area = PARALLAX.areas[PARALLAX.currentAreaId];
    if (!area || !area.doors) return;
    
    area.doors.forEach(door => {
      // Draw door outline
      cx.strokeStyle = 'rgba(34, 197, 94, 0.6)';
      cx.lineWidth = 3;
      cx.strokeRect(door.x, door.y, door.width, door.height);
      
      // Draw door fill
      cx.fillStyle = 'rgba(34, 197, 94, 0.1)';
      cx.save();
cx.globalAlpha = 0.6;
cx.fillStyle = (door.fill || 'rgba(255,255,255,0.6)');
cx.fillRect(door.x,door.y,door.width,door.height);
cx.globalAlpha = 1;
cx.lineWidth = Math.max(2, cx.lineWidth||2);
cx.strokeStyle = (door.stroke || '#111');
cx.strokeRect(door.x,door.y,door.width,door.height);
cx.restore();;
      
      // Draw door marker
      cx.fillStyle = 'rgba(34, 197, 94, 0.8)';
      cx.font = 'bold 20px system-ui';
      cx.textAlign = 'center';
      cx.textBaseline = 'middle';
      cx.fillText('üö™', door.x + door.width / 2, door.y + door.height / 2);
    });
  }
  
  // Interaction state
  const INTERACTION = {
    transitioning: false
  };
  
  // Handle interaction input
  function handleInteraction() {
    if (INTERACTION.transitioning) return;
    
    const nearDoor = checkDoorProximity();
    if (nearDoor) {
      INTERACTION.transitioning = true;
      transitionToArea(nearDoor.targetArea, nearDoor.spawnX, nearDoor.spawnY);
      
      setTimeout(() => {
        INTERACTION.transitioning = false;
      }, 1500);
    }
  }
  
  // ====== Config & constants ======
  const CONFIG = {
    actor: { scale: 0.70 },
    groundRatio: 0.70,
    canvas: { w: 720, h: 460, scale: 1 },
    groundY: 380,

    colors: { body:'#e5f0ff', left:'#86efac', right:'#93c5fd', guide:'#233044', hitbox:'#0ea5e9' },

    // Global fallback durations (SLAM uses these)
    durations: { toWindup:1600, toStrike:160, toRecoil:180, toStance:0 },

    parts: {
      hitbox:{ w:135, h:180, r:60, torsoAttach:{ nx:0.5, ny:0.7 } },
      torso:{ len:60 }, arm:{ upper:50, lower:50 }, leg:{ upper:40, lower:40 }, head:{ neck:14, radius:16 }
    },

    hierarchy: { legsFollowTorsoRotation: false },
    ik: { calvesOnly: true },

    basePose: { torso:0, lShoulder:-90, lElbow:0, rShoulder:-90, rElbow:0, lHip:90, lKnee:0, rHip:90, rKnee:0 },
    limits: {
      torso:{ absMin:-45, absMax:90 },
      shoulder:{ relMin:-360, relMax:-90 },
      elbow:{ relMin:-170, relMax:0 },
      hip:{ absMin:90, absMax:210 },
      knee:{ relMin:0, relMax:170 }
    },

    poses: {
      Stance:{ 
        torso:10, lShoulder:-120, lElbow:-120, rShoulder:-65, rElbow:-140, lHip:110, lKnee:40, rHip:30, rKnee:40, 
        rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0, resetFlipsBefore: true,
        allowAiming: true, aimLegs: false  // Allow upper body aiming in stance
      },
      Windup:{
        torso:-35, lShoulder:-360, lElbow:0, rShoulder:-360, rElbow:0, lHip:40, lKnee:90, rHip:-90, rKnee:90,
        rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
        allowAiming: true, aimLegs: false,  // Allow aiming during windup
        anim_events: [
          { time: 0.00, velocityX: -15, velocityY: 0 },
          { time: 0.65, impulse: 320, impulse_angle: -90 }
        ]
      },
      Strike:{
        torso:45, lShoulder:-45, lElbow:0, rShoulder:-45, rElbow:0, lHip:180, lKnee:0, rHip:90, rKnee:0,
        rootMoveVel:{x:0,y:0, flip: false }, impulseMag:0, impulseDirDeg:0,
        allowAiming: true, aimLegs: false,  // Allow aiming during strike
        anim_events: [
          { time: 0.00, impulse: 450, impulse_angle: -45 },
          { time: 0.05, velocityX: 280, velocityY: 120, localVel: true }
        ]
      },
      Recoil:{ durMs:200, phase:'recoil',
        torso:-15, lShoulder:-45, lElbow:0, rShoulder:-45, rElbow:0, lHip:0, lKnee:70, rHip:110, rKnee:0,
        rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
        allowAiming: false, aimLegs: false,  // No aiming during recoil
        anim_events: [
          { time: 0.00, velocityX: 80, velocityY: -40 },
          { time: 0.30, impulse: 120, impulse_angle: 160 }
        ]
      },
      Jump:{ 
        torso:-10, lShoulder:-160, lElbow:-30, rShoulder:-160, rElbow:-30, 
        lHip:120, lKnee:60, rHip:120, rKnee:60, 
        rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
        allowAiming: true, aimLegs: false  // Allow aiming while jumping
      },
      Walk:{ 
        torso:20, lShoulder:-100, lElbow:-100, rShoulder:-100, rElbow:-100,
        lHip:90, lKnee:20, rHip:90, rKnee:20,
        rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
        allowAiming: true, aimLegs: false  // Allow aiming while walking
      }
    },

    fighters: {
      TLETINGAN: {
        actor: { scale: 0.70 },
        parts: { hitbox:{ w:80, h:110, r:60, torsoAttach:{ nx:0.4, ny:0.6 } }, torso:{ len:40 }, arm:{ upper:30, lower:40 }, leg:{ upper:30, lower:30 }, head:{ neck:10, radius:12 } },
        hierarchy: { legsFollowTorsoRotation: false },
        ik: { calvesOnly: true },
        basePose: { torso:0, lShoulder:-90, lElbow:0, rShoulder:-90, rElbow:0, lHip:90, lKnee:0, rHip:90, rKnee:0 },
        limits: { torso:{ absMin:-45, absMax:90 }, shoulder:{ relMin:-360, relMax:-90 }, elbow:{ relMin:-170, relMax:0 }, hip:{ absMin:90, absMax:210 }, knee:{ relMin:0, relMax:170 } },
        offsets: {
          torso: { origin:{ax:0, ay:0}, shoulder:{ax:-8, ay:-5}, hip:{ax:0, ay:0}, neck:{ax:0, ay:0} },
          arm: { upper:{ origin:{ax:0, ay:0}, elbow:{ax:0, ay:0} }, lower:{ origin:{ax:0, ay:0} } },
          leg: { upper:{ origin:{ax:0, ay:0}, knee:{ax:0, ay:0}  }, lower:{ origin:{ax:0, ay:0} } },
          head:{ origin:{ax:-1, ay:6} }
        },
        sprites: {
          torso: "https://i.imgur.com/YatjSyo.png",
          head:  "https://i.imgur.com/WsKQ2Eo.png",
          arm: { upper:"https://i.imgur.com/CAmWLbf.png", lower:"https://i.imgur.com/gOHujif.png" },
          leg: { upper:"https://i.imgur.com/qgcQTmx.png", lower:"https://i.imgur.com/lZbF7j2.png" },
          style: {
            widthFactor: { torso:1.0, armUpper:1.0, armLower:1.0, legUpper:1.0, legLower:1.0, head:1.0 },
            xformUnits: "percent",
            xform: {
              torso:    { ax:-0.5, ay:-0.00, scaleX:4.50, scaleY:4.50, rotDeg:180 },
              head:     { ax:-1.40, ay:-0.20, scaleX:4.50, scaleY:4.50, rotDeg:180 },
              armUpper: { ax:0.00, ay:0.00, scaleX:3.00, scaleY:3.00, rotDeg:0 },
              armLower: { ax:0.00, ay:0.00, scaleX:2.00, scaleY:2.00, rotDeg:0 },
              legUpper: { ax:-0.10, ay:0.10, scaleX:2.0, scaleY:2.0, rotDeg:0 },
              legLower: { ax:-0.2, ay:0.02, scaleX:2, scaleY:2.00, rotDeg:-10 }
            }
          }
        }
      }
    },

    movement: {
      authoredWeight:0.6, physicsWeight:0.4,
      gravity:2400, jumpImpulse:-650, accelX:1500, maxSpeedX:420, friction:8.0, restitution:0.0,
      dashSpeedMultiplier: 2.2,  // Speed multiplier when dashing
      facingSmooth:10.0, attackPhases:['Windup','Strike'], lockFacingDuringAttack:true, rootVelRelative:true
    },
    
    // Mouse aiming configuration
    aiming: {
      enabled: true,
      upperBodyOnly: true,  // Only rotate torso and arms, not legs
      smoothing: 8.0,       // How fast the aim follows mouse (higher = faster)
      maxTorsoAngle: 45,    // Max degrees torso can rotate from base
      maxShoulderAngle: 60, // Max degrees shoulders can rotate for aiming
      flipThreshold: 0.0    // Mouse passes character center to flip
    },
    
    walk: { 
      enabled:true, onlyTorsoLegs:true, baseHz:1.3, speedScale:1.0, minSpeed:80, amp:1.0,
      poses:{ 
        A:{ torso:30, lHip:0, lKnee:45, rHip:180, rKnee:90 }, 
        B:{ torso:40, lHip:180, lKnee:90, rHip:0, rKnee:45 } 
      } 
    },
    ragdoll: {
      killAuthOnActive:true, enabled:true,
      // Disable automatic calf ragdoll mid-air to prevent calves from
      // teleporting during jumps. Stiffness remains for other limbs.
      autoCalvesMidAir:false, stiffness:10.0,
      // Disable ragdoll on calves entirely. This keeps the legs stiff
      // in the air and avoids errant positions when jumping.
      limbs:{ lCalf:false, rCalf:false, lThigh:false, rThigh:false, lUpperArm:false, rUpperArm:false, lForearm:false, rForearm:false, torso:false, head:false }
    },
    
    // Collider configuration - multipliers for different body parts
    colliders: {
      handMultiplier: 2.0,  // Hands are 2x larger than base radius
      footMultiplier: 1.0   // Feet remain at base radius
    },
    
    // Knockback system configuration
    knockback: {
      // Maximum footing value before knockback has no multiplier
      maxFooting: 100,
      // Weapon type modifiers
      weaponTypes: {
        unarmed: { type: 'blunt', multiplier: 1.0 },
        blunt: { multiplier: 1.2 },
        sharp: { multiplier: 0.8 }
      },
      // Current weapon equipped (can be changed per fighter)
      currentWeapon: 'unarmed'
    }
  };

  // ====== Presets & fighter application ======
  CONFIG.presets = {
    SLAM: { 
      poses: JSON.parse(JSON.stringify(CONFIG.poses)), 
      durations: JSON.parse(JSON.stringify(CONFIG.durations)),
      knockbackBase: 250,  // Base knockback force for SLAM attacks (reduced from 350)
      cancelWindow: 0.5  // Can cancel into next attack during last 50% of Recoil phase
    },
    KICK: {
      durations: { toWindup:180, toStrike:110, toRecoil:680, toStance:0 },
      knockbackBase: 180,  // Base knockback force for KICK attacks (reduced from 280)
      cancelWindow: 0.6,  // Can cancel into next attack during last 60% of Recoil (408ms of 680ms)
      poses: {
        Stance: Object.assign(JSON.parse(JSON.stringify(CONFIG.poses.Stance)), { resetFlipsBefore: true }),
        Windup: {
          torso:-10, lShoulder:-100, lElbow:-120, rShoulder:-80, rElbow:-100,
          lHip:110, lKnee:30, rHip:170, rKnee:40,
          rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
          allowAiming: true, aimLegs: true, aimRightLegOnly: true,  // Right leg aims during kick windup!
          anim_events: [{ time: 0.00, velocityX: -80, velocityY: 0 }]
        },
        Strike: {
          torso:90, lShoulder:-27, lElbow:0, rShoulder:90, rElbow:0,
          lHip:87, lKnee:0, rHip:0, rKnee:0,
          rootMoveVel:{x:0,y:0}, impulseMag:120, impulseDirDeg:0,
          allowAiming: true, aimLegs: true, aimRightLegOnly: true,  // Keep aiming through strike
          flip: true, flipAt: 0.1,
          flipParts: ['ARM_R_UPPER','ARM_R_LOWER','LEG_R_UPPER','LEG_R_LOWER'],
          // Introduce a full-body flip at the start of the strike
          fullFlipFacing: true,
          fullFlipAt: 0.1,
          anim_events: [
            { time: 0.00, impulse: 180, impulse_angle: 0 },
            { time: 0.05, velocityX: 0, velocityY: 0, localVel:true }
          ]
        },
        Recoil: {
          torso:-6, lShoulder:-100, lElbow:-120, rShoulder:-90, rElbow:-120,
          lHip:110, lKnee:40, rHip:30, rKnee:50,
          rootMoveVel:{x:0,y:0}, impulseMag:0, impulseDirDeg:0,
          allowAiming: false, aimLegs: false,  // No aiming during recoil
          // Flip back at the end of recoil to revert full-body flip
          flip: true, flipAt: 0.9,
          flipParts: ['ARM_R_UPPER','ARM_R_LOWER','LEG_R_UPPER','LEG_R_LOWER'],
          fullFlipFacing: true,
          fullFlipAt: 0.9,
          anim_events: [{ time: 0.00, velocityX: 0, velocityY: 0 }]
        }
      }
    },
    PUNCH: {
      durations: { toWindup1:180, toWindup2: 180, toStrike1:110, toStrike2:110, toRecoil:200, toStance:120 },
      knockbackBase: 140,  // Base knockback force for PUNCH attacks (reduced from 200)
      cancelWindow: 0.7,  // Can cancel into next attack during last 70% of Recoil (140ms of 200ms)
      poses: {
        Stance: JSON.parse(JSON.stringify(CONFIG.poses.Stance)),
        Windup: JSON.parse(JSON.stringify(CONFIG.poses.Windup)),
        Strike: JSON.parse(JSON.stringify(CONFIG.poses.Strike)),
        Recoil: JSON.parse(JSON.stringify(CONFIG.poses.Recoil)),
        Strike1: Object.assign(JSON.parse(JSON.stringify(CONFIG.poses.Strike)), { durMs:110, phase:'strike', torso:45, rShoulder:-35, rootMoveVel:{x:30,y:0}, impulseMag:90, impulseDirDeg:0, anim_events:[{ time:0.00, velocityX:260, velocityY:0, localVel:true }] }),
        Strike2: Object.assign(JSON.parse(JSON.stringify(CONFIG.poses.Strike)), { durMs:130, phase:'strike', torso:50, rShoulder:-45, rootMoveVel:{x:40,y:0}, impulseMag:110, impulseDirDeg:0, anim_events:[{ time:0.00, velocityX:300, velocityY:0, localVel:true }] })
      },
      // Authorable sequence for a double strike quick attack
      sequence: [
        { pose:'Stance', durKey:'toStance' },
        { pose:'Windup', durKey:'toWindup1' },
        { pose:'Strike1', durKey:'toStrike1' },
        { pose:'Windup', durKey:'toWindup2' },
        { pose:'Strike2', durKey:'toStrike2' },
        { pose:'Recoil', durKey:'toRecoil' },
        { pose:'Stance', durKey:'toStance' }
      ]
    }
  };

  // ------------------------------------------------------------------------
  // Define an alternate Kick preset to use when executing flourish combos. This
  // preset repeats the Windup and Strike phases four times with varying
  // durations, starting very fast and becoming progressively slower. The
  // default poses and durations are cloned from the existing KICK preset
  // ensuring the animation style remains consistent.
  (function defineKickAlt(){
    /**
     * Build an alternate Kick preset that elongates the quick attack into
     * a flourish sequence. It repeats the Windup and Strike phases four
     * times, accelerating through the first two pairs and then slowing
     * down for the final two. The durations are derived from the base
     * Kick preset so changes to Kick automatically reflect here. The
     * final Recoil and Stance durations are taken from the base preset
     * using durKey references. This function also updates any existing
     * combo alt sequences to reference KICK_ALT instead of KICK.
     */
    const base = CONFIG.presets && CONFIG.presets.KICK;
    if (!base) return;
    // Derive baseline durations
    const w0 = base.durations && base.durations.toWindup || 180;
    const s0 = base.durations && base.durations.toStrike || 110;
    // Precompute scaled durations (3√ó speed = 1/3 duration, etc.)
    const d1 = { w: Math.round(w0/3), s: Math.round(s0/3) }; // 3√ó speed
    const d2 = { w: Math.round(w0/2), s: Math.round(s0/2) }; // 2√ó speed
    const d3 = { w: Math.round(w0),   s: Math.round(s0)   }; // normal speed
    const d4 = { w: Math.round(w0*2), s: Math.round(s0*2) }; // 0.5√ó speed
    CONFIG.presets.KICK_ALT = {
      durations: JSON.parse(JSON.stringify(base.durations)),
      poses: JSON.parse(JSON.stringify(base.poses)),
      sequence: [
        { pose:'Windup', durMs: d1.w },
        { pose:'Strike', durMs: d1.s },
        { pose:'Windup', durMs: d2.w },
        { pose:'Strike', durMs: d2.s },
        { pose:'Windup', durMs: d3.w },
        { pose:'Strike', durMs: d3.s },
        { pose:'Windup', durMs: d4.w },
        { pose:'Strike', durMs: d4.s },
        { pose:'Recoil', durKey:'toRecoil' },
        { pose:'Stance', durKey:'toStance' }
      ]
    };
    // Ensure existing altSequence entries referencing KICK are replaced
    if (CONFIG.combo && Array.isArray(CONFIG.combo.altSequence)){
      for (let i=0; i<CONFIG.combo.altSequence.length; i++){
        if (CONFIG.combo.altSequence[i] === 'KICK'){ CONFIG.combo.altSequence[i] = 'KICK_ALT'; }
      }
    }
  })();

  
  // Ensure alt combo entries reference KICK_ALT where appropriate
  // Used after CONFIG.combo is defined and whenever the Combo UI is (re)built.
  function ensureAltSequenceUsesKickAlt(){
    // depends on CONFIG.presets.KICK_ALT, CONFIG.combo.altSequence
    if (!CONFIG || !CONFIG.presets || !CONFIG.presets.KICK_ALT) return;
    if (!CONFIG.combo || !Array.isArray(CONFIG.combo.altSequence)) return;
    for (let i=0; i<CONFIG.combo.altSequence.length; i++){
      if (CONFIG.combo.altSequence[i] === 'KICK'){ CONFIG.combo.altSequence[i] = 'KICK_ALT'; }
    }
  }

  // ====== Small helpers ======
  const TAU=Math.PI*2, deg2rad=(d)=>d*Math.PI/180, rad2deg=(r)=>r*180/Math.PI;
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v)), lerp=(a,b,t)=>a+(b-a)*t;
  const easeInOutCubic=(t)=>t<.5?4*t*t*t:1-(((-2*t+2)**3)/2);
  const now=()=>performance.now(), clone=(o)=>JSON.parse(JSON.stringify(o));
  function mixVec(a,b,t){ return {x: lerp(a.x||0,b.x||0,t), y: lerp(a.y||0,b.y||0,t)}; }
  const angNorm=(a)=>{ a=(a+Math.PI)%TAU; if(a<0)a+=TAU; return a-Math.PI; };
  const lerpAngle=(a,b,t)=> a + angNorm(b-a)*t;
  function addAngles(base,delta){ const out={}; for(const k in base){ out[k]=(base[k]||0)+(delta[k]||0);} return out; }
  function addOffsets(a,b){ const out={}; for(const k in CONFIG.basePose){ out[k]=(a[k]||0)+(b[k]||0);} return out; }
  function scaleOffsets(a,s){ const out={}; for(const k in CONFIG.basePose){ out[k]=(a[k]||0)*s;} return out; }
  function mix(a,b,t){ const out={}; for(const k in CONFIG.basePose){ out[k]=lerp(a[k]||0,b[k]||0,t);} return out; }

  /**
   * Compute the world-space position of the wrist given a shoulder base
   * coordinate, a shoulder absolute angle and an elbow relative angle. This
   * mirrors the calculations in drawArm() but returns the end of the lower
   * arm instead of drawing anything. Offsets and limb lengths come from
   * CONFIG.parts and CONFIG.offsets. See drawArm() for reference.
   * @param {number} baseX - shoulder base X coordinate
   * @param {number} baseY - shoulder base Y coordinate
   * @param {number} shoulderRel - absolute shoulder angle (radians)
   * @param {number} elbowRel - relative elbow angle (radians)
   * @returns {{x:number,y:number}}
   */
  function computeArmEnd(baseX, baseY, shoulderRel, elbowRel){
    let x = baseX, y = baseY;
    // Offset for the origin of the upper arm
    const offUpper = CONFIG.offsets && CONFIG.offsets.arm && CONFIG.offsets.arm.upper;
    if (offUpper && offUpper.origin){ [x, y] = withAX(x, y, shoulderRel, offUpper.origin); }
    // Upper arm length
    const upperLen = (CONFIG.parts.arm.upper || 0) * CONFIG.actor.scale;
    // Position of the elbow
    let elbow = segPos(x, y, upperLen, shoulderRel);
    // Apply elbow offset on the upper arm
    if (offUpper && offUpper.elbow){ elbow = withAX(elbow[0], elbow[1], shoulderRel, offUpper.elbow); }
    // Forearm absolute angle
    const foreAng = shoulderRel + elbowRel;
    // Offset for the origin of the lower arm
    const offLower = CONFIG.offsets && CONFIG.offsets.arm && CONFIG.offsets.arm.lower;
    let wristStart = elbow;
    if (offLower && offLower.origin){ wristStart = withAX(elbow[0], elbow[1], foreAng, offLower.origin); }
    // Lower arm length
    const lowerLen = (CONFIG.parts.arm.lower || 0) * CONFIG.actor.scale;
    const wrist = segPos(wristStart[0], wristStart[1], lowerLen, foreAng);
    return { x: wrist[0], y: wrist[1] };
  }

  /**
   * Compute the world-space position of the foot given a hip base coordinate,
   * hip absolute angle and knee relative angle. This mirrors the
   * calculations in drawLeg() but returns the end of the lower leg rather
   * than drawing. Offsets and limb lengths come from CONFIG.parts and
   * CONFIG.offsets. See drawLeg() for reference.
   * @param {number} baseX - hip base X coordinate
   * @param {number} baseY - hip base Y coordinate
   * @param {number} hipAng - absolute hip angle (radians)
   * @param {number} kneeRel - relative knee angle (radians)
   * @returns {{x:number,y:number}}
   */
  function computeFootEnd(baseX, baseY, hipAng, kneeRel){
    let x = baseX, y = baseY;
    // Offset for the origin of the upper leg
    const legOff = CONFIG.offsets && CONFIG.offsets.leg;
    if (legOff && legOff.upper && legOff.upper.origin){ [x, y] = withAX(x, y, hipAng, legOff.upper.origin); }
    // Upper leg length
    const upperLen = (CONFIG.parts.leg.upper || 0) * CONFIG.actor.scale;
    // Position of the knee
    let knee = segPos(x, y, upperLen, hipAng);
    if (legOff && legOff.upper && legOff.upper.knee){ knee = withAX(knee[0], knee[1], hipAng, legOff.upper.knee); }
    // Shin absolute angle
    const shinAng = hipAng + kneeRel;
    // Offset for the origin of the lower leg
    let ankleStart = knee;
    if (legOff && legOff.lower && legOff.lower.origin){ ankleStart = withAX(knee[0], knee[1], shinAng, legOff.lower.origin); }
    // Lower leg length
    const lowerLen = (CONFIG.parts.leg.lower || 0) * CONFIG.actor.scale;
    const foot = segPos(ankleStart[0], ankleStart[1], lowerLen, shinAng);
    return { x: foot[0], y: foot[1] };
  }

  /**
   * Determine which attack colliders should be active based on the current
   * attack preset and whether we are within a strike phase. The result
   * informs drawAttackColliders() which circles should be highlighted.
   * @returns {string[]} list of collider keys (e.g. 'handL', 'footR')
   */
  function getActiveColliders(){
    // Only consider activating colliders when an attack is running
    if (!ATTACK.active) {
      // console.log('[Colliders] ATTACK not active');
      return [];
    }
    const blend = getPoseBlend();
    const toName = (blend.toName || '').toLowerCase();
    const fromName = (blend.fromName || '').toLowerCase();
    const inStrike = toName.includes('strike') || fromName.includes('strike');
    if (!inStrike) {
      // console.log('[Colliders] Not in strike phase. toName:', toName, 'fromName:', fromName);
      return [];
    }
    const preset = (ATTACK.preset || '').toUpperCase();
    console.log('[Colliders] ACTIVE! preset:', preset, 'toName:', toName, 'fromName:', fromName);
    if (preset.startsWith('KICK')){
      return ['footL','footR'];
    } else if (preset.startsWith('PUNCH')){
      return ['handL','handR'];
    }
    // Default: assume both hands and feet may hit if unspecified
    return ['handL','handR','footL','footR'];
  }

  /**
   * Render simple circular hitboxes for the hands and feet based on the
   * positions computed in drawSkeleton(). Active colliders are coloured
   * red; inactive ones are light grey. The radius scales with the actor.
   */
  /**
   * Render simple circular hitboxes for the hands and feet based on the
   * positions computed in drawSkeleton(). Active colliders are coloured
   * red; inactive ones are light grey. The radius scales with the actor.
   *
   * If a `posObj` is provided it will be used instead of the global
   * COLLIDERS_POS. This allows us to draw colliders for the NPC separately
   * from the player's colliders. If omitted, the global COLLIDERS_POS is used.
   *
   * @param {Object} posObj optional collider positions (handL, handR, footL, footR, hitCenter)
   */
  function drawAttackColliders(posObj, activeKeys, collisionKeys, hitCounts, facingRad){
    const target = posObj || COLLIDERS_POS;
    const active = Array.isArray(activeKeys) ? activeKeys : getActiveColliders();
    const collisions = Array.isArray(collisionKeys) ? collisionKeys : [];
    const counts = hitCounts || {};
    const baseRadius = 8 * CONFIG.actor.scale;
    cx.save();
    cx.textAlign = 'center';
    cx.textBaseline = 'middle';
    cx.font = `${Math.round(8 * CONFIG.actor.scale)}px system-ui, sans-serif`;
    for (const key of ['handL','handR','footL','footR']){
      const pos = target[key];
      if (!pos) continue;
      // Apply size multiplier based on collider type
      let radius = baseRadius;
      if (key === 'handL' || key === 'handR') {
        radius *= CONFIG.colliders.handMultiplier;
      } else if (key === 'footL' || key === 'footR') {
        radius *= CONFIG.colliders.footMultiplier;
      }
      cx.beginPath();
      cx.arc(pos.x, pos.y, radius, 0, TAU);
      // Highlight collisions in red, active colliders in orange, others in grey
      let color;
      if (collisions.includes(key)){
        color = 'rgba(255, 60, 60, 0.9)';
      } else if (active.includes(key)){
        color = 'rgba(255, 120, 80, 0.8)';
      } else {
        color = 'rgba(255, 255, 255, 0.25)';
      }
      cx.fillStyle = color;
      cx.fill();
      // Draw hit count if present
      const cnt = counts[key] || 0;
      if (cnt > 0){
        cx.fillStyle = '#ffffff';
        cx.fillText(String(cnt), pos.x, pos.y);
      }
    }
    cx.restore();
  }

  // ====== State ======
  let current = clone(CONFIG.poses.Stance);
  let lastPoseName = 'Stance';
  let active = null, holding=false;
  
  // ====== UNIFIED FIGHTER SYSTEM ======
  // Factory function to create a fighter entity (player or NPC)
  function createFighter(config) {
    return {
      // Identity
      id: config.id,
      isPlayer: config.isPlayer || false,
      
      // Physics state
      pos: config.pos || {x: 0, y: 0},
      vel: {x: 0, y: 0},
      onGround: true,
      prevOnGround: true,
      landedImpulse: 0,
      facingRad: config.facingRad || 0,
      
      // Combat state
      footing: config.footing || 50,
      ragdoll: false,
      ragdollTime: 0,
      ragdollVel: {x: 0, y: 0},
      jointAngles: {},
      recovering: false,
      recoveryTime: 0,
      recoveryDuration: 0.8,
      recoveryStartAngles: {},
      recoveryStartY: 0,
      recoveryTargetY: 0,
      
      // Stamina system
      stamina: {
        current: config.stamina || 100,
        max: 100,
        drainRate: 40,
        regenRate: 25,
        minToDash: 10,
        isDashing: false
      },
      
      // Attack system
      attack: {
        active: false,
        preset: null,
        slot: null,
        facingRadAtPress: 0,
        dirSign: 1,
        downT: 0,
        holdStartTime: 0,
        holdWindupDuration: 0,
        isHoldRelease: false,
        strikeLanded: false,
        currentPhase: null,
        currentActiveKeys: [],
        sequence: [],
        durations: [],
        phaseIndex: 0,
        timer: 0,
        lunge: {
          active: false,
          paused: false,
          distance: 0,
          targetDistance: 60,
          speed: 400,
          lungeVel: {x: 0, y: 0}
        }
      },
      
      // Aiming system
      aim: {
        targetAngle: 0,
        currentAngle: 0,
        torsoOffset: 0,
        shoulderOffset: 0,
        hipOffset: 0,
        active: false
      },
      
      // Combo system
      combo: {
        active: false,
        sequenceIndex: 0,
        attackDelay: 0
      },
      
      // Walk animation state
      walk: {
        phase: 0,
        amp: 0
      },
      
      // Player-specific: input state (null for NPCs)
      input: config.isPlayer ? {left: false, right: false, jump: false, dash: false} : null,
      
      // NPC-specific: AI state (null for players)
      ai: config.ai ? {
        mode: 'approach',
        timer: 0,
        cooldown: 0
      } : null,
      
      // Visual trail color
      trailColor: config.trailColor || 'cyan'
    };
  }
  
  // Create both fighters
  const FIGHTERS = {
    player: createFighter({
      id: 'player',
      isPlayer: true,
      pos: {x: CONFIG.canvas.w/2, y: CONFIG.groundY - CONFIG.parts.hitbox.h/2},
      facingRad: 0,
      footing: 50,
      stamina: 100,
      trailColor: 'cyan'
    }),

    npc: createFighter({
      id: 'npc',
      isPlayer: false,
      pos: {x: CONFIG.canvas.w * 0.75, y: CONFIG.groundY - (CONFIG.parts.hitbox.h * CONFIG.actor.scale) / 2},
      facingRad: Math.PI,
      footing: 100,
      stamina: 100,
      trailColor: 'red',
      ai: true
    }),

    npc2: createFighter({
      id: 'npc2',
      isPlayer: false,
      pos: {x: CONFIG.canvas.w * 0.35, y: CONFIG.groundY - (CONFIG.parts.hitbox.h * CONFIG.actor.scale) / 2},
      facingRad: 0,
      footing: 100,
      stamina: 100,
      trailColor: 'orange',
      ai: true
    })
  };

  const NPCS = [FIGHTERS.npc, FIGHTERS.npc2];
  
  // Legacy aliases for backward compatibility during migration
  const MOVE = FIGHTERS.player;
  const STAMINA = FIGHTERS.player.stamina;
  
  // Dash trail effect for anime-style motion
  const DASH_TRAIL = {
    enabled: true,
    positions: [],      // Array of {x, y, alpha, angles} for trail rendering
    maxLength: 8,       // Number of afterimages
    interval: 0.03,     // Time between trail captures (seconds)
    timer: 0
  };
  
  // NPC dash trail
  const NPC_DASH_TRAIL = {
    enabled: true,
    positions: [],
    maxLength: 8,
    interval: 0.03,
    timer: 0
  };
  
  // Attack collider trails - creates afterimages of active weapon hitboxes
  const ATTACK_TRAIL = {
    enabled: true,
    colliders: {
      handL: [],
      handR: [],
      footL: [],
      footR: []
    },
    maxLength: 6,       // Number of afterimages per collider
    interval: 0.02,     // Time between trail captures (seconds)
    timer: 0
  };
  
  // NPC attack collider trails
  const NPC_ATTACK_TRAIL = {
    enabled: true,
    colliders: {
      handL: [],
      handR: [],
      footL: [],
      footR: []
    },
    maxLength: 6,
    interval: 0.02,
    timer: 0
  };
  
  // ====== Camera System ======
  const WORLD_WIDTH = 1600;  // Total game world width
  const CAMERA = {
    x: 0,              // Camera position in world space
    smoothing: 0.15    // Camera follow smoothing factor
  };
  
  // ====== Mouse Aiming System ======
  const MOUSE = {
    isDown: false,
  x: 0,               // Canvas-space mouse X
    y: 0,               // Canvas-space mouse Y
    worldX: 0,          // World-space mouse X (accounting for canvas scaling)
    worldY: 0,          // World-space mouse Y
    isInCanvas: false   // Whether mouse is currently over canvas
  };
  
  // Legacy aliases for player-specific systems (kept separate as they're tied to player animation)
  const ATTACK = FIGHTERS.player.attack;  // Alias for backward compatibility
  const AIM = FIGHTERS.player.aim;        // Alias for backward compatibility
  const WALK = FIGHTERS.player.walk;      // Alias for backward compatibility
  const FACE = { active:false, rad:0 };   // Face-lock system (player only for now)
  
  let LAST_DT = 0.016;  // Last delta time for various calculations
  
  const RAG = { 
    active: false,
    lCalfRagdoll: false, rCalfRagdoll: false,
    lKneeRel:deg2rad(CONFIG.basePose.lKnee), 
    rKneeRel:deg2rad(CONFIG.basePose.rKnee) 
  };

  // ====== NPC support ======
  // Global toggle for NPC - set to false to disable NPC completely
  let NPC_ENABLED = true;
  
  // Legacy alias for NPC (for backward compatibility during migration)
  const NPC_STATE = FIGHTERS.npc;
  const NPC2_STATE = FIGHTERS.npc2;
  // --- AI field sync to top-level (compat with older code that reads NPC_STATE.mode/cooldown) ---
  if (!('mode' in NPC_STATE)) NPC_STATE.mode = 'wander';
  if (!Number.isFinite(NPC_STATE.cooldown)) NPC_STATE.cooldown = 0;
  if (!('mode' in NPC2_STATE)) NPC2_STATE.mode = 'wander';
  if (!Number.isFinite(NPC2_STATE.cooldown)) NPC2_STATE.cooldown = 0;


  // NPC walk cycle (legacy alias retained for compatibility)
  const NPC_WALK = FIGHTERS.npc.walk;

  function randomRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function ensureWandererState(npc, index) {
    if (!npc) return;
    const defaultDir = index % 2 === 0 ? -1 : 1;
    if (!npc.wander) {
      npc.wander = {
        direction: defaultDir,
        lastDirection: defaultDir,
        timer: randomRange(1.5, 3.5),
        speed: CONFIG.movement.maxSpeedX * 0.3,
        boundsRatio: {
          min: 0.25 + index * 0.1,
          max: 0.85 - index * 0.1
        }
      };
    } else {
      npc.wander.speed = CONFIG.movement.maxSpeedX * 0.3;
      npc.wander.boundsRatio = npc.wander.boundsRatio || { min: 0.25 + index * 0.1, max: 0.85 - index * 0.1 };
      npc.wander.boundsRatio.min = 0.25 + index * 0.1;
      npc.wander.boundsRatio.max = 0.85 - index * 0.1;
      if (!Number.isFinite(npc.wander.timer)) {
        npc.wander.timer = randomRange(1.5, 3.5);
      }
      if (typeof npc.wander.lastDirection !== 'number') {
        npc.wander.lastDirection = defaultDir;
      }
      if (typeof npc.wander.direction !== 'number') {
        npc.wander.direction = defaultDir;
      }
    }

    npc.mode = 'wander';
    npc.cooldown = 0;
    npc.onGround = true;
    npc.ragdoll = false;
    npc.recovering = false;
    if (npc.ai) {
      npc.ai.mode = 'wander';
      npc.ai.timer = npc.wander.timer;
      npc.ai.cooldown = 0;
    }
    if (npc.attack) {
      npc.attack.active = false;
      npc.attack.currentActiveKeys = [];
      npc.attack.currentPhase = null;
    }
    if (npc.combo) {
      npc.combo.active = false;
      npc.combo.sequenceIndex = 0;
      npc.combo.attackDelay = 0;
    }
  }

  function pickNextWanderState(npc) {
    if (!npc || !npc.wander) return;
    const choices = [-1, 0, 1];
    const choice = choices[Math.floor(Math.random() * choices.length)];
    npc.wander.direction = choice;
    npc.wander.timer = randomRange(1.5, 3.5);
    if (choice !== 0) {
      npc.wander.lastDirection = choice;
    }
  }

  function getWanderBounds(npc) {
    if (!npc || !npc.wander || !npc.wander.boundsRatio) {
      return { min: WORLD_WIDTH * 0.2, max: WORLD_WIDTH * 0.8 };
    }
    return {
      min: WORLD_WIDTH * npc.wander.boundsRatio.min,
      max: WORLD_WIDTH * npc.wander.boundsRatio.max
    };
  }

  // Positions of attack colliders for the current frame. These are populated
  // during skeleton drawing so that the render function can draw simple
  // circles showing where a punch or kick would hit. Each entry holds
  // {x, y} coordinates in world space. The hitCenter is also cached
  // here so flipping logic can be applied uniformly when computing
  // collider positions. When no positions are available yet, they will
  // be null. See drawSkeleton() for details.
  const COLLIDERS_POS = {
    handL: null,
    handR: null,
    footL: null,
    footR: null,
    hitCenter: { x: 0, y: 0 },
    lunge: null  // Lunge anticipation collider
  };

  // Track how many times each collider from each fighter has collided
  // with an opponent's active collider. Counts persist across frames
  // and allow the HUD to show impact totals inside each attack circle.
  const HIT_COUNTS = {
    player: { handL: 0, handR: 0, footL: 0, footR: 0 },
    npc:    { handL: 0, handR: 0, footL: 0, footR: 0, body: 0 }
  };

  // Attack input & slot config with proper hierarchy
  // Each button has a light attack (tap) and heavy attack (hold)
  const ATTACK_INPUT = {
    thresholds: { 
      tapMaxMs: 200,  // Reduced for more responsive tap detection
      chargeStageMs: 200  // Time per charge stage for hold-release (5 stages = 1000ms total)
    },
    slots: {
      A: { 
        light: { 
          type: 'combo',  // Combo system (chained attacks)
          // Combo config handled by COMBO object below
        },
        heavy: { 
          type: 'hold-release',  // Charge-based heavy attack
          preset: 'SLAM',
          maxChargeStages: 5,  // 0-5 charge stages
          minChargeStages: 1   // Must reach stage 1 to trigger attack
        }
      },
      B: {
        light: { 
          type: 'quick',  // Single quick attack
          preset: 'PUNCH', 
          windupMs: 0 
        },
        heavy: { 
          type: 'hold-release',  // Charge-based heavy attack
          preset: 'SLAM',
          maxChargeStages: 5,
          minChargeStages: 1
        }
      }
    }
  };
  
  // Track charge state for hold-release attacks
  const CHARGE_STATE = {
    active: false,
    stage: 0,  // 0-5
    startTime: 0
  };
  
  // Attack queue - stores up to 1 pending attack input
  const ATTACK_QUEUE = {
    pending: false,
    type: null,      // 'light' or 'heavy'
    button: null,    // 'A' or 'B'
    chargeStage: 0,  // For heavy attacks
    downTime: 0      // When the queued button was pressed (for tap/hold detection)
  };

  // Combo configuration. A combo is defined as a sequence of four presets
  // that will play in order when the combo button is pressed. Once the
  // hit counter reaches 4 and the combo timer is still active, the
  // alternate sequence will be used instead. These values are kept in
  // CONFIG so they can be modified via the UI selects.
  CONFIG.combo = {
    sequence: ['KICK','PUNCH','KICK','PUNCH'],
    altSequence: ['PUNCH','KICK','PUNCH','KICK'],
    timerDuration: 3000 // ms
  };

  // State for tracking combo progress and timers
    ensureAltSequenceUsesKickAlt();

  const COMBO = { hits: 0, sequenceIndex: 0, timer: 0 };

  // ====== DOM ======
  const cv = document.getElementById('game');
  const cx = cv.getContext('2d');
  // Get new button elements
  const btnJump = document.getElementById('btnJump');
  const btnAttackA = document.getElementById('btnAttackA');
  const btnAttackB = document.getElementById('btnAttackB');
  const btnInteract = document.getElementById('btnInteract');
  const btnHelp = document.getElementById('btnHelp');
  const btnFullscreen = document.getElementById('btnFullscreen');
  const helpPanel = document.getElementById('helpPanel');
  
  // Joystick elements
  const joystickArea = document.getElementById('joystickArea');
  const joystickStick = document.getElementById('joystickStick');

  // New DOM references
  const comboFields = document.getElementById('comboFields');
  const hitSlider = document.getElementById('hitSlider');

  // Settings
  const wAuth = document.getElementById('wAuth');
  const wPhys = document.getElementById('wPhys');
  const ikCalvesOnly = document.getElementById('ikCalvesOnly');
  const lockFacing = document.getElementById('lockFacing');
  const actorScaleInput = document.getElementById('actorScale');
  const groundRatioInput = document.getElementById('groundRatio');
  const handMultiplierInput = document.getElementById('handMultiplier');
  const footMultiplierInput = document.getElementById('footMultiplier');
  
  // Initialize settings listeners
  wAuth.addEventListener('input', ()=> CONFIG.movement.authoredWeight = +wAuth.value);
  wPhys.addEventListener('input', ()=> CONFIG.movement.physicsWeight  = +wPhys.value);
  ikCalvesOnly.addEventListener('change', ()=> CONFIG.ik.calvesOnly = ikCalvesOnly.checked);
  lockFacing.addEventListener('change', ()=> CONFIG.movement.lockFacingDuringAttack = lockFacing.checked);
  actorScaleInput.addEventListener('input', ()=>{ CONFIG.actor.scale = +actorScaleInput.value; resizeCanvas(); });
  groundRatioInput.addEventListener('input', ()=>{ CONFIG.groundRatio = +groundRatioInput.value; resizeCanvas(); });
  if (handMultiplierInput) {
    handMultiplierInput.addEventListener('input', ()=> CONFIG.colliders.handMultiplier = +handMultiplierInput.value);
  }
  if (footMultiplierInput) {
    footMultiplierInput.addEventListener('input', ()=> CONFIG.colliders.footMultiplier = +footMultiplierInput.value);
  }

  // Manual hit slider updates the combo hit counter. This allows the user to
  // simulate successive hits for testing the alternate combo behaviour.
  if (hitSlider){
    hitSlider.addEventListener('input', ()=>{
      COMBO.hits = parseInt(hitSlider.value, 10) || 0;
    });
  }

  // Fighter selection
  const fighterSelect = document.getElementById('fighterSelect');
  if (fighterSelect && CONFIG.fighters){
    const names = Object.keys(CONFIG.fighters);
    fighterSelect.innerHTML = names.map(n => `<option value="${n}">${n}</option>`).join('');
    fighterSelect.value = CONFIG.activeFighter || names[0];
    fighterSelect.addEventListener('change', ()=>{
      applyFighter(fighterSelect.value);
      actorScaleInput.value = CONFIG.actor.scale.toFixed(2);
      ikCalvesOnly.checked = CONFIG.ik.calvesOnly;
      resizeCanvas();
      refreshSpriteDebug();
      // Rebuild combo UI when presets or fighter settings change
      initComboUI();
    });
  }

  // Initialize combo configuration UI. This populates a set of select
  // elements allowing the user to choose which quick attack presets are
  // executed at each stage of the combo and which alternates to use when
  // the combo is fully built. The UI is rebuilt whenever presets are
  // updated, ensuring available options stay in sync.
  function initComboUI(){
    if (!comboFields) return;
    comboFields.innerHTML = '';
    ensureAltSequenceUsesKickAlt();

    const presets = Object.keys(CONFIG.presets || {});
    // Four primary combo selects
    for (let i=0; i<4; i++){
      const wrap = document.createElement('label');
      wrap.style.display = 'grid';
      wrap.style.gap = '6px';
      wrap.style.fontSize = '12px';
      wrap.textContent = `Combo ${i+1}`;
      const sel = document.createElement('select');
      sel.id = `comboSeq${i}`;
      presets.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      });
      sel.value = CONFIG.combo.sequence[i] || presets[0];
      sel.addEventListener('change', ()=>{
        CONFIG.combo.sequence[i] = sel.value;
      });
      wrap.appendChild(sel);
      comboFields.appendChild(wrap);
    }
    // Four alternate combo selects
    for (let i=0; i<4; i++){
      const wrap = document.createElement('label');
      wrap.style.display = 'grid';
      wrap.style.gap = '6px';
      wrap.style.fontSize = '12px';
      wrap.textContent = `Alt ${i+1}`;
      const sel = document.createElement('select');
      sel.id = `comboAlt${i}`;
      presets.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      });
      sel.value = CONFIG.combo.altSequence[i] || presets[0];
      sel.addEventListener('change', ()=>{
        CONFIG.combo.altSequence[i] = sel.value;
      });
      wrap.appendChild(sel);
      comboFields.appendChild(wrap);
    }
  }

  // ====== Controls ======
  
  // Virtual Joystick State
  const JOYSTICK = {
    active: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    deltaX: 0,
    deltaY: 0,
    angle: 0,
    distance: 0,
    maxDistance: 50 // max pixels from center
  };
  
  // Update joystick visual position
  function updateJoystickVisual() {
    if (!joystickStick) return;
    
    if (JOYSTICK.active) {
      joystickStick.classList.add('active');
      joystickStick.style.transform = `translate(calc(-50% + ${JOYSTICK.deltaX}px), calc(-50% + ${JOYSTICK.deltaY}px))`;
    } else {
      joystickStick.classList.remove('active');
      joystickStick.style.transform = 'translate(-50%, -50%)';
    }
  }
  
  // Process joystick input for movement and aiming
  function processJoystickInput() {
  // Movement gating during attacks/charging: keep aim from stick but stop horizontal input
  if (ATTACK.active || CHARGE_STATE.active) {
    if (!JOYSTICK.active) {
      MOVE.input.left = false;
      MOVE.input.right = false;
      AIMING.manualAim = false;
      return;
    }
    const deadzone = 0.15;
    const normalized = JOYSTICK.distance / JOYSTICK.maxDistance;
    // Compute angle for aiming
    const angle = Math.atan2(JOYSTICK.deltaY, JOYSTICK.deltaX);
    if (normalized > 0.3) {
      AIMING.manualAim = true;
      AIMING.targetAngle = angle;
    } else {
      AIMING.manualAim = false;
    }
    // Suppress movement while attacking/charging
    MOVE.input.left = false;
    MOVE.input.right = false;
    return;
  }

    if (!JOYSTICK.active) {
      MOVE.input.left = false;
      MOVE.input.right = false;
      return;
    }
    
    const deadzone = 0.15; // 15% deadzone
    const normalized = JOYSTICK.distance / JOYSTICK.maxDistance;
    
    if (normalized < deadzone) {
      MOVE.input.left = false;
      MOVE.input.right = false;
      return;
    }
    
    // Movement - horizontal axis
    const angle = JOYSTICK.angle;
    const horizontalStrength = Math.cos(angle);
    
    if (horizontalStrength > deadzone) {
      MOVE.input.right = true;
      MOVE.input.left = false;
    } else if (horizontalStrength < -deadzone) {
      MOVE.input.left = true;
      MOVE.input.right = false;
    } else {
      MOVE.input.left = false;
      MOVE.input.right = false;
    }
    
    // Aiming - update facing direction based on joystick
    // Use the joystick direction to aim the character
    if (normalized > 0.3) { // Require significant input for aiming
      AIMING.manualAim = true;
      AIMING.targetAngle = angle;
    } else {
      AIMING.manualAim = false;
    }
  }
  
  // Aiming state (replaces mouse aiming)
  const AIMING = {
    manualAim: false,
    targetAngle: 0
  };
  
  // Joystick touch handlers
  function handleJoystickStart(e) {
    e.preventDefault();
    JOYSTICK.active = true;
    
    const rect = joystickArea.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    JOYSTICK.startX = centerX;
    JOYSTICK.startY = centerY;
    
    const touch = e.touches ? e.touches[0] : e;
    JOYSTICK.currentX = touch.clientX;
    JOYSTICK.currentY = touch.clientY;
    
    updateJoystickPosition();
  }
  
  function handleJoystickMove(e) {
    if (!JOYSTICK.active) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    JOYSTICK.currentX = touch.clientX;
    JOYSTICK.currentY = touch.clientY;
    
    updateJoystickPosition();
  }
  
  function handleJoystickEnd(e) {
    e.preventDefault();
    JOYSTICK.active = false;
    JOYSTICK.deltaX = 0;
    JOYSTICK.deltaY = 0;
    JOYSTICK.distance = 0;
    AIMING.manualAim = false;
    MOVE.input.left = false;
    MOVE.input.right = false;
    updateJoystickVisual();
    processJoystickInput();
  }
  
  function updateJoystickPosition() {
    let dx = JOYSTICK.currentX - JOYSTICK.startX;
    let dy = JOYSTICK.currentY - JOYSTICK.startY;
    
    const distance = Math.sqrt(dx * dx + dy * dy);
    JOYSTICK.distance = distance;
    
    // Clamp to max distance
    if (distance > JOYSTICK.maxDistance) {
      const scale = JOYSTICK.maxDistance / distance;
      dx *= scale;
      dy *= scale;
    }
    
    JOYSTICK.deltaX = dx;
    JOYSTICK.deltaY = dy;
    JOYSTICK.angle = Math.atan2(dy, dx);
    
    updateJoystickVisual();
    processJoystickInput();
  }
  
  // Bind joystick events
  if (joystickArea) {
    joystickArea.addEventListener('touchstart', handleJoystickStart, { passive: false });
    joystickArea.addEventListener('touchmove', handleJoystickMove, { passive: false });
    joystickArea.addEventListener('touchend', handleJoystickEnd, { passive: false });
    joystickArea.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
    
    // Also support mouse for testing
    joystickArea.addEventListener('mousedown', handleJoystickStart);
    document.addEventListener('mousemove', handleJoystickMove);
    document.addEventListener('mouseup', handleJoystickEnd);
  }
  
  // Helper function for button bindings
  function bindHold(btn, onDown, onUp){
    if (!btn) return;
    const start = (e)=>{ 
      e.preventDefault(); 
      btn.classList.add('active');
      onDown(); 
    };
    const end = (e)=>{ 
      e && e.preventDefault(); 
      btn.classList.remove('active');
      onUp(); 
    };
    btn.addEventListener('pointerdown', start);
    btn.addEventListener('pointerup', end);
    btn.addEventListener('pointercancel', end);
    btn.addEventListener('pointerleave', end);
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('touchend', end, {passive:false});
  }

  // Bind jump button
  bindHold(btnJump, ()=>{ 
    if (MOVE.onGround){ 
      MOVE.vel.y = CONFIG.movement.jumpImpulse; 
      MOVE.onGround = false; 
      MOVE.input.jump = true;
    } 
  }, ()=>{ MOVE.input.jump = false; });

  // Help toggle
  if (btnHelp && helpPanel) {
    btnHelp.addEventListener('click', (e) => {
      e.preventDefault();
      helpPanel.classList.toggle('visible');
    });
  }

  // Attack slot handling
  /**
   * Determine whether a new attack can be initiated. Attacks are only
   * permitted while the fighter is in a relaxed "Stance" pose and no other
   * transitions are occurring. This prevents chaining attacks from mid-air
   * states, recoil frames or while walking. Only when the current pose
   * blend is entirely within the Stance (from and to) or when there is
   * no active transition and the last pose was Stance will true be
   * returned.
   * @returns {boolean} true if a new attack can start
   */
  function canAttackNow(){
    // Disallow if moving horizontally or airborne ‚Äì attacks only start
    // from a neutral grounded stance. If either left or right input is
    // currently active or the fighter is off the ground, return false.
    if (MOVE.input.left || MOVE.input.right || !MOVE.onGround) return false;
    
    // If a transition is active, check if we're in a cancel window
    if (active){
      const blend = getPoseBlend();
      
      // Both from and to are Stance - definitely allowed
      if (blend.fromName === 'Stance' && blend.toName === 'Stance') return true;
      
      // Transitioning to Stance and >= 85% complete - allow for responsive input
      if (blend.toName === 'Stance' && blend.k >= 0.85) return true;
      
      // Check if we're in Recoil phase with a cancel window
      if (blend.toName === 'Recoil' && ATTACK.active && ATTACK.preset) {
        const preset = CONFIG.presets && CONFIG.presets[ATTACK.preset];
        if (preset && typeof preset.cancelWindow === 'number') {
          // cancelWindow is the fraction of Recoil where canceling is allowed
          // e.g., 0.6 means last 60% of recoil animation
          const cancelStart = 1.0 - preset.cancelWindow;
          if (blend.k >= cancelStart) {
            console.log(`Cancel window active! Recoil at ${(blend.k * 100).toFixed(0)}%, cancel starts at ${(cancelStart * 100).toFixed(0)}%`);
            return true;
          }
        }
      }
      
      return false;
    }
    return lastPoseName === 'Stance';
  }
  function captureFacingAtPress(){
    if (MOVE.input.left !== MOVE.input.right){ return MOVE.input.right ? 0 : Math.PI; }
    return MOVE.facingRad;
  }

  // Combo attack function (used by Button A tap)
  function playComboAttack(){
    // Prevent starting a combo if another attack is running or cannot attack
    if (ATTACK.active || !canAttackNow() || active) {
      // Queue this attack if possible
      if (!ATTACK_QUEUE.pending) {
        console.log('Queueing combo attack');
        ATTACK_QUEUE.pending = true;
        ATTACK_QUEUE.type = 'light';
        ATTACK_QUEUE.button = 'A';
      }
      return;
    }
    // Reset combo timer whenever a combo attack is played
    COMBO.timer = CONFIG.combo.timerDuration;
    // Determine which preset to use based on hit counter
    const idx = COMBO.sequenceIndex % 4;
    const useAlt = (COMBO.hits >= 4 && COMBO.timer > 0);
    const presetName = useAlt ? (CONFIG.combo.altSequence[idx] || CONFIG.combo.sequence[idx]) : (CONFIG.combo.sequence[idx] || 'KICK');
    // Play the quick attack. Reuse windupMs=0 so durations come from preset
    playQuickAttack(presetName, 0);
    // Advance sequence index
    COMBO.sequenceIndex = (COMBO.sequenceIndex + 1) % 4;
  }
  
  // Execute a charged heavy attack
  function executeHeavyAttack(slotKey, chargeStage) {
    const slot = ATTACK_INPUT.slots[slotKey];
    if (!slot || !slot.heavy) return;
    
    console.log(`Executing heavy attack: ${slot.heavy.preset} with charge ${chargeStage}`);
    ATTACK.active = true;
    const preset = slot.heavy.preset;
    applyPreset(preset);
    ATTACK.preset = preset;
    ATTACK.isHoldRelease = true;
    ATTACK.chargeStage = chargeStage;
    
    const durs = getPresetDurations(preset);
    // Go straight to Strike since we were already in windup
    startTransition(sampleOffsets(), 'Strike', durs.toStrike, ()=>{
      startTransition(current, 'Recoil', durs.toRecoil, ()=> startTransition(current, 'Stance', durs.toStance));
    });
  }

  function slotDown(slotKey){
    const slot = ATTACK_INPUT.slots[slotKey]; 
    if (!slot) return;
    
    // Auto-neutralize movement so attacks can start while moving.
    // This preserves 'press to attack halts movement' UX.
    if (MOVE.input.left || MOVE.input.right) {
      MOVE.input.left = false;
      MOVE.input.right = false;
      if (MOVE.vel && typeof MOVE.vel.x === 'number') MOVE.vel.x = 0;
      if (typeof STAMINA !== 'undefined' && STAMINA.isDashing) STAMINA.isDashing = false;
    }

    
    // If attack is blocked, queue this button press for later execution
    if (ATTACK.active || !canAttackNow()) {
      console.log(`Button ${slotKey} pressed but attack blocked - queueing for later`);
      // Queue this button press (overwrite any existing queued input with the latest)
      if (!ATTACK_QUEUE.pending) {
        ATTACK_QUEUE.pending = true;
        ATTACK_QUEUE.button = slotKey;
        ATTACK_QUEUE.downTime = now(); // Track when queued button was pressed
        console.log('  ‚Üí Attack queued successfully');
      } else {
        console.log('  ‚Üí Queue already has pending attack, ignoring');
      }
      return;
    }
    
    console.log(`Button ${slotKey} pressed - starting hold timer and windup animation`);
    
    // Track button press timing and facing
    ATTACK.slot = slotKey;
    ATTACK.facingRadAtPress = captureFacingAtPress();
    ATTACK.dirSign = (Math.cos(ATTACK.facingRadAtPress) >= 0) ? 1 : -1;
    ATTACK.downT = now();
    
    // Initialize charge state for potential heavy attack
    CHARGE_STATE.active = true;
    CHARGE_STATE.stage = 0;
    CHARGE_STATE.startTime = now();
    
    // Start charging state for hold-release attacks
    if (slot.heavy && slot.heavy.type === 'hold-release') {
      ATTACK.active = true;
      ATTACK.isCharging = true;  // Flag to indicate we're in charge mode
      const preset = slot.heavy.preset;
      applyPreset(preset);
      ATTACK.preset = preset;
      
      // We'll handle the windup progression dynamically in the tick function
      // based on charge stage rather than using a single long transition
      console.log('  ‚Üí Starting charge mode - windup will progress with charge stages');
    }
  }

  function slotUp(slotKey){
    const tUp = now();
    const slot = ATTACK_INPUT.slots[slotKey]; 
    if (!slot) return;
    
    const heldMs = tUp - (ATTACK.downT || tUp);
    const tap = heldMs <= ATTACK_INPUT.thresholds.tapMaxMs;
    
    console.log(`Button ${slotKey} released - held for ${heldMs}ms, tap=${tap}, threshold=${ATTACK_INPUT.thresholds.tapMaxMs}ms`);
    
    // Deactivate charge state
    CHARGE_STATE.active = false;

    // TAP = LIGHT ATTACK
    if (tap) {
      console.log(`Button ${slotKey}: TAP detected - triggering LIGHT attack`);
      
      // If we started charging, cancel it
      if (ATTACK.isCharging) {
        ATTACK.active = false;
        ATTACK.isCharging = false;
        ATTACK.slot = null;
        ATTACK.preset = null;
      }
      
      // Button A light = Combo
      if (slotKey === 'A' && slot.light.type === 'combo') {
        console.log('  ‚Üí Combo attack');
        playComboAttack();  // This will queue if unable to execute
        return;
      }
      
      // Button B light = Quick attack
      if (slotKey === 'B' && slot.light.type === 'quick') {
        console.log(`  ‚Üí Quick attack: ${slot.light.preset}`);
        // Check if we can attack, otherwise queue
        if (!canAttackNow() || ATTACK.active || active) {
          if (!ATTACK_QUEUE.pending) {
            console.log('  ‚Üí Queueing quick attack');
            ATTACK_QUEUE.pending = true;
            ATTACK_QUEUE.type = 'light';
            ATTACK_QUEUE.button = 'B';
          }
        } else {
          playQuickAttack(slot.light.preset, slot.light.windupMs || 0);
        }
        return;
      }
    }
    
    // HOLD = HEAVY ATTACK
    if (!tap) {
      console.log(`Button ${slotKey}: HOLD detected - checking for HEAVY attack`);
      
      if (slot.heavy && slot.heavy.type === 'hold-release') {
        // Calculate charge stage (0-5)
        const chargeStage = Math.min(
          slot.heavy.maxChargeStages, 
          Math.floor(heldMs / ATTACK_INPUT.thresholds.chargeStageMs)
        );
        
        console.log(`  ‚Üí Charge stage: ${chargeStage}/${slot.heavy.maxChargeStages} (min required: ${slot.heavy.minChargeStages})`);
        
        // Must reach minimum charge stage to trigger attack
        if (chargeStage < slot.heavy.minChargeStages) {
          console.log(`  ‚Üí Charge insufficient! Resetting to stance.`);
          // Reset back to stance without attacking
          ATTACK.active = false;
          ATTACK.isCharging = false;
          ATTACK.slot = null;
          ATTACK.preset = null;
          CHARGE_STATE.stage = 0;
          // Transition back to stance
          startTransition(sampleOffsets(), 'Stance', 200);
          return;
        }
        
        // Execute or queue charged heavy attack
        console.log(`  ‚Üí Heavy attack ready with charge ${chargeStage}`);
        ATTACK.isCharging = false;
        
        // Check if we can execute now
        if (canAttackNow()) {
          executeHeavyAttack(slotKey, chargeStage);
        } else {
          // Queue the heavy attack
          if (!ATTACK_QUEUE.pending) {
            console.log('  ‚Üí Queueing heavy attack');
            ATTACK_QUEUE.pending = true;
            ATTACK_QUEUE.type = 'heavy';
            ATTACK_QUEUE.button = slotKey;
            ATTACK_QUEUE.chargeStage = chargeStage;
          }
        }
        
        CHARGE_STATE.stage = 0;
        return;
      }
    }

    // Fallback - reset
    console.log('  ‚Üí Fallback: resetting attack state');
    ATTACK.active = false;
    ATTACK.isCharging = false;
    ATTACK.slot = null; 
    ATTACK.preset = null;
    CHARGE_STATE.stage = 0;
  }

  // Bind attack buttons
  bindHold(btnAttackA, ()=> slotDown('A'), ()=> slotUp('A'));
  bindHold(btnAttackB, ()=> slotDown('B'), ()=> slotUp('B'));
  
  // Bind interact button
  if (btnInteract) {
    btnInteract.addEventListener('click', (e) => {
      e.preventDefault();
      handleInteraction();
    });
  }

  // Fullscreen button
  function toggleFullscreen(){
    const d = document;
    if (!d.fullscreenElement && !d.webkitFullscreenElement){
      const el = d.documentElement;
      if (el.requestFullscreen){ el.requestFullscreen(); }
      else if (el.webkitRequestFullscreen){ el.webkitRequestFullscreen(); }
    } else {
      if (d.exitFullscreen){ d.exitFullscreen(); }
      else if (d.webkitExitFullscreen){ d.webkitExitFullscreen(); }
    }
  }
  if (btnFullscreen){ btnFullscreen.addEventListener('click', toggleFullscreen); }

  // Keyboard controls - FIXED AND COMPLETE
  const keysPressed = {};
  
  window.addEventListener('keydown', (e)=>{
    if (e.repeat) return;
    keysPressed[e.code] = true;
    
    // Movement
    if (e.code==='KeyA'){ MOVE.input.left = true; }
    if (e.code==='KeyD'){ MOVE.input.right = true; }
    if (e.code==='ArrowLeft'){ MOVE.input.left = true; }
    if (e.code==='ArrowRight'){ MOVE.input.right = true; }
    
    // Dash (Shift key)
    if (e.code==='ShiftLeft' || e.code==='ShiftRight'){ MOVE.input.dash = true; }
    
    // Jump
    if ((e.code==='KeyW' || e.code==='ArrowUp' || e.code==='Space') && MOVE.onGround){ 
      e.preventDefault();
      MOVE.vel.y = CONFIG.movement.jumpImpulse; 
      MOVE.onGround=false;
      MOVE.input.jump = true;
    }
    
    // Attacks / Door Interaction
    if (e.code==='KeyE'){ 
      // Check if near a door first
      const nearDoor = checkDoorProximity();
      if (nearDoor && !ATTACK.active) {
        handleInteraction();
      } else {
        slotDown('A'); 
      }
    }
    if (e.code==='KeyF'){ slotDown('B'); }
    

    // Quick toggle NPC (dev convenience)
    if (e.code==='KeyN'){ toggleNpc(); }

    // Toggle AI HUD
    if (e.code==='F8'){ 
      const hud = document.getElementById('aiHud'); 
      if (hud) hud.style.display = (hud.style.display==='none' || !hud.style.display) ? 'block' : 'none'; 
    }
  });

  window.addEventListener('keyup', (e)=>{
    delete keysPressed[e.code];
    
    // Movement
    if (e.code==='KeyA'){ MOVE.input.left = false; }
    if (e.code==='KeyD'){ MOVE.input.right = false; }
    if (e.code==='ArrowLeft'){ MOVE.input.left = false; }
    if (e.code==='ArrowRight'){ MOVE.input.right = false; }
    if (e.code==='KeyW' || e.code==='ArrowUp' || e.code==='Space'){ MOVE.input.jump = false; }
    
    // Dash
    if (e.code==='ShiftLeft' || e.code==='ShiftRight'){ MOVE.input.dash = false; }
    
    // Attacks
    if (e.code==='KeyE'){ slotUp('A'); }
    if (e.code==='KeyF'){ slotUp('B'); }
  });

  // ====== Mouse Aiming Controls ======
  function updateMousePosition(e) {
    const rect = cv.getBoundingClientRect();
    // Get mouse position relative to canvas
    const scaleX = cv.width / rect.width;
    const scaleY = cv.height / rect.height;
    MOUSE.x = (e.clientX - rect.left) * scaleX;
    MOUSE.y = (e.clientY - rect.top) * scaleY;
    // World coordinates account for camera offset
    MOUSE.worldX = MOUSE.x + CAMERA.x;
    MOUSE.worldY = MOUSE.y;
  }

  cv.addEventListener('mousemove', (e) => {
    updateMousePosition(e);
    MOUSE.isInCanvas = true;
  });

  cv.addEventListener('mouseenter', (e) => {
    updateMousePosition(e);
    MOUSE.isInCanvas = true;
  });

  cv.addEventListener('mouseleave', () => {
    MOUSE.isInCanvas = false;
  });

  // Mouse button attack handlers
  cv.addEventListener('mousedown', (e) => {
    e.preventDefault();
    MOUSE.isDown = true;
    // Left click = Button A (combo on tap)
    if (e.button === 0) {
      slotDown('A');
    }
    // Right click = Button B (single attack on tap)
    else if (e.button === 2) {
      slotDown('B');
    }
  });

  cv.addEventListener('mouseup', (e) => {
    e.preventDefault();
    MOUSE.isDown = false;
    // Left click = Button A
    if (e.button === 0) {
      slotUp('A');
    }
    // Right click = Button B
    else if (e.button === 2) {
      slotUp('B');
    }
  });

  // Prevent context menu on right click
  cv.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });


  // Track mouse globally for when it leaves canvas
  window.addEventListener('mousemove', (e) => {
    if (!MOUSE.isInCanvas) {
      updateMousePosition(e);
    }
  });

  // ====== Attack executors ======
  function startHoldReleaseWindup(presetName){
    applyPreset(presetName);
    holding = true;
    const durs = getPresetDurations(presetName);
    startTransition(sampleOffsets(), 'Windup', durs.toWindup);
    // Remember which preset is being executed so we can display its name
    ATTACK.preset = presetName;
    // Track hold-release timing for knockback calculation
    ATTACK.isHoldRelease = true;
    ATTACK.holdStartTime = now();
    ATTACK.holdWindupDuration = durs.toWindup;
  }

  function finishHoldRelease(presetName){
    if (!holding) return;
    holding = false;
    const durs = getPresetDurations(presetName);
    startTransition(sampleOffsets(), 'Strike', durs.toStrike, ()=>{
      startTransition(current, 'Recoil', durs.toRecoil, ()=> startTransition(current, 'Stance', durs.toStance));
    });
  }

  function playQuickAttack(presetName, windupMs){
    // Set attack as active so colliders work properly
    ATTACK.active = true;
    
    applyPreset(presetName);
    // Track the preset so we can show the animation name in the HUD and
    // determine which colliders to activate
    ATTACK.preset = presetName;
    // Quick attacks are not hold-release
    ATTACK.isHoldRelease = false;
    const preset = CONFIG.presets && CONFIG.presets[presetName];
    // If the preset defines a custom sequence, use it
    if (preset && preset.sequence){
      // Deep clone the sequence so modifications don't affect the original
      const seq = preset.sequence.map(step => Object.assign({}, step));
      // Override the first Windup duration if windupMs is specified
      if (windupMs > 0){
        for (const step of seq){
          if (step.pose === 'Windup' && typeof step.durMs !== 'number'){
            step.durMs = windupMs;
            break;
          }
        }
      }
      runAttackSequence(presetName, seq, 0);
    } else {
      const durs = getPresetDurations(presetName);
      const wMs = windupMs>0 ? windupMs : durs.toWindup;
      startTransition(sampleOffsets(), 'Windup', wMs, ()=>{
        startTransition(current, 'Strike', durs.toStrike, ()=>{
          startTransition(current, 'Recoil', durs.toRecoil, ()=> startTransition(current, 'Stance', durs.toStance));
        });
      });
    }
  }

  /**
   * Calculate knockback force based on attack parameters and defender state.
   * 
   * @param {string} presetName - Name of the attack preset (e.g., 'KICK', 'PUNCH')
   * @param {boolean} isHoldRelease - Whether this is a hold-release attack
   * @param {number} holdStartTime - Time when hold started (for hold-release attacks)
   * @param {number} holdWindupDuration - Total windup duration (for hold-release attacks)
   * @param {number} defenderFooting - Defender's current footing value (0-100)
   * @returns {number} Final knockback force to apply
   */
  function calculateKnockback(presetName, isHoldRelease, holdStartTime, holdWindupDuration, defenderFooting) {
    const preset = CONFIG.presets && CONFIG.presets[presetName];
    if (!preset) return 0;
    
    // Base knockback from preset
    const baseKnockback = preset.knockbackBase || 0;
    
    // 1. Calculate hold-release timing modifier (0 to 1)
    let timingModifier = 1.0;
    if (isHoldRelease && holdWindupDuration > 0) {
      const holdDuration = now() - holdStartTime;
      // Normalize to 0-1 range, clamped
      timingModifier = Math.min(1.0, Math.max(0.0, holdDuration / holdWindupDuration));
    }
    
    // 2. Get weapon type modifier
    const weaponConfig = CONFIG.knockback.weaponTypes[CONFIG.knockback.currentWeapon] || CONFIG.knockback.weaponTypes.unarmed;
    const weaponModifier = weaponConfig.multiplier || 1.0;
    
    // 3. Calculate footing modifier (inverse relationship: less footing = more knockback)
    // At 0 footing: 2x knockback, at 100 footing: 1x knockback (no modifier)
    const maxFooting = CONFIG.knockback.maxFooting || 100;
    const footingRatio = Math.min(1.0, Math.max(0.0, defenderFooting / maxFooting));
    const footingModifier = 2.0 - footingRatio; // Ranges from 2.0 (unstable) to 1.0 (stable)
    
    // Calculate final knockback
    const finalKnockback = baseKnockback * timingModifier * weaponModifier * footingModifier;
    
    return finalKnockback;
  }

  // Run an authorable attack sequence. Each entry can specify:
  // - pose: the pose name to transition to
  // - durKey: a key looked up in preset durations (e.g. 'toWindup')
  // - durMs: a literal duration in ms overriding durKey
  function runAttackSequence(presetName, seq, idx=0){
    if (!seq || idx >= seq.length) return;
    const step = seq[idx] || {};
    const poseName = step.pose || 'Stance';
    // Determine duration: prefer literal ms, then durKey looked up, else fallback by pose name
    let dur = step.durMs;
    if (typeof dur !== 'number'){
      const poseObj = (CONFIG.poses && CONFIG.poses[poseName]) || null;
      if (poseObj && typeof poseObj.durMs === 'number') {
        dur = poseObj.durMs;
      } else if (step.durKey){ 
        const durs = getPresetDurations(presetName);
        dur = durs[step.durKey] || 0;
      } else {
        // fallback: use preset durations by mapping pose
        const durs = getPresetDurations(presetName);
        if (poseName==='Windup') dur = durs.toWindup;
        else if (poseName==='Strike' || poseName==='Strike1' || poseName==='Strike2') dur = durs.toStrike;
        else if (poseName==='Recoil') dur = durs.toRecoil;
        else dur = durs.toStance || 0;
      }
    }
    startTransition(sampleOffsets(), poseName, dur|0, ()=>{
      runAttackSequence(presetName, seq, idx+1);
    });
  }

  // ====== Pose & animation system ======
  const MIRROR = Object.create(null);
  // Persistent flip state used to toggle flips across attack stages.
  // Each entry represents the current mirror state per sprite tag.
  const FLIP_STATE = Object.create(null);

  /**
   * Sync FLIP_STATE from the current MIRROR settings.
   * This is used when a pose requests a hard reset of flips before playing.
   */
  function initFlipStateFromMirror(){
    for(const k in FLIP_STATE) delete FLIP_STATE[k];
    for(const k in MIRROR){ FLIP_STATE[k] = MIRROR[k]; }
  }
  const RENDER_CTX = { tag: null };
  const EVENT = { pose:null, idx:0, list:[] };

  function applyPreset(name){
    const p = CONFIG.presets && CONFIG.presets[name];
    if (!p) return false;
    CONFIG.poses = clone(p.poses);
    // Also copy Jump and Walk poses if missing
    if(!CONFIG.poses.Jump) CONFIG.poses.Jump = CONFIG.presets.SLAM.poses.Jump || CONFIG.poses.Stance;
    if(!CONFIG.poses.Walk) CONFIG.poses.Walk = CONFIG.presets.SLAM.poses.Walk || CONFIG.poses.Stance;
    return true;
  }

  function getPresetDurations(name){
    const p = CONFIG.presets && CONFIG.presets[name];
    return (p && p.durations) ? p.durations : CONFIG.durations;
  }

  function applyFighter(name){
    CONFIG.activeFighter = name;
    const f = CONFIG.fighters && CONFIG.fighters[name];
    if(!f) return false;
    
    if (f.actor) CONFIG.actor = clone(f.actor);
    if (f.parts) CONFIG.parts = clone(f.parts);
    if (f.basePose) CONFIG.basePose = clone(f.basePose);
    if (f.limits) CONFIG.limits = clone(f.limits);
    if (f.hierarchy) CONFIG.hierarchy = clone(f.hierarchy);
    if (f.ik) CONFIG.ik = clone(f.ik);
    if (f.offsets) CONFIG.offsets = clone(f.offsets);
    
    if (f.sprites){
      CONFIG.sprites = clone(f.sprites);
      loadSpriteMap(f.sprites);
    } else {
      CONFIG.sprites = null;
    }
    return true;
  }

  function resetSpriteMirrorsForPose(poseName){
    for (const k in MIRROR) delete MIRROR[k];
    const P = (CONFIG.poses && CONFIG.poses[poseName]) || null;
    const map = P && (P.spriteMirror || P.mirror || null);
    if (map){
      for (const k in map){ MIRROR[k.toUpperCase()] = !!map[k]; }
    }
  }

  function getPoseEvents(poseName){
    const P = (CONFIG.poses && CONFIG.poses[poseName]) || {};
    let list = P.anim_events || P.events || [];
    if (!list) return [];
    if (Array.isArray(list)) return list.slice().sort((a,b)=> (a.time||0) - (b.time||0));
    const arr=[]; 
    for (const k in list){ if (list[k]) arr.push(list[k]); }
    return arr.sort((a,b)=> (a.time||0) - (b.time||0));
  }

  function primeAnimEventsForPose(poseName){
    EVENT.pose = poseName; 
    EVENT.idx = 0; 
    EVENT.list = getPoseEvents(poseName);
  }

  function processAnimEvents(k){
    if (EVENT.list.length===0) return;
    while (EVENT.idx < EVENT.list.length && (EVENT.list[EVENT.idx].time||0) <= (k + 1e-6)){
      const ev = EVENT.list[EVENT.idx++];
      applyAnimEvent(ev);
    }
  }

  function facingForEvents(){ 
    return ATTACK.active ? ATTACK.facingRadAtPress : MOVE.facingRad; 
  }

  function applyAnimEvent(ev){
    if (!ev) return;
    const useLocal = !!ev.localVel || ev.velSpace === 'local';
    if (typeof ev.velocityX === 'number' || typeof ev.velocityY === 'number'){
      if (useLocal){
        const base = facingForEvents();
        const c=Math.cos(base), s=Math.sin(base);
        const vx = (ev.velocityX||0)*c - (ev.velocityY||0)*s;
        const vy = (ev.velocityX||0)*s + (ev.velocityY||0)*c;
        if (typeof ev.velocityX === 'number') MOVE.vel.x = vx;
        if (typeof ev.velocityY === 'number') MOVE.vel.y = vy;
      } else {
        const sign = ATTACK.active ? ATTACK.dirSign : 1;
        if (typeof ev.velocityX === 'number') MOVE.vel.x = sign * ev.velocityX;
        if (typeof ev.velocityY === 'number') MOVE.vel.y = ev.velocityY;
      }
    }
    if (typeof ev.impulse === 'number' && ev.impulse){
      const ang = facingForEvents() + deg2rad(ev.impulse_angle||0);
      MOVE.vel.x += Math.cos(ang) * ev.impulse;
      MOVE.vel.y += Math.sin(ang) * ev.impulse;
    }
  }

  // ====== Transitions ======
  function startTransition(fromOffsets, toName, duration, onDone){
    const fromName = nearestPose(fromOffsets);
    applyEntryImpulse(toName);
    const __P = (CONFIG.poses && CONFIG.poses[toName]) || {};
    // Determine if this pose requests a hard reset of flip states before starting.
    const __resetBefore = !!__P.resetFlipsBefore;
    if(__resetBefore){
      // Clear all MIRROR tags then sync FLIP_STATE to mirror.
      resetSpriteMirrorsForPose(toName);
      initFlipStateFromMirror();
    }
    primeAnimEventsForPose(toName);
    
    const __tagsAll = resolveTagsFromPart('ALL');
    const __baseline = Object.create(null);
    // Capture baseline from the persistent FLIP_STATE instead of the transient MIRROR.
    for (const __t of __tagsAll){ __baseline[__t] = !!FLIP_STATE[__t]; }
    const __flip = !!__P.flip;
    const __flipAt = (typeof __P.flipAt === 'number') ? Math.min(1, Math.max(0, __P.flipAt)) : 0;
    // Full-body flip settings
    const __fullFlip = !!__P.fullFlipFacing;
    const __fullFlipAt = (typeof __P.fullFlipAt === 'number') ? Math.min(1, Math.max(0, __P.fullFlipAt)) : __flipAt;

    active = { 
      from: clone(fromOffsets), 
      to: clone(CONFIG.poses[toName]), 
      start: now(), 
      dur: Math.max(1, duration|0), 
      onDone: onDone||null, 
      fromName, 
      toName,
      flip: __flip, 
      flipAt: __flipAt, 
      flipApplied: false, 
      flipBaseline: __baseline,
      fullFlip: __fullFlip,
      fullFlipAt: __fullFlipAt,
      fullFlipApplied: false
    };

    if (CONFIG.movement.lockFacingDuringAttack){
      if (toName === 'Windup'){
        FACE.active = true;
        if (ATTACK.active){ 
          FACE.rad = ATTACK.facingRadAtPress; 
        } else if (MOVE.input.left !== MOVE.input.right){ 
          FACE.rad = (MOVE.input.right ? 0 : Math.PI); 
        } else { 
          FACE.rad = MOVE.facingRad; 
        }
      } else if (toName === 'Strike'){
        // Reset strike landed flag when entering Strike phase
        ATTACK.strikeLanded = false;
        ATTACK.currentPhase = 'Strike';
        
        // Activate lunge mechanic - leap forward during Strike
        if (fromName === 'Windup') {
          ATTACK.lunge.active = true;
          ATTACK.lunge.paused = false;  // Start immediately
          ATTACK.lunge.distance = 0;
          
          // Calculate lunge direction based on aim
          const aimAngle = ATTACK.facingRadAtPress;
          const lungeSpeed = ATTACK.lunge.speed;
          ATTACK.lunge.lungeVel.x = Math.cos(aimAngle) * lungeSpeed;
          ATTACK.lunge.lungeVel.y = Math.sin(aimAngle) * lungeSpeed * 0.3;  // Reduced vertical
        }
      } else if (toName === 'Recoil' && ATTACK.currentPhase === 'Strike'){
        // Leaving Strike phase - if no hit landed, reset combo
        if (!ATTACK.strikeLanded) {
          COMBO.hits = 0;
        }
        ATTACK.currentPhase = 'Recoil';
      } else if (toName === 'Stance'){
        FACE.active = false;
        ATTACK.currentPhase = null;
        // Only clear ATTACK state if we're already in an attack and returning to Stance
        // This prevents clearing ATTACK.active when Stance is used as a starting pose in sequences
        if (ATTACK.active && lastPoseName && lastPoseName !== 'Stance') {
          ATTACK.active = false; 
          ATTACK.slot=null; 
          ATTACK.preset=null;
        }
      }
    }
  }

  function sampleOffsets(){ 
    if (!active) return clone(current); 
    const t = Math.min(1, Math.max(0, (now()-active.start)/active.dur));
    
    // Use custom easing for hold-release Windup transitions
    // This creates a speed curve that starts faster then slows down
    let k;
    if (active.toName === 'Windup' && ATTACK.isHoldRelease) {
      // Custom ease-out curve: starts fast (70% progress in first 30% of time)
      // Then slows down for the remaining time
      // This makes the windup feel more responsive while still allowing buildup
      if (t < 0.3) {
        // Fast initial phase - accelerate to 70% progress
        k = (t / 0.3) * 0.7;
      } else {
        // Slow buildup phase - cover remaining 30% progress
        const remainingT = (t - 0.3) / 0.7;
        k = 0.7 + (remainingT * 0.3);
      }
    } else {
      // Standard easing for all other transitions
      k = easeInOutCubic(t);
    }
    
    // Apply per-bone flip event exactly once when reaching flipAt.
    if (active.flip && !active.flipApplied && k >= active.flipAt){
      active.flipApplied = true;
      const __P = (CONFIG.poses && CONFIG.poses[active.toName]) || {};
      const flipParts = __P.flipParts || ['ALL'];
      for (const p of flipParts){
        const tags = resolveTagsFromPart(p);
        for (const tg of tags){
          // Toggle relative to the baseline and update both MIRROR and FLIP_STATE.
          const newVal = !active.flipBaseline[tg];
          MIRROR[tg] = newVal;
          FLIP_STATE[tg] = newVal;
        }
      }
    }

    // Apply full-body flip (facing rotation) exactly once at the authored time.
    if (active.fullFlip && !active.fullFlipApplied && k >= active.fullFlipAt){
      active.fullFlipApplied = true;
      // Normalize angle helper
      const norm = (a)=>{ const TAU = Math.PI*2; a %= TAU; return (a < 0) ? (a + TAU) : a; };
      // Rotate move facing by œÄ
      MOVE.facingRad = norm(MOVE.facingRad + Math.PI);
      // Rotate face direction if locked
      if (FACE.active){ FACE.rad = norm(FACE.rad + Math.PI); }
      // Flip local dirSign so local impulses/velocities remain consistent
      if (ATTACK && typeof ATTACK.dirSign === 'number'){ ATTACK.dirSign *= -1; }
    }

    return mix(active.from, active.to, k);
  }

  function resolveTagsFromPart(part){
    const ALL = ['TORSO','HEAD','ARM_L_UPPER','ARM_L_LOWER','ARM_R_UPPER','ARM_R_LOWER',
                 'LEG_L_UPPER','LEG_L_LOWER','LEG_R_UPPER','LEG_R_LOWER','HITBOX'];
    if (!part || part===' ' || part==='*' || part==='ALL') return ALL;
    const p = String(part).trim().toUpperCase();
    const groups = {
      ARMUPPER:['ARM_L_UPPER','ARM_R_UPPER'],
      ARMLOWER:['ARM_L_LOWER','ARM_R_LOWER'],
      LEGUPPER:['LEG_L_UPPER','LEG_R_UPPER'],
      LEGLOWER:['LEG_L_LOWER','LEG_R_LOWER']
    };
    return groups[p] ? groups[p] : [p];
  }

  function getPoseBlend(){
    if(!active) return { fromName: lastPoseName, toName: lastPoseName, k: 1 };
    const t = Math.min(1, (now() - active.start) / active.dur);
    const k = easeInOutCubic(Math.max(0, t));
    return { fromName: active.fromName, toName: active.toName, k };
  }

  function applyEntryImpulse(poseName){
    const P = CONFIG.poses[poseName], mag = P.impulseMag || 0; 
    if (!mag) return;
    const base = facingForEvents();
    const rad = base + deg2rad(P.impulseDirDeg || 0);
    MOVE.vel.x += Math.cos(rad) * mag;
    MOVE.vel.y += Math.sin(rad) * mag;
  }

  // ====== Physics ======
  // ====== UNIVERSAL FIGHTER PHYSICS SYSTEM ======
  // This ONE system works for BOTH player and NPC - NO duplication!
  
  // Joint physics configuration
  const JOINT_PHYSICS = {
    damping: 0.92,
    normalStiffness: 0.25,
    ragdollStiffness: 0.05,
    maxAngularVel: 0.3,
    joints: {
      torso: { mass: 2.0, limits: [-0.8, 0.8] },
      lShoulder: { mass: 0.5, limits: [-1.5, 1.5] },
      rShoulder: { mass: 0.5, limits: [-1.5, 1.5] },
      lElbow: { mass: 0.4, limits: [-2.5, 0.2] },
      rElbow: { mass: 0.4, limits: [-0.2, 2.5] },
      lHip: { mass: 0.8, limits: [-1.2, 0.8] },
      rHip: { mass: 0.8, limits: [-1.2, 0.8] },
      lKnee: { mass: 0.6, limits: [-0.2, 2.0] },
      rKnee: { mass: 0.6, limits: [-0.2, 2.0] }
    }
  };

  // Initialize joint physics for any fighter
  function initJointPhysics(fighter) {
    if (!fighter.jointAngles) fighter.jointAngles = {};
    const jointKeys = Object.keys(JOINT_PHYSICS.joints);
    for (const key of jointKeys) {
      if (!(key in fighter.jointAngles)) fighter.jointAngles[key] = 0;
      const velKey = key + 'Vel';
      if (!(velKey in fighter.jointAngles)) fighter.jointAngles[velKey] = 0;
    }
  }

  // Update joint physics for any fighter
  function updateJointPhysics(fighter, dt) {
    initJointPhysics(fighter);
    
    const jointKeys = Object.keys(JOINT_PHYSICS.joints);
    const stiffness = fighter.ragdoll ? JOINT_PHYSICS.ragdollStiffness : JOINT_PHYSICS.normalStiffness;
    
    for (const key of jointKeys) {
      const velKey = key + 'Vel';
      const joint = JOINT_PHYSICS.joints[key];
      
      const angle = fighter.jointAngles[key] || 0;
      let angularVel = fighter.jointAngles[velKey] || 0;
      
      let targetAngle = 0;
      if (fighter.ragdoll) {
        if (!fighter.jointAngles[key + 'Target']) {
          fighter.jointAngles[key + 'Target'] = (Math.random() - 0.5) * 0.5;
        }
        targetAngle = fighter.jointAngles[key + 'Target'];
        
        if (fighter.ragdollTime < 0.5) {
          angularVel += (Math.random() - 0.5) * 0.3 * dt;
        }
      } else if (fighter.recovering) {
        const stancePose = CONFIG.poses.Stance;
        const t = Math.min(1.0, fighter.recoveryTime / fighter.recoveryDuration);
        const eased = 1 - Math.pow(1 - t, 3);
        targetAngle = lerp(fighter.recoveryStartAngles[key] || 0, stancePose[key] || 0, eased);
      } else {
        targetAngle = 0;
      }
      
      const angleError = targetAngle - angle;
      angularVel += angleError * stiffness;
      angularVel *= JOINT_PHYSICS.damping;
      angularVel = Math.max(-JOINT_PHYSICS.maxAngularVel, Math.min(JOINT_PHYSICS.maxAngularVel, angularVel));
      
      const newAngle = angle + angularVel;
      const limits = joint.limits;
      fighter.jointAngles[key] = Math.max(limits[0], Math.min(limits[1], newAngle));
      fighter.jointAngles[velKey] = angularVel;
    }
    
    if (fighter.ragdoll) {
      const torsoTilt = fighter.jointAngles.torso || 0;
      fighter.vel.x += Math.sin(torsoTilt) * 0.15 * dt;
    }
  }

  // Enter ragdoll state for any fighter
  function enterRagdollState(fighter) {
    console.log(`‚ö†Ô∏è ${fighter.id.toUpperCase()} RAGDOLL ACTIVATED - Footing: ${fighter.footing.toFixed(1)}`);
    
    fighter.ragdoll = true;
    fighter.ragdollTime = 0;
    fighter.ragdollVel = {x: fighter.vel.x, y: fighter.vel.y};
    
    initJointPhysics(fighter);
    const jointKeys = Object.keys(JOINT_PHYSICS.joints);
    for (const key of jointKeys) {
      const velKey = key + 'Vel';
      fighter.jointAngles[velKey] = (fighter.jointAngles[velKey] || 0) + (Math.random() - 0.5) * 0.15;
    }
  }

  // UNIVERSAL PHYSICS - Works for Player AND NPC!
  function updateFighterPhysics(fighter, dt) {
    const M = CONFIG.movement;
    const hb = CONFIG.parts.hitbox;
    const hbH = hb.h * CONFIG.actor.scale;
    const groundCenterY = CONFIG.groundY - hbH/2;
    const wasGrounded = fighter.onGround;
    
    // 1. GRAVITY (always)
    const gravityMult = fighter.ragdoll ? 1.8 : 1.0;
    fighter.vel.y += M.gravity * dt * gravityMult;
    
    // 2. HORIZONTAL MOVEMENT (only in normal mode, only if has input)
    if (!fighter.ragdoll && !fighter.recovering && fighter.input) {
      const dashMult = fighter.stamina.isDashing ? CONFIG.movement.dashSpeedMultiplier : 1.0;
      const accelX = M.accelX * dashMult;
      const maxSpeed = M.maxSpeedX * dashMult;
      
      if (fighter.input.left) fighter.vel.x -= accelX * dt;
      if (fighter.input.right) fighter.vel.x += accelX * dt;
      
      fighter.vel.x = clamp(fighter.vel.x, -maxSpeed, maxSpeed);
    }
    
    // 3. FRICTION
    if (fighter.ragdoll) {
      if (!fighter.ragdollVel) fighter.ragdollVel = {x: fighter.vel.x, y: fighter.vel.y};
      fighter.vel.x = fighter.ragdollVel.x * 0.96;
      fighter.ragdollVel.x *= 0.96;
    } else {
      fighter.vel.x *= Math.exp(-M.friction * dt);
    }
    
    // 4. JOINT PHYSICS
    updateJointPhysics(fighter, dt);
    
    // 5. POSITION UPDATE
    fighter.pos.x += fighter.vel.x * dt;
    fighter.pos.y += fighter.vel.y * dt;
    
    // 6. BOUNDS - clamp to world boundaries
    const margin = 40;
    fighter.pos.x = clamp(fighter.pos.x, margin, WORLD_WIDTH - margin);
    
    // 7. GROUND COLLISION
    const groundY = fighter.ragdoll ? (CONFIG.groundY - 20 * CONFIG.actor.scale) : groundCenterY;
    
    if (fighter.pos.y >= groundY) {
      fighter.pos.y = groundY;
      
      if (fighter.vel.y > 0) {
        if (fighter.ragdoll) {
          fighter.vel.y = -fighter.vel.y * 0.2;
          const jointKeys = Object.keys(JOINT_PHYSICS.joints);
          for (const key of jointKeys) {
            const velKey = key + 'Vel';
            if (fighter.jointAngles[velKey]) {
              fighter.jointAngles[velKey] *= 0.5;
            }
          }
        } else {
          fighter.landedImpulse = Math.max(fighter.landedImpulse || 0, fighter.vel.y);
          fighter.vel.y = -fighter.vel.y * M.restitution;
        }
      }
      fighter.onGround = true;
    } else {
      fighter.onGround = false;
    }
    
    // 8. STATE TRANSITIONS
    if (fighter.ragdoll) {
      fighter.ragdollTime += dt;
      
      if (fighter.onGround && fighter.ragdollTime > 2.5) {
        fighter.ragdoll = false;
        fighter.ragdollTime = 0;
        fighter.recovering = true;
        fighter.recoveryTime = 0;
        fighter.recoveryStartY = fighter.pos.y;
        fighter.recoveryTargetY = groundCenterY;
        
        fighter.recoveryStartAngles = {};
        const jointKeys = Object.keys(JOINT_PHYSICS.joints);
        for (const key of jointKeys) {
          fighter.recoveryStartAngles[key] = fighter.jointAngles[key] || 0;
        }
        fighter.footing = 30;
      }
    } else if (fighter.recovering) {
      fighter.recoveryTime += dt;
      const t = Math.min(1.0, fighter.recoveryTime / fighter.recoveryDuration);
      
      fighter.pos.y = lerp(fighter.recoveryStartY, fighter.recoveryTargetY, t);
      
      if (t >= 1.0) {
        fighter.recovering = false;
        fighter.recoveryTime = 0;
      }
    }
    
    // 9. FOOTING RECOVERY
    if (fighter.onGround && !fighter.ragdoll) {
      const recoveryRate = 20;
      fighter.footing = Math.min(CONFIG.knockback.maxFooting, fighter.footing + recoveryRate * dt);
    }
    
    // 10. AUTO-RAGDOLL TRIGGER
    if (!fighter.ragdoll && !fighter.recovering && fighter.footing <= 10) {
      enterRagdollState(fighter);
    }
    
    // 11. LEGACY CALF RAGDOLL (player only)
    if (fighter.isPlayer && CONFIG.ragdoll && CONFIG.ragdoll.enabled && CONFIG.ragdoll.autoCalvesMidAir) {
      const posePhase = (active && CONFIG.poses && CONFIG.poses[active.toName] && CONFIG.poses[active.toName].phase) || null;
      const inAttack = ATTACK.active || (posePhase==='windup' || posePhase==='strike' || posePhase==='recoil');
      RAG.active = !fighter.onGround && !inAttack && !fighter.ragdoll;
      RAG.lCalfRagdoll = RAG.active && CONFIG.ragdoll.limbs.lCalf;
      RAG.rCalfRagdoll = RAG.active && CONFIG.ragdoll.limbs.rCalf;
    }
    
    fighter.landedImpulse = (fighter.landedImpulse || 0) * Math.exp(-10 * dt);
    fighter.prevOnGround = wasGrounded;
  }

  // Player physics wrapper (backward compatibility)
  function stepPhysics(dt) {
    updateFighterPhysics(MOVE, dt);
  }

  function updateFacing(dt){
    /**
     * Update the facing orientation of the fighter. In the original logic the
     * facing direction would be derived from the current velocity vector
     * (e.g. when recoiling or falling), which caused the fighter to spin
     * during physics interactions. For better control we now only respond
     * to explicit player input (left/right) or to an active face lock
     * during attacks. This means physics alone will no longer change the
     * facing direction, eliminating unintended flips during recoil or slam.
     */
    let target = MOVE.facingRad;
    if (CONFIG.movement.lockFacingDuringAttack && FACE.active){
      // Preserve attack facing when locked
      target = FACE.rad;
    } else {
      // Only flip facing when the player is actively pressing left or right
      // UNLESS dashing is active - keep facing locked during dash
      if (MOVE.input.left !== MOVE.input.right && !STAMINA.isDashing){
        target = MOVE.input.right ? 0 : Math.PI;
      }
    }
    const s = 1 - Math.exp(-CONFIG.movement.facingSmooth * dt);
    MOVE.facingRad = lerpAngle(MOVE.facingRad, target, s);
  }

  function computePhysicsOffsets(dt){
    const o = {}; 
    o.torso = clamp(MOVE.vel.x * 0.04, -25, 25);
    const crouch = clamp(MOVE.landedImpulse * 0.04, 0, 60);
    o.lKnee = crouch; 
    o.rKnee = crouch; 
    o.lHip = -crouch*0.25; 
    o.rHip = -crouch*0.25;
    
    // Add jump animation
    if(!MOVE.onGround && MOVE.input.jump){
      o.torso -= 10;
      o.lHip += 30;
      o.rHip += 30;
      o.lKnee += 30;
      o.rKnee += 30;
    }
    
    return o;
  }

  function nearestPose(delta){
    const d = (P)=> Object.keys(CONFIG.basePose).reduce((s,k)=> s + Math.abs((P[k]||0)-(delta[k]||0)), 0);
    const scores = [
      ['Stance', d(CONFIG.poses.Stance)], 
      ['Windup', d(CONFIG.poses.Windup)], 
      ['Strike', d(CONFIG.poses.Strike)], 
      ['Recoil', d(CONFIG.poses.Recoil)]
    ].sort((a,b)=> a[1]-b[1]);
    return scores[0][0];
  }

  // ====== Walk layer ======
  function computeWalkOffsets(baseOffsets, dt){
    const W=CONFIG.walk, out={}; 
    if(!W.enabled) return out;
    
    const blend = getPoseBlend();
    const pureStance = (blend.fromName==='Stance' && blend.toName==='Stance');
    const speed = Math.abs(MOVE.vel.x);
    const hasWalk = (MOVE.input.left !== MOVE.input.right);
    const active = pureStance && MOVE.onGround && speed > W.minSpeed && hasWalk;
    
    const k = 1 - Math.exp(-8 * dt);
    const targetAmp = active ? 1 : 0;
    WALK.amp += (targetAmp - WALK.amp) * k;
    
    if (WALK.amp < 1e-3) return out;
    
    const speedNorm = clamp(speed/CONFIG.movement.maxSpeedX, 0, 1);
    const hz = W.baseHz * (0.6 + 0.8 * speedNorm) * W.speedScale;
    WALK.phase = (WALK.phase + hz * dt * TAU) % TAU;
    const t = (Math.sin(WALK.phase)+1)/2;
    
    const A=W.poses.A, B=W.poses.B, S=CONFIG.poses.Stance;
    const WalkPose={ 
      torso:lerp(A.torso||0,B.torso||0,t), 
      lHip:lerp(A.lHip||0,B.lHip||0,t), 
      lKnee:lerp(A.lKnee||0,B.lKnee||0,t), 
      rHip:lerp(A.rHip||0,B.rHip||0,t), 
      rKnee:lerp(A.rKnee||0,B.rKnee||0,t) 
    };
    
    out.torso = lerp(S.torso||0, WalkPose.torso, WALK.amp);
    out.lHip  = lerp(S.lHip ||0, WalkPose.lHip , WALK.amp);
    out.lKnee = lerp(S.lKnee||0, WalkPose.lKnee, WALK.amp);
    out.rHip  = lerp(S.rHip ||0, WalkPose.rHip , WALK.amp);
    out.rKnee = lerp(S.rKnee||0, WalkPose.rKnee, WALK.amp);
    out.__overwrite = pureStance;
    return out;
  }

  // ====== Aiming System ======
  function updatePlayerAiming(dt) {
    if (!CONFIG.aiming.enabled) {
      AIM.active = false;
      return;
    }
    
    // Check if current pose allows aiming
    const blend = getPoseBlend();
    const currentPose = CONFIG.poses[blend.toName];
    const allowAiming = currentPose && currentPose.allowAiming !== false;
    
    if (!allowAiming) {
      AIM.active = false;
      AIM.torsoOffset = 0;
      AIM.shoulderOffset = 0;
      AIM.hipOffset = 0;
      return;
    }
    
    AIM.active = true;
    
    let targetAngle;
    
    // Use joystick for aiming if active, otherwise use mouse
    if (AIMING.manualAim && JOYSTICK.active) {
      // Joystick aiming - use joystick angle directly
      targetAngle = AIMING.targetAngle;
      
      // Check joystick side for flipping
      const joystickSide = Math.cos(targetAngle) >= 0 ? 0 : Math.PI;
      const currentSide = Math.cos(MOVE.facingRad) >= 0 ? 0 : Math.PI;
      if (joystickSide !== currentSide && !STAMINA.isDashing) {
        MOVE.facingRad = joystickSide;
      }
    } else {
      // Mouse aiming - calculate angle to mouse from player position
      const dx = MOUSE.worldX - MOVE.pos.x;
      const dy = MOUSE.worldY - MOVE.pos.y;
      targetAngle = Math.atan2(dy, dx);
      
      // Check if mouse crossed character center for flipping
      const mouseSide = dx > 0 ? 0 : Math.PI;
      const currentSide = Math.cos(MOVE.facingRad) >= 0 ? 0 : Math.PI;
      if (MOUSE.isDown && mouseSide !== currentSide && !STAMINA.isDashing) {
        MOVE.facingRad = mouseSide;
      }
    }
    
    // Convert target angle relative to current facing
    let relativeAngle = targetAngle - MOVE.facingRad;
    // Normalize to -PI to PI range
    while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
    while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
    
    // Smooth the aim angle
    const smoothing = 1 - Math.exp(-CONFIG.aiming.smoothing * dt);
    AIM.currentAngle += (relativeAngle - AIM.currentAngle) * smoothing;
    
    // Calculate offsets based on aim angle
    const aimDeg = rad2deg(AIM.currentAngle);
    AIM.torsoOffset = clamp(aimDeg * 0.5, -CONFIG.aiming.maxTorsoAngle, CONFIG.aiming.maxTorsoAngle);
    AIM.shoulderOffset = clamp(aimDeg * 0.7, -CONFIG.aiming.maxShoulderAngle, CONFIG.aiming.maxShoulderAngle);
    
    // Apply leg aiming if pose allows it
    if (currentPose.aimLegs) {
      if (currentPose.aimRightLegOnly) {
        AIM.hipOffset = clamp(aimDeg * 0.6, -50, 50); // Only right leg aims
      } else {
        AIM.hipOffset = clamp(aimDeg * 0.4, -40, 40); // Both legs aim
      }
    } else {
      AIM.hipOffset = 0;
    }
  }
  
  function updateNpcAiming(dt) {
    if (!CONFIG.aiming.enabled) {
      NPC_STATE.aim.active = false;
      return;
    }
    
    // NPC aims at player when jumping
    const shouldAim = !NPC_STATE.onGround;
    
    if (!shouldAim) {
      NPC_STATE.aim.active = false;
      NPC_STATE.aim.torsoOffset = 0;
      NPC_STATE.aim.shoulderOffset = 0;
      NPC_STATE.aim.hipOffset = 0;
      return;
    }
    
    NPC_STATE.aim.active = true;
    
    // Calculate angle to player from NPC position
    const dx = MOVE.pos.x - NPC_STATE.pos.x;
    const dy = MOVE.pos.y - NPC_STATE.pos.y;
    let targetAngle = Math.atan2(dy, dx);
    
    // Convert target angle relative to NPC facing
    let relativeAngle = targetAngle - NPC_STATE.facingRad;
    while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
    while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
    
    // Smooth the aim angle
    const smoothing = 1 - Math.exp(-CONFIG.aiming.smoothing * dt);
    NPC_STATE.aim.currentAngle += (relativeAngle - NPC_STATE.aim.currentAngle) * smoothing;
    
    // Calculate offsets
    const aimDeg = rad2deg(NPC_STATE.aim.currentAngle);
    NPC_STATE.aim.torsoOffset = clamp(aimDeg * 0.5, -CONFIG.aiming.maxTorsoAngle, CONFIG.aiming.maxTorsoAngle);
    NPC_STATE.aim.shoulderOffset = clamp(aimDeg * 0.7, -CONFIG.aiming.maxShoulderAngle, CONFIG.aiming.maxShoulderAngle);
    NPC_STATE.aim.hipOffset = 0; // NPC doesn't aim legs
  }
  
  function applyAimingOffsets(offsets, aimState) {
    if (!aimState.active) return offsets;
    
    // Apply aiming offsets to the pose
    const result = {...offsets};
    result.torso = (result.torso || 0) + aimState.torsoOffset;
    result.lShoulder = (result.lShoulder || 0) + aimState.shoulderOffset;
    result.rShoulder = (result.rShoulder || 0) + aimState.shoulderOffset;
    
    // Apply leg aiming if present
    if (aimState.hipOffset !== 0) {
      // Check the offsets object itself for aiming flags
      const aimLegs = offsets.aimLegs;
      const aimRightLegOnly = offsets.aimRightLegOnly;
      
      if (aimRightLegOnly) {
        // Only right leg
        result.rHip = (result.rHip || 0) + aimState.hipOffset;
      } else if (aimLegs) {
        // Both legs
        result.lHip = (result.lHip || 0) + aimState.hipOffset;
        result.rHip = (result.rHip || 0) + aimState.hipOffset;
      }
    }
    
    return result;
  }

  // ====== Orchestrator ======
  function orchestrate(offsets, dt){
    const blend = getPoseBlend();
    const vFrom = CONFIG.poses[blend.fromName].rootMoveVel || {x:0,y:0};
    const vTo   = CONFIG.poses[blend.toName].rootMoveVel   || {x:0,y:0};
    const vAuth = mixVec(vFrom, vTo, blend.k);
    const wa = CONFIG.movement.authoredWeight;
    
    if (CONFIG.movement.rootVelRelative){
      const c=Math.cos(MOVE.facingRad), s=Math.sin(MOVE.facingRad);
      const vx=vAuth.x*c - vAuth.y*s, vy=-(vAuth.x*s + vAuth.y*c);
      MOVE.pos.x += wa*vx*dt; 
      MOVE.pos.y += wa*vy*dt;
    } else { 
      MOVE.pos.x += wa*vAuth.x*dt; 
      MOVE.pos.y += wa*vAuth.y*dt; 
    }
    
    const __blend = getPoseBlend(); 
    processAnimEvents(__blend.k);
    stepPhysics(dt); 
    updateFacing(dt);
    updatePlayerAiming(dt);  // Update aiming system
    
    const phys = computePhysicsOffsets(dt);
    let finalOffsets = addOffsets(offsets, scaleOffsets(phys, CONFIG.movement.physicsWeight));
    
    const w = computeWalkOffsets(finalOffsets, dt);
    if (w.__overwrite){ 
      for(const k of ['torso','lHip','lKnee','rHip','rKnee']) 
        if(k in w) finalOffsets[k]=w[k]; 
    } else { 
      finalOffsets = addOffsets(finalOffsets, w); 
    }
    
    // Apply aiming offsets to final pose
    finalOffsets = applyAimingOffsets(finalOffsets, AIM);
    
    return { offsets: finalOffsets, hitCenter: { x: MOVE.pos.x, y: MOVE.pos.y } };
  }

  // ====== Limits ======
  function clampAngles(A){
    const L=CONFIG.limits;
    A.torso = clamp(A.torso, L.torso.absMin, L.torso.absMax);
    const lShRel = clamp(A.lShoulder - A.torso, L.shoulder.relMin, L.shoulder.relMax);
    const rShRel = clamp(A.rShoulder - A.torso, L.shoulder.relMin, L.shoulder.relMax);
    A.lShoulder = lShRel + A.torso; 
    A.rShoulder = rShRel + A.torso;
    A.lElbow = clamp(A.lElbow, L.elbow.relMin, L.elbow.relMax);
    A.rElbow = clamp(A.rElbow, L.elbow.relMin, L.elbow.relMax);
    A.lHip = clamp(A.lHip, L.hip.absMin, L.hip.absMax);
    A.rHip = clamp(A.rHip, L.hip.absMin, L.hip.absMax);
    A.lKnee = clamp(A.lKnee, L.knee.relMin, L.knee.relMax);
    A.rKnee = clamp(A.rKnee, L.knee.relMin, L.knee.relMax);
    return A;
  }

  // ====== Render helpers ======
  function drawGround(){ 
    const y = CONFIG.groundY; 
    cx.strokeStyle = CONFIG.colors.guide; 
    cx.lineWidth = 2; 
    cx.beginPath(); 
    cx.moveTo(0, y); 
    cx.lineTo(WORLD_WIDTH, y); 
    cx.stroke(); 
  }
  
  function segPos(x,y,len,ang){ 
    const ex = x + len*Math.sin(ang); 
    const ey = y - len*Math.cos(ang); 
    return [ex,ey]; 
  }
  
  function withAX(x,y,ang,off){ 
    if(!off) return [x,y]; 
    const ax = off.ax||0, ay = off.ay||0; 
    const dx = ax*Math.sin(ang) + ay*Math.cos(ang); 
    const dy = ax*(-Math.cos(ang)) + ay*Math.sin(ang); 
    return [x+dx, y+dy]; 
  }

  const DEFAULT_RENDER_ORDER = ['HITBOX','ARM_L_UPPER','ARM_L_LOWER','LEG_L_UPPER','LEG_L_LOWER','TORSO','HEAD','LEG_R_UPPER','LEG_R_LOWER','ARM_R_UPPER','ARM_R_LOWER'];
  
  function zOrder(tag){
    const o = (CONFIG.render && Array.isArray(CONFIG.render.order)) ? CONFIG.render.order : DEFAULT_RENDER_ORDER;
    const i = o.indexOf(tag);
    return (i === -1) ? (o.length + 10) : i;
  }
  
  function enqueue(Q, tag, fn){ 
    Q.push({ z: zOrder(tag), tag, fn }); 
  }

  // ====== Sprite system ======
  const SPRITES = { cache:{}, loaded:{}, failed:new Set(), pending:new Set(), el:null };
  
  function ensureSpriteCacheEl(){
    if (!SPRITES.el){
      const el = document.createElement('div'); 
      el.id = 'spriteContainer';
      el.style.position = 'absolute'; 
      el.style.left = '-9999px'; 
      el.style.top = '-9999px';
      el.style.width = '1px'; 
      el.style.height = '1px'; 
      el.style.overflow = 'hidden'; 
      el.style.visibility = 'hidden';
      document.body.appendChild(el); 
      SPRITES.el = el;
    }
  }
  
  function _loadImage(key, url){
    if(!url || SPRITES.cache[key]) return;
    ensureSpriteCacheEl();
    const img = document.createElement('img');
  img.crossOrigin = 'anonymous'; // added for remote sprites on canvas
    img.decoding = 'async'; 
    img.loading = 'eager'; 
    img.alt = '';
    img.style.width = '1px'; 
    img.style.height = '1px'; 
    img.style.opacity = '0';
    SPRITES.pending.add(key);
    img.addEventListener('load', ()=>{ 
      SPRITES.loaded[key] = true; 
      SPRITES.pending.delete(key); 
      refreshSpriteDebug(); 
    });
    img.addEventListener('error', ()=>{ 
      console.warn('Sprite failed:', key, url); 
      SPRITES.failed.add(key); 
      SPRITES.pending.delete(key); 
      refreshSpriteDebug(); 
    });
    img.src = url;
    SPRITES.cache[key] = img; 
    SPRITES.el.appendChild(img);
  }
  
  function loadSpriteMap(map){
    if(!map) return;
    if(map.torso) _loadImage('torso', map.torso);
    if(map.head)  _loadImage('head', map.head);
    if(map.arm && map.arm.upper) _loadImage('armUpper', map.arm.upper);
    if(map.arm && map.arm.lower) _loadImage('armLower', map.arm.lower);
    if(map.leg && map.leg.upper) _loadImage('legUpper', map.leg.upper);
    if(map.leg && map.leg.lower) _loadImage('legLower', map.leg.lower);
    refreshSpriteDebug();
  }

  function drawBoneSprite(xStart,yStart,len,ang,key,widthFactor){
    const img = SPRITES.cache[key];
    if(!img || !SPRITES.loaded[key]) return false;

    const baseH = Math.max(1, len);
    const nh = (img.naturalHeight || img.height || 1);
    const nw = (img.naturalWidth  || img.width  || 1);
    const s = baseH / nh;
    let w = nw * s * (widthFactor || 1);
    let h = baseH;

    const mid = segPos(xStart, yStart, len*0.5, ang);
    let x = mid[0], y = mid[1];

    const style = (CONFIG.sprites && CONFIG.sprites.style) || {};
    const units = (style.xformUnits || 'px');
    const xf = (style.xform && style.xform[key]) || (style.transforms && style.transforms[key]) || null;

    if (xf && (xf.ax || xf.ay)){
      let ax = xf.ax || 0;
      let ay = xf.ay || 0;
      if (units === 'percent'){ ax = ax * len; ay = ay * len; }
      [x,y] = withAX(x,y, ang, {ax, ay});
    }

    if (xf && (xf.scaleX || xf.scaleY)){
      const sx = (xf.scaleX==null?1:xf.scaleX);
      const sy = (xf.scaleY==null?1:xf.scaleY);
      w *= sx; h *= sy;
    }

    const rot = (xf && xf.rotDeg ? deg2rad(xf.rotDeg) : 0);

    cx.save();
    cx.translate(x, y);
    cx.rotate(ang + rot + Math.PI);
    let _w = w;
    if (RENDER_CTX && RENDER_CTX.tag && false){ _w = -w; }
    cx.drawImage(img, -_w/2, -h/2, _w, h);
    cx.restore();
    return true;
  }

  function seg(x,y,len,ang){
    const [ex,ey]=segPos(x,y,len,ang);
    if (!CONFIG.render || CONFIG.render.debugBones){
      cx.beginPath(); cx.moveTo(x,y); cx.lineTo(ex,ey); cx.stroke();
    }
    return [ex,ey];
  }

  function drawHitbox(cx0,cy0,w,h,r){
    w*=CONFIG.actor.scale; h*=CONFIG.actor.scale; r*=CONFIG.actor.scale;
    const x=cx0-w/2, y=cy0-h/2, rr=Math.min(r,w/2,h/2);
    if (!CONFIG.render || CONFIG.render.debugBones){
      cx.save(); 
      cx.lineWidth=2; 
      cx.strokeStyle=CONFIG.colors.hitbox;
      cx.beginPath(); 
      cx.moveTo(x+rr,y); 
      cx.lineTo(x+w-rr,y); 
      cx.arc(x+w-rr,y+rr,rr,-Math.PI/2,0);
      cx.lineTo(x+w,y+h-rr); 
      cx.arc(x+w-rr,y+h-rr,rr,0,Math.PI/2); 
      cx.lineTo(x+rr,y+h);
      cx.arc(x+rr,y+h-rr,rr,Math.PI/2,Math.PI); 
      cx.lineTo(x,y+rr); 
      cx.arc(x+rr,y+rr,rr,Math.PI,1.5*Math.PI);
      cx.closePath(); 
      cx.stroke(); 
      cx.restore();
    }
  }

  // IK and limb drawing functions
  function solveLegIK(hipX,hipY,targetX,targetY,bendSign){
    const a=CONFIG.parts.leg.upper*CONFIG.actor.scale,b=CONFIG.parts.leg.lower*CONFIG.actor.scale;
    let dx=targetX-hipX, dy=targetY-hipY; 
    const dist=Math.hypot(dx,dy);
    const c=clamp(dist,1e-4,a+b-1e-4); 
    const base=Math.atan2(dx,-dy);
    const cosTheta=clamp((a*a+b*b-c*c)/(2*a*b),-1,1); 
    const theta=Math.acos(cosTheta);
    const cosAlpha=clamp((a*a+c*c-b*b)/(2*a*c),-1,1); 
    const alpha=Math.acos(cosAlpha);
    let hipAng=base + bendSign*alpha; 
    let kneeRel=bendSign*(Math.PI-theta);
    const L=CONFIG.limits; 
    hipAng=clamp(hipAng,deg2rad(L.hip.absMin),deg2rad(L.hip.absMax)); 
    kneeRel=clamp(kneeRel,deg2rad(L.knee.relMin),deg2rad(L.knee.relMax));
    return { hipAng, kneeRel };
  }

  function fkFoot(hipX,hipY,hipAng,kneeRel){
    let {upper,lower}=CONFIG.parts.leg; 
    upper*=CONFIG.actor.scale; 
    lower*=CONFIG.actor.scale; 
    const k=segPos(hipX,hipY,upper,hipAng); 
    const f=segPos(k[0],k[1],lower,hipAng+kneeRel); 
    return {kneeX:k[0],kneeY:k[1],footX:f[0],footY:f[1]};
  }

  function updateCalfRagdollFromState(side, hipAng){
    const key = side + 'KneeRel';
    const prevKneeRel = RAG[key];
    const stiff = CONFIG.ragdoll.stiffness;
    const grav = deg2rad(90);
    const kneeAng = hipAng + prevKneeRel;
    const target = grav - hipAng;
    const diff = angNorm(target - prevKneeRel);
    const k = 1 - Math.exp(-stiff * LAST_DT);
    const newKneeRel = prevKneeRel + diff * k;
    RAG[key] = newKneeRel;
    return newKneeRel;
  }

  function drawArm(x,y,shoulderRel,elbowRel,which,Q){
const scale = CONFIG.actor.scale; const {upper,lower} = CONFIG.parts.arm;
  // First apply any origin offset for the upper arm. This modifies x/y
  // before computing tag names and mirror state so the mirroring pivot is
  // correct for both skeleton and sprite drawing.
  [x,y] = withAX(x,y, shoulderRel, CONFIG.offsets && CONFIG.offsets.arm && CONFIG.offsets.arm.upper && CONFIG.offsets.arm.upper.origin);
  // Determine the tag names for this arm and whether mirroring is active.
  const tagU = which==='L' ? 'ARM_L_UPPER' : 'ARM_R_UPPER';
  const tagL = which==='L' ? 'ARM_L_LOWER' : 'ARM_R_LOWER';
  const __mirror = !!(MIRROR[tagU] || MIRROR[tagL]);
  // Helper to optionally flip drawing for this limb's skeleton and sprites.
  function __withLocalMirror(fn){
    if (!__mirror) return fn();
    cx.save();
    cx.translate(x, 0);
    cx.scale(-1, 1);
    cx.translate(-x, 0);
    try { return fn(); } finally { cx.restore(); }
  }
  // Draw the upper arm segment. We wrap the seg() call in the local mirror
  // context so the skeleton line mirrors along with the sprite when needed.
  let elbow;
  __withLocalMirror(() => {
    elbow = seg(x, y, upper*scale, shoulderRel);
  });
  // Apply the elbow offset on the upper arm outside of any mirror to compute
  // the world-space location of the elbow for downstream transforms.
  elbow = withAX(elbow[0], elbow[1], shoulderRel, CONFIG.offsets && CONFIG.offsets.arm && CONFIG.offsets.arm.upper && CONFIG.offsets.arm.upper.elbow);
  // Compute the forearm angle and the starting point for the lower arm.
  const foreAng = shoulderRel + elbowRel;
  let wristStart = withAX(elbow[0], elbow[1], foreAng, CONFIG.offsets && CONFIG.offsets.arm && CONFIG.offsets.arm.lower && CONFIG.offsets.arm.lower.origin);
  // Draw the lower arm segment inside the local mirror context so it mirrors
  // along with the sprite when required. We don't need the returned value.
  __withLocalMirror(() => {
    seg(wristStart[0], wristStart[1], lower*scale, foreAng);
  });
  const wf = (CONFIG.sprites && CONFIG.sprites.style && CONFIG.sprites.style.widthFactor) || {};

  if (Q){
    enqueue(Q, tagU, ()=> __withLocalMirror(()=> drawBoneSprite(x, y, (upper*scale), shoulderRel, 'armUpper', wf.armUpper||1)));
    enqueue(Q, tagL, ()=> __withLocalMirror(()=> drawBoneSprite(wristStart[0], wristStart[1], (lower*scale), foreAng, 'armLower', wf.armLower||1)));
  } else {
    __withLocalMirror(()=> drawBoneSprite(x, y, (upper*scale), shoulderRel, 'armUpper', wf.armUpper||1));
    __withLocalMirror(()=> drawBoneSprite(wristStart[0], wristStart[1], (lower*scale), foreAng, 'armLower', wf.armLower||1));
  }
}

  function drawLeg(x,y,hipAng,kneeRel,which,Q){
const scale = CONFIG.actor.scale; const {upper,lower} = CONFIG.parts.leg;
  // Apply any origin offset for the upper leg. This ensures that the
  // mirroring pivot is based on the correct starting position for both
  // skeleton and sprite drawing.
  [x,y] = withAX(x,y, hipAng, CONFIG.offsets && CONFIG.offsets.leg && CONFIG.offsets.leg.upper && CONFIG.offsets.leg.upper.origin);
  // Determine the tag names for this leg and whether mirroring is active.
  const tagU = which==='L' ? 'LEG_L_UPPER' : 'LEG_R_UPPER';
  const tagL = which==='L' ? 'LEG_L_LOWER' : 'LEG_R_LOWER';
  const __mirror = !!(MIRROR[tagU] || MIRROR[tagL]);
  // Helper to optionally flip drawing for this limb's skeleton and sprites.
  function __withLocalMirror(fn){
    if (!__mirror) return fn();
    cx.save();
    cx.translate(x, 0);
    cx.scale(-1, 1);
    cx.translate(-x, 0);
    try { return fn(); } finally { cx.restore(); }
  }
  // Draw the upper leg segment inside the mirror context if needed. Capture
  // the returned knee coordinate for downstream transforms.
  let knee;
  __withLocalMirror(() => {
    knee = seg(x, y, upper*scale, hipAng);
  });
  // Apply the knee offset outside of any mirror to compute the world-space
  // location of the knee for downstream transforms.
  knee = withAX(knee[0], knee[1], hipAng, CONFIG.offsets && CONFIG.offsets.leg && CONFIG.offsets.leg.upper && CONFIG.offsets.leg.upper.knee);
  const shinAng = hipAng + kneeRel;
  let ankleStart = withAX(knee[0], knee[1], shinAng, CONFIG.offsets && CONFIG.offsets.leg && CONFIG.offsets.leg.lower && CONFIG.offsets.leg.lower.origin);
  // Draw the lower leg segment inside the mirror context so the skeleton
  // line mirrors with the sprite when needed.
  __withLocalMirror(() => {
    seg(ankleStart[0], ankleStart[1], lower*scale, shinAng);
  });

  const wf = (CONFIG.sprites && CONFIG.sprites.style && CONFIG.sprites.style.widthFactor) || {};

  if (Q){
    enqueue(Q, tagU, ()=> __withLocalMirror(()=> drawBoneSprite(x, y, (upper*scale), hipAng, 'legUpper', wf.legUpper||1)));
    enqueue(Q, tagL, ()=> __withLocalMirror(()=> drawBoneSprite(ankleStart[0], ankleStart[1], (lower*scale), shinAng, 'legLower', wf.legLower||1)));
  } else {
    __withLocalMirror(()=> drawBoneSprite(x, y, (upper*scale), hipAng, 'legUpper', wf.legUpper||1));
    __withLocalMirror(()=> drawBoneSprite(ankleStart[0], ankleStart[1], (lower*scale), shinAng, 'legLower', wf.legLower||1));
  }
}

  function drawHead(x,y,torsoAng,Q){
    const scale = CONFIG.actor.scale; const {neck,radius} = CONFIG.parts.head;
    [x,y] = withAX(x,y, torsoAng, CONFIG.offsets && CONFIG.offsets.head && CONFIG.offsets.head.origin);
    const headC = segPos(x, y, neck*scale, torsoAng);
    if (!CONFIG.render || CONFIG.render.debugBones){
      cx.beginPath(); cx.arc(headC[0], headC[1], radius*scale, 0, TAU); cx.strokeStyle = CONFIG.colors.body; cx.stroke();
    }
    const wf = (CONFIG.sprites && CONFIG.sprites.style && CONFIG.sprites.style.widthFactor) || {};
    const headLen = (neck + radius*2) * scale;
    if (Q){ enqueue(Q, 'HEAD', ()=> drawBoneSprite(x, y, headLen, torsoAng, 'head', wf.head||1)); }
    else { drawBoneSprite(x, y, headLen, torsoAng, 'head', wf.head||1); }
  }

  function drawSkeleton(delta, hitCenter, ragdollState = null){
    let A = addAngles(CONFIG.basePose, delta);
    
    // Determine which ragdoll/recovery state to use (NPC or Player)
    const activeRagdoll = ragdollState || (MOVE.ragdoll ? MOVE : null);
    const activeRecovery = ragdollState ? (ragdollState.recovering ? ragdollState : null) : (MOVE.recovering ? MOVE : null);
    
    // RECOVERY MODE: Use lerped angles during transition back to stance
    if (activeRecovery && activeRecovery.recovering && activeRecovery.jointAngles) {
      A.torso = activeRecovery.jointAngles.torso || A.torso;
      A.lShoulder = activeRecovery.jointAngles.lShoulder || A.lShoulder;
      A.rShoulder = activeRecovery.jointAngles.rShoulder || A.rShoulder;
      A.lElbow = activeRecovery.jointAngles.lElbow || A.lElbow;
      A.rElbow = activeRecovery.jointAngles.rElbow || A.rElbow;
      A.lHip = activeRecovery.jointAngles.lHip || A.lHip;
      A.rHip = activeRecovery.jointAngles.rHip || A.rHip;
      A.lKnee = activeRecovery.jointAngles.lKnee || A.lKnee;
      A.rKnee = activeRecovery.jointAngles.rKnee || A.rKnee;
      // Clamp angles during recovery for smooth transition
      A = clampAngles(A);
    }
    // RAGDOLL MODE: Override all joint angles with physics-driven values
    else if (activeRagdoll && activeRagdoll.ragdoll && activeRagdoll.jointAngles) {
      // Completely override with ragdoll angles - all joints collapse independently
      A.torso = activeRagdoll.jointAngles.torso || A.torso;
      A.lShoulder = activeRagdoll.jointAngles.lShoulder || A.lShoulder;
      A.rShoulder = activeRagdoll.jointAngles.rShoulder || A.rShoulder;
      A.lElbow = activeRagdoll.jointAngles.lElbow || A.lElbow;
      A.rElbow = activeRagdoll.jointAngles.rElbow || A.rElbow;
      A.lHip = activeRagdoll.jointAngles.lHip || A.lHip;
      A.rHip = activeRagdoll.jointAngles.rHip || A.rHip;
      A.lKnee = activeRagdoll.jointAngles.lKnee || A.lKnee;
      A.rKnee = activeRagdoll.jointAngles.rKnee || A.rKnee;
      
      // Don't clamp angles in ragdoll - let them go completely wild!
    } else {
      A = clampAngles(A);
    }
    
    cx.save();
    const flipLeft = Math.cos(ragdollState ? ragdollState.facingRad : MOVE.facingRad) < 0;
    if (flipLeft){ 
      cx.translate(hitCenter.x*2, 0); 
      cx.scale(-1,1); 
    }
    cx.lineCap='round'; 
    cx.lineWidth=6;

    const Q = [];

    enqueue(Q, 'HITBOX', ()=> drawHitbox(hitCenter.x, hitCenter.y, CONFIG.parts.hitbox.w, CONFIG.parts.hitbox.h, CONFIG.parts.hitbox.r));

    const hb=CONFIG.parts.hitbox;
    const torsoAttach={ 
      x: hitCenter.x + (hb.torsoAttach.nx-0.5)*hb.w*CONFIG.actor.scale,
      y: hitCenter.y + (hb.torsoAttach.ny-0.5)*hb.h*CONFIG.actor.scale 
    };
    const torsoLen=CONFIG.parts.torso.len * CONFIG.actor.scale, torsoAng=deg2rad(A.torso);

    const base = withAX(torsoAttach.x, torsoAttach.y, torsoAng, CONFIG.offsets && CONFIG.offsets.torso && CONFIG.offsets.torso.origin);
    cx.strokeStyle=CONFIG.colors.body;
    const torsoTop = seg(base[0], base[1], torsoLen, torsoAng);

    const wf = (CONFIG.sprites && CONFIG.sprites.style && CONFIG.sprites.style.widthFactor) || {};
    enqueue(Q, 'TORSO', ()=> drawBoneSprite(base[0], base[1], torsoLen, torsoAng, 'torso', wf.torso||1));

    const neckBase = withAX(torsoTop[0], torsoTop[1], torsoAng, CONFIG.offsets && CONFIG.offsets.torso && CONFIG.offsets.torso.neck);
    drawHead(neckBase[0], neckBase[1], torsoAng, Q);

    const shoulderBase = withAX(torsoTop[0], torsoTop[1], torsoAng, CONFIG.offsets && CONFIG.offsets.torso && CONFIG.offsets.torso.shoulder);
    cx.strokeStyle=CONFIG.colors.left;  
    drawArm(shoulderBase[0], shoulderBase[1], torsoAng + deg2rad(A.lShoulder - A.torso), deg2rad(A.lElbow), 'L', Q);
    cx.strokeStyle=CONFIG.colors.right; 
    drawArm(shoulderBase[0], shoulderBase[1], torsoAng + deg2rad(A.rShoulder - A.torso), deg2rad(A.rElbow), 'R', Q);

    const hipBase = withAX(base[0], base[1], torsoAng, CONFIG.offsets && CONFIG.offsets.torso && CONFIG.offsets.torso.hip);

    let lHipAng = deg2rad(A.lHip), lKneeRel = deg2rad(A.lKnee);
    let lCalfRD = RAG.active && RAG.lCalfRagdoll && !activeRagdoll && !activeRecovery; // Disable partial ragdoll in full ragdoll or recovery
    if (lCalfRD){ 
      lKneeRel = updateCalfRagdollFromState('L', lHipAng); 
    } else { 
      RAG.lKneeRel = lKneeRel; 
    }
    // Don't clamp in full ragdoll mode, but do clamp during recovery
    if (!activeRagdoll || activeRecovery) {
      lHipAng=clamp(lHipAng,deg2rad(CONFIG.limits.hip.absMin),deg2rad(CONFIG.limits.hip.absMax));
      lKneeRel=clamp(lKneeRel,deg2rad(CONFIG.limits.knee.relMin),deg2rad(CONFIG.limits.knee.relMax));
    }
    cx.strokeStyle=CONFIG.colors.left;  
    drawLeg(hipBase[0], hipBase[1], lHipAng, lKneeRel, 'L', Q);

    let rHipAng = deg2rad(A.rHip), rKneeRel = deg2rad(A.rKnee);
    let rCalfRD = RAG.active && RAG.rCalfRagdoll && !activeRagdoll && !activeRecovery; // Disable partial ragdoll in full ragdoll or recovery
    if (rCalfRD){ 
      rKneeRel = updateCalfRagdollFromState('R', rHipAng); 
    } else { 
      RAG.rKneeRel = rKneeRel; 
    }
    // Don't clamp in full ragdoll mode, but do clamp during recovery
    if (!activeRagdoll || activeRecovery) {
      rHipAng=clamp(rHipAng,deg2rad(CONFIG.limits.hip.absMin),deg2rad(CONFIG.limits.hip.absMax));
      rKneeRel=clamp(rKneeRel,deg2rad(CONFIG.limits.knee.relMin),deg2rad(CONFIG.limits.knee.relMax));
    }
    cx.strokeStyle=CONFIG.colors.right; 
    drawLeg(hipBase[0], hipBase[1], rHipAng, rKneeRel, 'R', Q);

    // Compute attack collider positions for hands and feet. Positions are
    // calculated in world space prior to sorting/drawing queue so that the
    // render() function can draw simple circles after the skeleton is
    // rendered. We mirror the computations from drawArm() and drawLeg().
    try {
      // Cache the hit center for later flip adjustments
      COLLIDERS_POS.hitCenter.x = hitCenter.x;
      COLLIDERS_POS.hitCenter.y = hitCenter.y;
      // Left hand position
      const lShoulderRel = torsoAng + deg2rad(A.lShoulder - A.torso);
      const lElbowRel    = deg2rad(A.lElbow);
      let lh = computeArmEnd(shoulderBase[0], shoulderBase[1], lShoulderRel, lElbowRel);
      // Right hand position
      const rShoulderRel = torsoAng + deg2rad(A.rShoulder - A.torso);
      const rElbowRel    = deg2rad(A.rElbow);
      let rh = computeArmEnd(shoulderBase[0], shoulderBase[1], rShoulderRel, rElbowRel);
      // Left foot position
      let lf = computeFootEnd(hipBase[0], hipBase[1], lHipAng, lKneeRel);
      // Right foot position
      let rf = computeFootEnd(hipBase[0], hipBase[1], rHipAng, rKneeRel);
      // Apply horizontal flip if the character is facing left. This mirrors
      // about the hitCenter.x so collider positions align with the flipped
      // skeleton. Without this the colliders would remain on the wrong side.
      if (flipLeft){
        const cx2 = hitCenter.x * 2;
        lh.x = cx2 - lh.x;
        rh.x = cx2 - rh.x;
        lf.x = cx2 - lf.x;
        rf.x = cx2 - rf.x;
      }
      // If specific limbs are mirrored via flipParts (e.g. in Kick Strike),
      // adjust the collider positions so they match the mirrored sprite. We
      // mirror only the relevant limb about the hitCenter.x axis when the
      // FLIP_STATE indicates that the right arm or leg has been flipped.
      const mirrorX = hitCenter.x;
      if (FLIP_STATE['ARM_R_UPPER'] || FLIP_STATE['ARM_R_LOWER']){
        rh.x = 2 * mirrorX - rh.x;
      }
      if (FLIP_STATE['LEG_R_UPPER'] || FLIP_STATE['LEG_R_LOWER']){
        rf.x = 2 * mirrorX - rf.x;
      }
      COLLIDERS_POS.handL = lh;
      COLLIDERS_POS.handR = rh;
      COLLIDERS_POS.footL = lf;
      COLLIDERS_POS.footR = rf;
      
      // Lunge anticipation collider - projects forward from character
      const facingDir = Math.cos(MOVE.facingRad);  // 1 for right, -1 for left
      const lungeDistance = 80;  // Distance in front of character
      COLLIDERS_POS.lunge = {
        x: hitCenter.x + facingDir * lungeDistance,
        y: hitCenter.y
      };
    } catch(e){
      // In case of any error, fall back to null positions to avoid
      // blocking rendering
      COLLIDERS_POS.handL = COLLIDERS_POS.handR = COLLIDERS_POS.footL = COLLIDERS_POS.footR = COLLIDERS_POS.lunge = null;
    }

    Q.sort((a,b)=> a.z - b.z);
    for (const d of Q){ 
      RENDER_CTX.tag = d.tag; 
      d.fn(); 
    }
    RENDER_CTX.tag = null;
    cx.restore();
  }

  // ====== Responsive canvas ======
  function resizeCanvas(){
    const stage = document.getElementById('gameStage');
    const rect = stage.getBoundingClientRect();
    // Canvas matches display size (for proper scaling)
    cv.width = Math.floor(rect.width);
    cv.height = Math.floor(rect.height);
    CONFIG.canvas.w = cv.width; 
    CONFIG.canvas.h = cv.height;
    CONFIG.groundY = Math.round(cv.height * CONFIG.groundRatio);
    
    const hb = CONFIG.parts.hitbox;
    const baseY = CONFIG.groundY - (hb.h * CONFIG.actor.scale) / 2;

    // Position player in WORLD coordinates (center of 1600px world)
    MOVE.pos.x = WORLD_WIDTH / 2;
    MOVE.pos.y = baseY;

    // Position wanderer NPCs in WORLD coordinates
    const defaultRatios = [0.65, 0.45];
    NPCS.forEach((npc, index) => {
      ensureWandererState(npc, index);
      const ratio = (defaultRatios[index] !== undefined) ? defaultRatios[index] : 0.55;
      npc.pos.x = WORLD_WIDTH * ratio;
      npc.pos.y = baseY;
    });

    // Initialize camera to center on player
    CAMERA.x = MOVE.pos.x - cv.width / 2;
  }

  function computeWandererPhysicsOffsets(npc) {
    const o = {};
    o.torso = clamp((npc && npc.vel ? npc.vel.x : 0) * 0.04, -25, 25);
    o.lKnee = 0;
    o.rKnee = 0;
    o.lHip = 0;
    o.rHip = 0;
    return o;
  }

  function computeWandererWalkOffsets(npc, dt) {
    const W = CONFIG.walk;
    const out = {};
    if (!npc || !npc.walk || !W || !W.enabled) return out;

    const pureStance = true;
    const speed = Math.abs(npc.vel.x || 0);
    const hasWalk = speed > 0.1;
    const active = pureStance && npc.onGround && speed > W.minSpeed && hasWalk;

    const k = 1 - Math.exp(-8 * dt);
    const targetAmp = active ? 1 : 0;
    npc.walk.amp += (targetAmp - npc.walk.amp) * k;
    if (npc.walk.amp < 1e-3) return out;

    const speedNorm = clamp(speed / CONFIG.movement.maxSpeedX, 0, 1);
    const hz = W.baseHz * (0.6 + 0.8 * speedNorm) * W.speedScale;
    npc.walk.phase = (npc.walk.phase + hz * dt * TAU) % TAU;
    const t = (Math.sin(npc.walk.phase) + 1) / 2;

    const A = W.poses.A || {};
    const B = W.poses.B || {};
    const S = CONFIG.poses.Stance || {};
    const walkPose = {
      torso: lerp(A.torso || 0, B.torso || 0, t),
      lHip:  lerp(A.lHip  || 0, B.lHip  || 0, t),
      lKnee: lerp(A.lKnee || 0, B.lKnee || 0, t),
      rHip:  lerp(A.rHip  || 0, B.rHip  || 0, t),
      rKnee: lerp(A.rKnee || 0, B.rKnee || 0, t)
    };

    out.torso = lerp(S.torso || 0, walkPose.torso, npc.walk.amp);
    out.lHip  = lerp(S.lHip  || 0, walkPose.lHip , npc.walk.amp);
    out.lKnee = lerp(S.lKnee || 0, walkPose.lKnee, npc.walk.amp);
    out.rHip  = lerp(S.rHip  || 0, walkPose.rHip , npc.walk.amp);
    out.rKnee = lerp(S.rKnee || 0, walkPose.rKnee, npc.walk.amp);
    out.__overwrite = pureStance;
    return out;
  }

  function computeWandererOffsets(npc, dt) {
    let final = clone(CONFIG.poses.Stance || {});
    const phys = computeWandererPhysicsOffsets(npc);
    final = addOffsets(final, scaleOffsets(phys, CONFIG.movement.physicsWeight));
    const walk = computeWandererWalkOffsets(npc, dt);
    if (walk.__overwrite) {
      for (const key of ['torso', 'lHip', 'lKnee', 'rHip', 'rKnee']) {
        if (Object.prototype.hasOwnProperty.call(walk, key)) {
          final[key] = walk[key];
        }
      }
    } else {
      final = addOffsets(final, walk);
    }
    return final;
  }

  function drawWanderers(dt, playerCollidersSnapshot) {
    if (!NPC_ENABLED) return;

    const savedMirror = {};
    for (const key in MIRROR) {
      savedMirror[key] = MIRROR[key];
    }
    const savedFlip = {};
    for (const key in FLIP_STATE) {
      savedFlip[key] = FLIP_STATE[key];
    }
    const savedMove = { x: MOVE.pos.x, y: MOVE.pos.y, facing: MOVE.facingRad };

    NPCS.forEach((npc, index) => {
      ensureWandererState(npc, index);
      const hitCenter = { x: npc.pos.x, y: npc.pos.y };
      const offsets = computeWandererOffsets(npc, dt);

      MOVE.pos.x = npc.pos.x;
      MOVE.pos.y = npc.pos.y;
      MOVE.facingRad = npc.facingRad;

      for (const key in MIRROR) { delete MIRROR[key]; }
      initFlipStateFromMirror();
      drawSkeleton(offsets, hitCenter, npc);
    });

    for (const key in MIRROR) { delete MIRROR[key]; }
    for (const key in savedMirror) { MIRROR[key] = savedMirror[key]; }
    for (const key in FLIP_STATE) { delete FLIP_STATE[key]; }
    for (const key in savedFlip) { FLIP_STATE[key] = savedFlip[key]; }

    MOVE.pos.x = savedMove.x;
    MOVE.pos.y = savedMove.y;
    MOVE.facingRad = savedMove.facing;

    if (playerCollidersSnapshot) {
      COLLIDERS_POS.hitCenter.x = playerCollidersSnapshot.hitCenter.x;
      COLLIDERS_POS.hitCenter.y = playerCollidersSnapshot.hitCenter.y;
      COLLIDERS_POS.handL = playerCollidersSnapshot.handL;
      COLLIDERS_POS.handR = playerCollidersSnapshot.handR;
      COLLIDERS_POS.footL = playerCollidersSnapshot.footL;
      COLLIDERS_POS.footR = playerCollidersSnapshot.footR;
    }
  }

  function updateWanderers(dt) {
    NPCS.forEach((npc, index) => {
      ensureWandererState(npc, index);
      if (!npc || !npc.wander) return;

      npc.wander.timer -= dt;
      if (npc.wander.timer <= 0) {
        pickNextWanderState(npc);
      }

      const bounds = getWanderBounds(npc);
      const baseY = CONFIG.groundY - (CONFIG.parts.hitbox.h * CONFIG.actor.scale) / 2;
      const speed = npc.wander.speed;
      let direction = npc.wander.direction;
      let desiredVel = direction === 0 ? 0 : direction * speed;

      npc.pos.x += desiredVel * dt;

      if (npc.pos.x <= bounds.min) {
        npc.pos.x = bounds.min;
        npc.wander.direction = 1;
        npc.wander.lastDirection = 1;
        npc.wander.timer = randomRange(1.5, 3.5);
      } else if (npc.pos.x >= bounds.max) {
        npc.pos.x = bounds.max;
        npc.wander.direction = -1;
        npc.wander.lastDirection = -1;
        npc.wander.timer = randomRange(1.5, 3.5);
      }

      direction = npc.wander.direction;
      desiredVel = direction === 0 ? 0 : direction * speed;

      npc.vel.x = desiredVel;
      npc.vel.y = 0;
      npc.pos.y = baseY;
      npc.onGround = true;
      npc.ragdoll = false;
      npc.recovering = false;
      npc.landedImpulse = 0;
      if (npc.stamina) {
        npc.stamina.isDashing = false;
        npc.stamina.current = npc.stamina.max;
      }

      const maxFooting = CONFIG.knockback && CONFIG.knockback.maxFooting ? CONFIG.knockback.maxFooting : 100;
      npc.footing = Math.min(maxFooting, npc.footing || maxFooting);

      if (direction !== 0) {
        npc.wander.lastDirection = direction;
      }
      const facingDir = npc.wander.lastDirection || 1;
      npc.facingRad = facingDir >= 0 ? 0 : Math.PI;
    });
  }

  // ====== NPC AI ======
  /**
   * Update the NPC's position and facing direction based on a simple AI.
   * The NPC will walk toward the player until within a small threshold,
   * then stand still. It uses a reduced movement speed relative to the
   * player's max speed and faces toward the player at all times.
   *
   * @param {number} dt Delta time in seconds since the last update
   */
  function updateNpc(dt){
    // Defensive defaults in case fields were unset or NaN
    if (!NPC_STATE.mode) NPC_STATE.mode = 'approach';
    if (!Number.isFinite(NPC_STATE.cooldown)) NPC_STATE.cooldown = 0;

    // ====== USE UNIVERSAL PHYSICS SYSTEM (same as player!) ======
    updateFighterPhysics(NPC_STATE, dt);
    
    // Skip AI if in ragdoll or recovering - physics handled above
    if (NPC_STATE.ragdoll || NPC_STATE.recovering) {
      return;
    }
    
    // ====== NORMAL NPC AI (physics already complete) ======
    const M = CONFIG.movement;
    
    // Update NPC lunge mechanic - applies movement during Strike phase
    if (NPC_STATE.attack.lunge.active && !NPC_STATE.attack.lunge.paused) {
      // Apply lunge movement
      NPC_STATE.pos.x += NPC_STATE.attack.lunge.lungeVel.x * dt;
      NPC_STATE.pos.y += NPC_STATE.attack.lunge.lungeVel.y * dt;
      NPC_STATE.attack.lunge.distance += Math.abs(NPC_STATE.attack.lunge.lungeVel.x) * dt;
      
      // Stop lunge after target distance or when leaving Strike phase
      if (NPC_STATE.attack.lunge.distance >= NPC_STATE.attack.lunge.targetDistance || NPC_STATE.attack.currentPhase !== 'Strike') {
        NPC_STATE.attack.lunge.active = false;
        NPC_STATE.attack.lunge.distance = 0;
      }
    }
    
    // Update the NPC's attack state each frame and handle cooldown between attacks
    updateNpcAttack(dt);
    // Always decrement the cooldown timer
    NPC_STATE.cooldown = Math.max(0, NPC_STATE.cooldown - dt);
    // Horizontal distance between player and NPC
    const dx = MOVE.pos.x - NPC_STATE.pos.x;
    const maxSpeed = CONFIG.movement.maxSpeedX * 0.8; // Faster NPC (was 0.5)
    const nearDist = 70; // Much closer attack range (was 140)
    // If an attack is active, the NPC does not move but maintains facing
    if (NPC_STATE.attack && NPC_STATE.attack.active){
      NPC_STATE.vel.x = 0;
      NPC_STATE.facingRad = (dx >= 0 ? 0 : Math.PI);
      return;
    }
    // If we were in attack mode and the attack just finished, switch to evade briefly
    // BUT NOT if we're in the middle of a combo!
    if (NPC_STATE.mode === 'attack' && !NPC_STATE.combo.active){
      NPC_STATE.mode = 'evade';
      NPC_STATE.timer = 0.3; // Very short evade (was 1.0)
      NPC_STATE.vel.x = -(dx > 0 ? 1 : -1) * maxSpeed;
      // Apply a short cooldown before the next attack
      NPC_STATE.cooldown = 0.4; // Much shorter cooldown (was 1.5)
    }
    // Decide whether to start a new attack when close enough and cooldown expired
    if (Math.abs(dx) <= nearDist && NPC_STATE.cooldown <= 0){
      // Always do a full combo sequence (all 4 attacks + 1 final attack)
      NPC_STATE.combo.active = true;
      NPC_STATE.combo.sequenceIndex = 0;
      NPC_STATE.combo.attackDelay = 0;
      // First attack starts immediately
      const preset = CONFIG.combo.sequence[0];
      startNpcQuickAttack(preset);
      
      NPC_STATE.mode = 'attack';
      NPC_STATE.vel.x = 0;
      NPC_STATE.facingRad = (dx >= 0 ? 0 : Math.PI);
      return;
    }
    // Normal movement: approach or evade based on mode
    if (NPC_STATE.mode === 'approach'){
      // Move toward the player until within attack range
      if (Math.abs(dx) > nearDist){
        NPC_STATE.vel.x = (dx > 0 ? 1 : -1) * maxSpeed;
        NPC_STATE.stamina.isDashing = false; // Not dashing when approaching
      } else {
        // Don't automatically switch to evade - just keep approaching
        // This makes NPC stay in attack range
        NPC_STATE.vel.x = (dx > 0 ? 1 : -1) * maxSpeed * 0.3; // Slow approach when close
        NPC_STATE.stamina.isDashing = false;
      }
    } else if (NPC_STATE.mode === 'evade'){
      // Move away from the player briefly - USE DASH when backing up!
      const dashMult = (NPC_STATE.stamina.current >= NPC_STATE.stamina.minToDash) 
        ? CONFIG.movement.dashSpeedMultiplier 
        : 1.0;
      NPC_STATE.vel.x = -(dx > 0 ? 1 : -1) * maxSpeed * dashMult;
      NPC_STATE.stamina.isDashing = (dashMult > 1.0);
      
      NPC_STATE.timer -= dt;
      if (NPC_STATE.timer <= 0){
        NPC_STATE.mode = 'approach';
        NPC_STATE.stamina.isDashing = false;
      }
    }
    
    // Update NPC stamina and trail
    if (NPC_STATE.stamina.isDashing && NPC_STATE.stamina.current > 0) {
      NPC_STATE.stamina.current = Math.max(0, NPC_STATE.stamina.current - NPC_STATE.stamina.drainRate * dt);
      
      // Capture NPC trail when dashing
      if (NPC_DASH_TRAIL.enabled) {
        NPC_DASH_TRAIL.timer += dt;
        if (NPC_DASH_TRAIL.timer >= NPC_DASH_TRAIL.interval) {
          NPC_DASH_TRAIL.timer = 0;
          NPC_DASH_TRAIL.positions.unshift({
            x: NPC_STATE.pos.x,
            y: NPC_STATE.pos.y,
            facingRad: NPC_STATE.facingRad,
            alpha: 1.0
          });
          if (NPC_DASH_TRAIL.positions.length > NPC_DASH_TRAIL.maxLength) {
            NPC_DASH_TRAIL.positions.length = NPC_DASH_TRAIL.maxLength;
          }
        }
      }
    } else {
      NPC_STATE.stamina.isDashing = false;
      NPC_STATE.stamina.current = Math.min(NPC_STATE.stamina.max, NPC_STATE.stamina.current + NPC_STATE.stamina.regenRate * dt);
    }
    
    // Fade out NPC trail positions
    for (let i = 0; i < NPC_DASH_TRAIL.positions.length; i++) {
      NPC_DASH_TRAIL.positions[i].alpha -= dt * 3;
    }
    NPC_DASH_TRAIL.positions = NPC_DASH_TRAIL.positions.filter(t => t.alpha > 0);
    
    // Update position and constrain within bounds
    NPC_STATE.pos.x += NPC_STATE.vel.x * dt;
    const margin = 40;
    const minX = margin;
    const maxX = WORLD_WIDTH - margin;
    NPC_STATE.pos.x = clamp(NPC_STATE.pos.x, minX, maxX);
    // Always face toward the player
    NPC_STATE.facingRad = (dx >= 0 ? 0 : Math.PI);
  }

  // ====== NPC animation offsets ======
  /**
   * Compute torso and leg offsets for the NPC based on its current velocity.
   * The NPC does not crouch or jump, so only a small lean proportional to
   * horizontal speed is applied. This mirrors computePhysicsOffsets() but
   * uses NPC_STATE instead of MOVE.
   *
   * @param {number} dt Delta time in seconds
   * @returns {Object} offset values keyed by limb name
   */
  function computeNpcPhysicsOffsets(dt){
    const o = {};
    // Lean the torso in the direction of movement
    o.torso = clamp(NPC_STATE.vel.x * 0.04, -25, 25);
    // Leave knees and hips at rest (no crouch)
    o.lKnee = 0;
    o.rKnee = 0;
    o.lHip = 0;
    o.rHip = 0;
    return o;
  }

  /**
   * Compute walk-cycle offsets for the NPC. This uses an internal NPC_WALK
   * object to track amplitude and phase, similar to the global WALK for the
   * player. The NPC must be moving on the ground to animate the walk.
   *
   * @param {Object} baseOffsets Offsets to blend with (unused but kept for API symmetry)
   * @param {number} dt Delta time in seconds
   * @returns {Object} offset values keyed by limb name. Includes an
   * '__overwrite' flag to signal when to replace the base offsets.
   */
  function computeNpcWalkOffsets(baseOffsets, dt){
    const W = CONFIG.walk;
    const out = {};
    // If walk layer disabled, no offsets
    if (!W || !W.enabled) return out;
    // NPC is considered in pure stance all the time
    const pureStance = true;
    // Determine if walk cycle is active: NPC must be on ground and moving horizontally
    const speed = Math.abs(NPC_STATE.vel.x);
    const hasWalk = speed > 0.1;
    const active = pureStance && NPC_STATE.onGround && speed > W.minSpeed && hasWalk;
    // Smoothly interpolate walk amplitude
    const k = 1 - Math.exp(-8 * dt);
    const targetAmp = active ? 1 : 0;
    NPC_WALK.amp += (targetAmp - NPC_WALK.amp) * k;
    if (NPC_WALK.amp < 1e-3) return out;
    // Update phase based on normalized speed
    const speedNorm = clamp(speed / CONFIG.movement.maxSpeedX, 0, 1);
    const hz = W.baseHz * (0.6 + 0.8 * speedNorm) * W.speedScale;
    NPC_WALK.phase = (NPC_WALK.phase + hz * dt * TAU) % TAU;
    const t = (Math.sin(NPC_WALK.phase) + 1) / 2;
    // Interpolate between walk poses A and B
    const A = W.poses.A;
    const B = W.poses.B;
    const S = CONFIG.poses.Stance;
    const WalkPose = {
      torso: lerp(A.torso || 0, B.torso || 0, t),
      lHip:  lerp(A.lHip  || 0, B.lHip  || 0, t),
      lKnee: lerp(A.lKnee || 0, B.lKnee || 0, t),
      rHip:  lerp(A.rHip  || 0, B.rHip  || 0, t),
      rKnee: lerp(A.rKnee || 0, B.rKnee || 0, t)
    };
    // Blend from stance to walk pose using current amplitude
    out.torso = lerp(S.torso || 0, WalkPose.torso, NPC_WALK.amp);
    out.lHip  = lerp(S.lHip  || 0, WalkPose.lHip , NPC_WALK.amp);
    out.lKnee = lerp(S.lKnee || 0, WalkPose.lKnee, NPC_WALK.amp);
    out.rHip  = lerp(S.rHip  || 0, WalkPose.rHip , NPC_WALK.amp);
    out.rKnee = lerp(S.rKnee || 0, WalkPose.rKnee, NPC_WALK.amp);
    // Overwrite base stance offsets when in pure stance to avoid double blending
    out.__overwrite = pureStance;
    return out;
  }

  /**
   * Compute the final animation offsets for the NPC by combining the stance
   * pose with NPC-specific physics and walk offsets. The offsets are scaled
   * by the same physics weight as the player. Walk offsets will overwrite
   * the base stance offsets when '__overwrite' is set on the result.
   *
   * @param {number} dt Delta time in seconds
   * @returns {Object} object with limb offsets to pass to drawSkeleton()
   */
  function computeNpcOffsets(dt){
    // Update NPC aiming system
    updateNpcAiming(dt);
    
    // If the NPC is executing an attack, compute offsets based on the
    // current phase of the attack sequence. This mirrors how the player
    // transitions between Windup ‚Üí Strike ‚Üí Recoil ‚Üí Stance by lerping
    // between poses. We avoid modifying the global CONFIG.poses by using
    // poses defined on the preset itself.
    if (NPC_STATE.attack && NPC_STATE.attack.active){
      const atk = NPC_STATE.attack;
      const presetName = atk.preset;
      const preset = (CONFIG.presets && CONFIG.presets[presetName]) || {};
      const poses = preset.poses || CONFIG.poses || {};
      const seq   = atk.sequence || [];
      const idx   = atk.phaseIndex || 0;
      // Determine the target pose for this phase and the starting pose.
      const toPoseName = seq[idx] || 'Stance';
      const fromPoseName = (idx === 0) ? 'Stance' : (seq[idx-1] || 'Stance');
      const fromOffsets = clone((poses[fromPoseName] || {}));
      const toOffsets   = clone((poses[toPoseName]   || {}));
      const dur  = atk.durations[idx] || 0.001;
      const k    = Math.max(0, Math.min(1, atk.timer / dur));
      const eased = easeInOutCubic(k);
      // Interpolate between the from and to offsets. Use mix() defined
      // globally, which blends individual joint angles based on CONFIG.basePose.
      let final = mix(fromOffsets, toOffsets, eased);
      // Apply aiming to NPC attack pose
      final = applyAimingOffsets(final, NPC_STATE.aim);
      return final;
    }
    // Otherwise, the NPC is idle or walking: compute stance plus lean and
    // walk offsets. Start from stance pose and blend in physics and walk.
    let final = clone(CONFIG.poses.Stance);
    // Physics offsets: small lean when moving
    const phys = computeNpcPhysicsOffsets(dt);
    final = addOffsets(final, scaleOffsets(phys, CONFIG.movement.physicsWeight));
    // Walk offsets: based on NPC velocity
    const walk = computeNpcWalkOffsets(final, dt);
    if (walk.__overwrite){
      // Overwrite stance offsets for torso and legs
      for (const k of ['torso','lHip','lKnee','rHip','rKnee']){
        if (k in walk) final[k] = walk[k];
      }
    } else {
      final = addOffsets(final, walk);
    }
    // Apply aiming to NPC stance/walk pose
    final = applyAimingOffsets(final, NPC_STATE.aim);
    return final;
  }

  // Ensure the NPC is considered on the ground at all times (no jumping)
  NPC_STATE.onGround = true;

  /**
   * Determine which colliders should be active for a given attack preset.
   * Kicks use both feet, punches use both hands, and slams use hands and
   * feet. Unknown presets activate nothing.
   *
   * @param {string} preset Name of the attack preset
   * @returns {string[]} Array of collider keys to activate
   */
  function getPresetActiveColliders(preset){
    if (!preset) return [];
    const name = preset.toUpperCase();
    if (name.startsWith('KICK')) return ['footL','footR'];
    if (name.startsWith('PUNCH')) return ['handL','handR'];
    if (name.startsWith('SLAM')) return ['handL','handR','footL','footR'];
    return [];
  }

  /**
   * Begin a quick attack for the NPC using the specified preset. The attack
   * consists of Windup, Strike, Recoil and Stance phases. Durations are
   * derived from the preset's configuration and converted to seconds.
   * If the preset defines a custom sequence (like KICK_ALT), use that instead.
   *
   * @param {string} presetName Name of the preset to use (e.g. 'KICK', 'KICK_ALT')
   */
  function startNpcQuickAttack(presetName){
    const preset = CONFIG.presets && CONFIG.presets[presetName];
    
    // Check if this preset has a custom sequence (like KICK_ALT)
    if (preset && preset.sequence){
      // Use the custom sequence
      const seq = preset.sequence.map(step => Object.assign({}, step));
      
      // Build attack state from the sequence
      NPC_STATE.attack.active = true;
      NPC_STATE.attack.preset = presetName;
      NPC_STATE.attack.sequence = [];
      NPC_STATE.attack.durations = [];
      NPC_STATE.attack.phaseIndex = 0;
      NPC_STATE.attack.timer = 0;
      NPC_STATE.attack.currentActiveKeys = [];
      NPC_STATE.attack.isHoldRelease = false;
      NPC_STATE.attack.holdWindupDuration = 0;
      NPC_STATE.attack.currentPhase = null;
      NPC_STATE.attack.strikeLanded = false;
      
      // Convert sequence steps to phases and durations
      for (const step of seq) {
        NPC_STATE.attack.sequence.push(step.pose);
        // Get duration either from durMs or durKey
        let durMs = 0;
        if (typeof step.durMs === 'number') {
          durMs = step.durMs;
        } else if (step.durKey) {
          const durs = preset.durations || CONFIG.durations || {};
          durMs = durs[step.durKey] || 0;
        }
        NPC_STATE.attack.durations.push(durMs / 1000); // Convert to seconds
      }
    } else {
      // Standard attack sequence
      const durs = getPresetDurations(presetName) || {};
      const w = durs.toWindup || 0;
      const s = durs.toStrike || 0;
      const r = durs.toRecoil || 0;
      const st = durs.toStance || 0;
      NPC_STATE.attack.active = true;
      NPC_STATE.attack.preset = presetName;
      NPC_STATE.attack.sequence = ['Windup','Strike','Recoil','Stance'];
      NPC_STATE.attack.durations = [w, s, r, st].map(ms => ms / 1000);
      NPC_STATE.attack.phaseIndex = 0;
      NPC_STATE.attack.timer = 0;
      NPC_STATE.attack.currentActiveKeys = [];
      NPC_STATE.attack.isHoldRelease = false;
      NPC_STATE.attack.holdWindupDuration = 0;
      NPC_STATE.attack.currentPhase = null;
      NPC_STATE.attack.strikeLanded = false;
    }
  }
  
  /**
   * Start a hold-release attack for the NPC (like SLAM with windup time)
   * @param {string} presetName - The attack preset (e.g., 'SLAM')
   * @param {number} windupMs - How long to "hold" the windup in milliseconds
   */
  function startNpcHoldReleaseAttack(presetName, windupMs){
    const durs = getPresetDurations(presetName) || {};
    const w = windupMs || 1000; // Use specified windup duration
    const s = durs.toStrike || 0;
    const r = durs.toRecoil || 0;
    const st = durs.toStance || 0;
    NPC_STATE.attack.active = true;
    NPC_STATE.attack.preset = presetName;
    NPC_STATE.attack.sequence = ['Windup','Strike','Recoil','Stance'];
    NPC_STATE.attack.durations = [w / 1000, s / 1000, r / 1000, st / 1000];
    NPC_STATE.attack.phaseIndex = 0;
    NPC_STATE.attack.timer = 0;
    NPC_STATE.attack.currentActiveKeys = [];
    NPC_STATE.attack.isHoldRelease = true;
    NPC_STATE.attack.holdWindupDuration = windupMs;
  }

  /**
   * Update the NPC's attack state. Progress through the phases based on
   * elapsed time and activate colliders during the Strike phase. Once all
   * phases complete, the attack becomes inactive and the NPC can resume
   * other actions.
   *
   * @param {number} dt Delta time in seconds
   */
  function updateNpcAttack(dt){
    // Update combo delay timer
    if (NPC_STATE.combo.active && !NPC_STATE.attack.active) {
      NPC_STATE.combo.attackDelay -= dt;
      if (NPC_STATE.combo.attackDelay <= 0) {
        // Continue combo with next attack
        NPC_STATE.combo.sequenceIndex++;
        
        if (NPC_STATE.combo.sequenceIndex < 4) {
          // Continue the combo sequence
          const preset = CONFIG.combo.sequence[NPC_STATE.combo.sequenceIndex];
          startNpcQuickAttack(preset);
          NPC_STATE.combo.attackDelay = 0.15; // Short delay between combo hits
        } else if (NPC_STATE.combo.sequenceIndex === 4) {
          // Combo complete! Do one more attack to trigger alternate
          // Since COMBO.hits should be >= 4 now, this will use alternate sequence
          const idx = 0; // Use first alternate attack
          const preset = CONFIG.combo.altSequence[idx] || CONFIG.combo.sequence[idx];
          startNpcQuickAttack(preset);
          NPC_STATE.combo.attackDelay = 0.15;
          NPC_STATE.combo.sequenceIndex++; // Move to 5 to end combo next
        } else {
          // Fully complete after 5th attack
          NPC_STATE.combo.active = false;
          NPC_STATE.combo.sequenceIndex = 0;
        }
      }
    }
    
    if (!NPC_STATE.attack.active) return;
    const attack = NPC_STATE.attack;
    attack.timer += dt;
    while (attack.phaseIndex < attack.durations.length && attack.timer >= attack.durations[attack.phaseIndex]){
      attack.timer -= attack.durations[attack.phaseIndex];
      
      // Check for phase transitions - capture old phase before incrementing
      const oldPhase = attack.sequence[attack.phaseIndex];
      attack.phaseIndex++;
      
      if (attack.phaseIndex >= attack.durations.length){
        attack.active = false;
        attack.currentActiveKeys = [];
        attack.currentPhase = null;
        
        // Set delay before next combo attack
        if (NPC_STATE.combo.active) {
          NPC_STATE.combo.attackDelay = 0.15;
        }
        return;
      }
      
      // Detect phase changes and handle strike tracking
      const newPhase = attack.sequence[attack.phaseIndex];
      if (newPhase === 'Strike' && oldPhase !== 'Strike') {
        // Entering Strike phase - reset strike landed flag and activate lunge
        attack.strikeLanded = false;
        attack.currentPhase = 'Strike';
        
        // Activate colliders immediately when entering Strike phase
        attack.currentActiveKeys = getPresetActiveColliders(attack.preset);
        
        // Activate lunge mechanic for NPC - works for any attack, including combos
        attack.lunge.active = true;
        attack.lunge.paused = false;
        attack.lunge.distance = 0;
        
        // Calculate lunge direction toward player
        const dx = MOVE.pos.x - NPC_STATE.pos.x;
        const dy = MOVE.pos.y - NPC_STATE.pos.y;
        const aimAngle = Math.atan2(dy, dx);
        const lungeSpeed = attack.lunge.speed;
        attack.lunge.lungeVel.x = Math.cos(aimAngle) * lungeSpeed;
        attack.lunge.lungeVel.y = Math.sin(aimAngle) * lungeSpeed * 0.3;
      } else if (newPhase === 'Recoil' && oldPhase === 'Strike') {
        // Leaving Strike phase - if no hit landed, reset combo
        if (!attack.strikeLanded) {
          COMBO.hits = 0;
        }
        attack.currentPhase = 'Recoil';
      }
    }
    // Update active colliders only during Strike phase (phase 1)
    const phaseName = attack.sequence[attack.phaseIndex];
    if (phaseName === 'Strike'){
      attack.currentActiveKeys = getPresetActiveColliders(attack.preset);
    } else {
      attack.currentActiveKeys = [];
    }
  }
  
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', resizeCanvas);

  // ====== Main loop ======
  let lastT=now();
  
  // ====== Stamina System ======
  function updateStamina(dt) {
    // Check if dash is being held and if we have enough stamina
    const wantsDash = MOVE.input.dash;
    const isMoving = MOVE.input.left || MOVE.input.right;
    
    if (wantsDash && isMoving && STAMINA.current >= STAMINA.minToDash && !MOVE.ragdoll && !MOVE.recovering) {
      // Dash is active - drain stamina
      STAMINA.isDashing = true;
      STAMINA.current = Math.max(0, STAMINA.current - STAMINA.drainRate * dt);
      
      // Update trail
      if (DASH_TRAIL.enabled) {
        DASH_TRAIL.timer += dt;
        if (DASH_TRAIL.timer >= DASH_TRAIL.interval) {
          DASH_TRAIL.timer = 0;
          // Capture current position and pose for trail
          DASH_TRAIL.positions.unshift({
            x: MOVE.pos.x,
            y: MOVE.pos.y,
            facingRad: MOVE.facingRad,
            alpha: 1.0,
            // Store joint angles if available
            angles: MOVE.jointAngles && Object.keys(MOVE.jointAngles).length > 0 
              ? {...MOVE.jointAngles} 
              : null
          });
          // Limit trail length
          if (DASH_TRAIL.positions.length > DASH_TRAIL.maxLength) {
            DASH_TRAIL.positions.length = DASH_TRAIL.maxLength;
          }
        }
      }
      
      // If stamina hits zero, stop dashing
      if (STAMINA.current <= 0) {
        STAMINA.isDashing = false;
      }
    } else {
      // Not dashing - regenerate stamina
      STAMINA.isDashing = false;
      STAMINA.current = Math.min(STAMINA.max, STAMINA.current + STAMINA.regenRate * dt);
    }
    
    // Fade out trail positions
    for (let i = 0; i < DASH_TRAIL.positions.length; i++) {
      DASH_TRAIL.positions[i].alpha -= dt * 3;
    }
    // Remove fully faded trails
    DASH_TRAIL.positions = DASH_TRAIL.positions.filter(t => t.alpha > 0);
    
    // Update stamina bar UI
    updateStaminaBar();
  }
  
  function updateStaminaBar() {
    const fillEl = document.getElementById('staminaFill');
    const labelEl = document.getElementById('staminaLabel');
    if (!fillEl || !labelEl) return;
    
    const percent = (STAMINA.current / STAMINA.max) * 100;
    fillEl.style.width = percent + '%';
    
    // Update visual state
    fillEl.classList.remove('low', 'dashing');
    if (STAMINA.isDashing) {
      fillEl.classList.add('dashing');
    } else if (percent < 30) {
      fillEl.classList.add('low');
    }
    
    labelEl.textContent = `${Math.round(STAMINA.current)}`;
  }
  
  function updateHealthBar() {
    const fillEl = document.getElementById('healthFill');
    const labelEl = document.getElementById('healthLabel');
    if (!fillEl || !labelEl) return;
    
    // For now, health is always at 100% (not used yet)
    const health = 100;
    const maxHealth = 100;
    const percent = (health / maxHealth) * 100;
    fillEl.style.width = percent + '%';
    labelEl.textContent = `${Math.round(health)}`;
  }
  
  function updateFootingBar() {
    const fillEl = document.getElementById('footingFill');
    const labelEl = document.getElementById('footingLabel');
    if (!fillEl || !labelEl) return;
    
    // Footing ranges from 0 to maxFooting (default 100)
    const maxFooting = CONFIG.knockback && CONFIG.knockback.maxFooting ? CONFIG.knockback.maxFooting : 100;
    const percent = (MOVE.footing / maxFooting) * 100;
    fillEl.style.width = Math.max(0, Math.min(100, percent)) + '%';
    labelEl.textContent = `${MOVE.footing.toFixed(1)}`;
  }
  
  
  function updateAiHud(){
    const hud = document.getElementById('aiHud');
    if (!hud || hud.style.display==='none') return;
    try{
      const lines = [`NPC_ENABLED: ${typeof NPC_ENABLED!=='undefined' ? NPC_ENABLED : 'n/a'}`];
      NPCS.forEach((npc, index) => {
        ensureWandererState(npc, index);
        const dx = (MOVE && MOVE.pos && npc && npc.pos) ? (MOVE.pos.x - npc.pos.x) : 0;
        const wander = npc && npc.wander ? npc.wander : { direction: 0, timer: 0 };
        const dirLabel = wander.direction > 0 ? 'right' : (wander.direction < 0 ? 'left' : 'idle');
        lines.push(
          `NPC${index + 1}: x=${npc.pos.x.toFixed(1)} dir=${dirLabel} timer=${wander.timer.toFixed(1)} dx=${dx.toFixed(1)}`
        );
      });
      hud.textContent = lines.join('\n');
    }catch(e){ hud.textContent = 'HUD error: '+e.message; }
  }

  function tick(){
    const tNow=now(); 
    const dt=Math.min(0.05, Math.max(0.001, (tNow-lastT)/1000)); 
    LAST_DT=dt; 
    lastT=tNow;
    
    // Update charge stage while button is held
    if (CHARGE_STATE.active) {
      const heldMs = tNow - CHARGE_STATE.startTime;
      const slot = ATTACK_INPUT.slots[ATTACK.slot];
      if (slot && slot.heavy && slot.heavy.type === 'hold-release') {
        CHARGE_STATE.stage = Math.min(
          slot.heavy.maxChargeStages,
          Math.floor(heldMs / ATTACK_INPUT.thresholds.chargeStageMs)
        );
      }
    }
    
    // Process attack queue - execute queued attack when able
    if (ATTACK_QUEUE.pending && !ATTACK.active && canAttackNow()) {
      console.log('Processing queued attack:', ATTACK_QUEUE);
      
      // Clear queue BEFORE processing to prevent re-queueing
      const queuedType = ATTACK_QUEUE.type;
      const queuedButton = ATTACK_QUEUE.button;
      const queuedCharge = ATTACK_QUEUE.chargeStage;
      
      ATTACK_QUEUE.pending = false;
      ATTACK_QUEUE.type = null;
      ATTACK_QUEUE.button = null;
      ATTACK_QUEUE.chargeStage = 0;
      
      // Now execute the queued attack
      if (queuedType === 'light') {
        const slot = ATTACK_INPUT.slots[queuedButton];
        if (queuedButton === 'A' && slot.light.type === 'combo') {
          // Call combo attack directly without queueing check
          COMBO.timer = CONFIG.combo.timerDuration;
          const idx = COMBO.sequenceIndex % 4;
          const useAlt = (COMBO.hits >= 4 && COMBO.timer > 0);
          const presetName = useAlt ? (CONFIG.combo.altSequence[idx] || CONFIG.combo.sequence[idx]) : (CONFIG.combo.sequence[idx] || 'KICK');
          playQuickAttack(presetName, 0);
          COMBO.sequenceIndex = (COMBO.sequenceIndex + 1) % 4;
        } else if (queuedButton === 'B' && slot.light.type === 'quick') {
          playQuickAttack(slot.light.preset, slot.light.windupMs || 0);
        }
      } else if (queuedType === 'heavy') {
        executeHeavyAttack(queuedButton, queuedCharge);
      }
    }
    
    // Update stamina system
    updateStamina(dt);
    
    // Update player lunge mechanic - applies movement during Strike phase
    if (ATTACK.lunge.active && !ATTACK.lunge.paused) {
      // Apply lunge movement
      MOVE.pos.x += ATTACK.lunge.lungeVel.x * dt;
      MOVE.pos.y += ATTACK.lunge.lungeVel.y * dt;
      ATTACK.lunge.distance += Math.abs(ATTACK.lunge.lungeVel.x) * dt;
      
      // Stop lunge after target distance or when leaving Strike phase
      if (ATTACK.lunge.distance >= ATTACK.lunge.targetDistance || ATTACK.currentPhase !== 'Strike') {
        ATTACK.lunge.active = false;
        ATTACK.lunge.distance = 0;
      }
    }
    
    let poseOffsets;
    if(active){
      const t = Math.min(1, (tNow-active.start)/active.dur);
      poseOffsets = sampleOffsets();
      if (t>=1){ 
        current=clone(active.to); 
        lastPoseName=active.toName; 
        const next=active.onDone; 
        active=null; 
        if(next) next(); 
      }
      
    } else if (ATTACK.isCharging) {
      // Dynamic windup progression based on charge stage
      // Lerp from Stance (0%) to full Windup (100%) as charge progresses
      const slot = ATTACK_INPUT.slots[ATTACK.slot];
      if (slot && slot.heavy) {
        const maxStages = slot.heavy.maxChargeStages;
        
        // Calculate smooth progress based on actual time held, not discrete stages
        // This gives smooth animation instead of 5 discrete jumps
        const heldMs = tNow - CHARGE_STATE.startTime;
        const maxChargeMs = maxStages * ATTACK_INPUT.thresholds.chargeStageMs;
        const chargeProgress = Math.min(1.0, heldMs / maxChargeMs); // 0.0 to 1.0, smooth
        
        // Get Stance and Windup poses
        const stancePose = CONFIG.poses['Stance'] || {};
        const windupPose = CONFIG.poses['Windup'] || {};
        
        // Lerp between them based on charge progress
        poseOffsets = {};
        for (let key in stancePose) {
          if (typeof stancePose[key] === 'number' && typeof windupPose[key] === 'number') {
            poseOffsets[key] = stancePose[key] + (windupPose[key] - stancePose[key]) * chargeProgress;
          } else {
            poseOffsets[key] = stancePose[key];
          }
        }
      } else {
        poseOffsets = current;
      }
    } else { 
      poseOffsets = current; 
    }
    
    // Update the NPC's AI before orchestrating animations (only if NPC is enabled)
    if (NPC_ENABLED) {
      updateWanderers(dt);
    }
    const final = orchestrate(poseOffsets, dt);
    
    // Fade out attack trails over time
    for (const key of ['handL', 'handR', 'footL', 'footR']) {
      for (let i = 0; i < ATTACK_TRAIL.colliders[key].length; i++) {
        ATTACK_TRAIL.colliders[key][i].alpha -= dt * 4; // Faster fade than dash
      }
      ATTACK_TRAIL.colliders[key] = ATTACK_TRAIL.colliders[key].filter(t => t.alpha > 0);
    }
    
    // Fade out NPC attack trails
    if (NPC_ENABLED) {
      for (const key of ['handL', 'handR', 'footL', 'footR']) {
        for (let i = 0; i < NPC_ATTACK_TRAIL.colliders[key].length; i++) {
          NPC_ATTACK_TRAIL.colliders[key][i].alpha -= dt * 4;
        }
        NPC_ATTACK_TRAIL.colliders[key] = NPC_ATTACK_TRAIL.colliders[key].filter(t => t.alpha > 0);
      }
    }
    
    // Update camera to smoothly follow player
    const targetCameraX = MOVE.pos.x - cv.width / 2;
    const maxCameraX = WORLD_WIDTH - cv.width;
    const clampedTarget = clamp(targetCameraX, 0, maxCameraX);
    CAMERA.x += (clampedTarget - CAMERA.x) * CAMERA.smoothing;
    
    // Update door interaction prompt
    updateInteractPrompt();
    
    render(final);

    // Update combo timer and status info. Combo timer counts down when
    // active and influences whether alternate sequences are used. The status
    // box displays the remaining time and current hit count for quick
    // reference. When the timer expires it is clamped to zero.
    COMBO.timer = Math.max(0, COMBO.timer - dt*1000);
    if (statusInfo){
      let msg = 'Game running! Use keyboard (WASD, Space, E) or on-screen buttons to control.';
      if (COMBO.timer > 0){ msg += ` | Combo timer: ${(COMBO.timer/1000).toFixed(1)}s`; }
      msg += ` | Hits: ${COMBO.hits}`;
      statusInfo.textContent = msg;
    }
    
    // Update UI bars
    updateHealthBar();
    updateFootingBar();

    updateAiHud();
    requestAnimationFrame(tick);
  }

  function render(final){
    cx.clearRect(0,0,cv.width,cv.height);
    
    // Draw parallax background BEFORE camera transformation (in screen space)
    drawParallaxBackground(cx, CAMERA.x, 0);
    
    // Apply camera transformation - translates world coordinates to screen coordinates
    cx.save();
    cx.translate(-CAMERA.x, 0);
    
    drawGround();
    
    // Draw doors (in world space)
    drawDoors(cx);
    
    // Draw player dash trail effect (anime-style afterimages)
    if (DASH_TRAIL.enabled && DASH_TRAIL.positions.length > 0) {
      for (let i = DASH_TRAIL.positions.length - 1; i >= 0; i--) {
        const trail = DASH_TRAIL.positions[i];
        const alpha = trail.alpha * 0.4; // Make trails semi-transparent
        
        cx.save();
        cx.globalAlpha = alpha;
        
        // Draw a simplified silhouette at the trail position
        // Use a cyan/blue tint for the anime effect
        cx.fillStyle = `rgba(100, 200, 255, ${alpha})`;
        cx.strokeStyle = `rgba(150, 230, 255, ${alpha * 1.5})`;
        cx.lineWidth = 2;
        
        // Draw simple character silhouette (hitbox representation)
        const hb = CONFIG.parts.hitbox;
        const hbW = hb.w * CONFIG.actor.scale;
        const hbH = hb.h * CONFIG.actor.scale;
        const hbX = trail.x - hbW / 2;
        const hbY = trail.y - hbH / 2;
        
        // Add motion blur effect
        cx.beginPath();
        cx.ellipse(trail.x, trail.y, hbW/2, hbH/2, 0, 0, Math.PI * 2);
        cx.fill();
        cx.stroke();
        
        // Add speed lines for extra anime effect
        if (i === 0 && STAMINA.isDashing) {
          cx.strokeStyle = `rgba(150, 230, 255, ${alpha * 0.8})`;
          cx.lineWidth = 3;
          const speedLineLength = 30;
          const direction = trail.facingRad === 0 ? 1 : -1;
          for (let j = -1; j <= 1; j++) {
            cx.beginPath();
            cx.moveTo(trail.x - direction * speedLineLength, trail.y + j * 20);
            cx.lineTo(trail.x - direction * speedLineLength * 0.3, trail.y + j * 20);
            cx.stroke();
          }
        }
        
        cx.restore();
      }
    }
    
    // Draw NPC dash trail effect (red/orange tint for enemy)
    if (NPC_ENABLED && NPC_DASH_TRAIL.enabled && NPC_DASH_TRAIL.positions.length > 0) {
      for (let i = NPC_DASH_TRAIL.positions.length - 1; i >= 0; i--) {
        const trail = NPC_DASH_TRAIL.positions[i];
        const alpha = trail.alpha * 0.4;
        
        cx.save();
        cx.globalAlpha = alpha;
        
        // Use a red/orange tint for enemy
        cx.fillStyle = `rgba(255, 100, 80, ${alpha})`;
        cx.strokeStyle = `rgba(255, 150, 100, ${alpha * 1.5})`;
        cx.lineWidth = 2;
        
        const hb = CONFIG.parts.hitbox;
        const hbW = hb.w * CONFIG.actor.scale;
        const hbH = hb.h * CONFIG.actor.scale;
        
        cx.beginPath();
        cx.ellipse(trail.x, trail.y, hbW/2, hbH/2, 0, 0, Math.PI * 2);
        cx.fill();
        cx.stroke();
        
        // Speed lines for NPC
        if (i === 0 && NPC_STATE.stamina.isDashing) {
          cx.strokeStyle = `rgba(255, 150, 100, ${alpha * 0.8})`;
          cx.lineWidth = 3;
          const speedLineLength = 30;
          const direction = trail.facingRad === 0 ? 1 : -1;
          for (let j = -1; j <= 1; j++) {
            cx.beginPath();
            cx.moveTo(trail.x - direction * speedLineLength, trail.y + j * 20);
            cx.lineTo(trail.x - direction * speedLineLength * 0.3, trail.y + j * 20);
            cx.stroke();
          }
        }
        
        cx.restore();
      }
    }
    
    // Draw the player's skeleton and colliders. Save the player's colliders
    // before drawing the NPC so we can restore them later. We clone nested
    // values to avoid mutating references when copying.
    drawSkeleton(final.offsets, final.hitCenter);
    
    const savedColliders = {
      hitCenter: { x: COLLIDERS_POS.hitCenter.x, y: COLLIDERS_POS.hitCenter.y },
      handL: COLLIDERS_POS.handL ? { x: COLLIDERS_POS.handL.x, y: COLLIDERS_POS.handL.y } : null,
      handR: COLLIDERS_POS.handR ? { x: COLLIDERS_POS.handR.x, y: COLLIDERS_POS.handR.y } : null,
      footL: COLLIDERS_POS.footL ? { x: COLLIDERS_POS.footL.x, y: COLLIDERS_POS.footL.y } : null,
      footR: COLLIDERS_POS.footR ? { x: COLLIDERS_POS.footR.x, y: COLLIDERS_POS.footR.y } : null
    };
    
    // Capture player attack trail positions (after skeleton is drawn and colliders are positioned)
    if (ATTACK_TRAIL.enabled && ATTACK.active) {
      ATTACK_TRAIL.timer += LAST_DT;
      if (ATTACK_TRAIL.timer >= ATTACK_TRAIL.interval) {
        ATTACK_TRAIL.timer = 0;
        
        const activeKeys = getActiveColliders();
        const baseRad = 8 * CONFIG.actor.scale;
        for (const key of ['handL', 'handR', 'footL', 'footR']) {
          if (activeKeys.includes(key) && savedColliders[key]) {
            // Calculate radius inline
            let radius = baseRad;
            if (key === 'handL' || key === 'handR') {
              radius *= CONFIG.colliders.handMultiplier;
            } else if (key === 'footL' || key === 'footR') {
              radius *= CONFIG.colliders.footMultiplier;
            }
            
            // Capture the collider position
            ATTACK_TRAIL.colliders[key].unshift({
              x: savedColliders[key].x,
              y: savedColliders[key].y,
              alpha: 1.0,
              radius: radius
            });
            
            // Limit trail length
            if (ATTACK_TRAIL.colliders[key].length > ATTACK_TRAIL.maxLength) {
              ATTACK_TRAIL.colliders[key].length = ATTACK_TRAIL.maxLength;
            }
          }
        }
      }
    }
    
    if (NPC_ENABLED) {
      drawWanderers(LAST_DT, savedColliders);
    }
    const playerActiveKeys2 = getActiveColliders();
    const playerCollisionKeys2 = [];

    // Draw player attack collider trails (afterimages)
    if (ATTACK_TRAIL.enabled) {
      for (const key of ['handL', 'handR', 'footL', 'footR']) {
        const trail = ATTACK_TRAIL.colliders[key];
        for (let i = trail.length - 1; i >= 0; i--) {
          const pos = trail[i];
          const alpha = pos.alpha * 0.5; // Semi-transparent afterimages
          
          cx.save();
          cx.globalAlpha = alpha;
          
          // Draw the collider afterimage with cyan/blue tint (matching dash effect)
          cx.beginPath();
          cx.arc(pos.x, pos.y, pos.radius, 0, TAU);
          cx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.8})`;
          cx.strokeStyle = `rgba(150, 230, 255, ${alpha})`;
          cx.lineWidth = 2;
          cx.fill();
          cx.stroke();
          
          cx.restore();
        }
      }
    }
    
    // Draw the player's colliders with active/highlight information and counts
    drawAttackColliders(savedColliders, playerActiveKeys2, playerCollisionKeys2, HIT_COUNTS.player, MOVE.facingRad);
    // NPC wanderers are non-aggressive, so no additional collider overlays are drawn.
    
    // HUD - Debug display commented out for clean gameplay
    /* 
    cx.fillStyle = '#9aa6b2'; 
    cx.font = '12px system-ui, sans-serif';
    const blend = getPoseBlend();
    const phase = nearestPose(final.offsets);
    
    // Check if we're in a cancel window
    let inCancelWindow = false;
    if (blend.toName === 'Recoil' && ATTACK.active && ATTACK.preset) {
      const preset = CONFIG.presets && CONFIG.presets[ATTACK.preset];
      if (preset && typeof preset.cancelWindow === 'number') {
        const cancelStart = 1.0 - preset.cancelWindow;
        if (blend.k >= cancelStart) {
          inCancelWindow = true;
        }
      }
    }
    
    const hud = [
      holding ? 'Holding: WINDUP' : ('Nearest: ' + phase),
      'vx=' + MOVE.vel.x.toFixed(0) + '  vy=' + MOVE.vel.y.toFixed(0),
      (MOVE.onGround ? 'grounded' : 'air'),
      'facing¬∞=' + rad2deg(MOVE.facingRad).toFixed(0),
      (ATTACK.active ? ('atkFace¬∞=' + rad2deg(ATTACK.facingRadAtPress).toFixed(0)) : 'atkFace:-'),
      CONFIG.ik.calvesOnly ? 'IK: calves-only' : 'IK: full leg',
      (FACE.active ? 'face-lock' : 'free-face'),
      'walkAmp=' + WALK.amp.toFixed(2) + ' œÜ=' + WALK.phase.toFixed(2)
    ].join('  ‚Ä¢  ');
    // First line: debug HUD
    cx.fillText(hud, 14, 22);
    // Second line: current animation/preset name and cancel window indicator
    let animLine = ATTACK.preset ? 'Anim: ' + ATTACK.preset : '';
    if (inCancelWindow) {
      animLine += ' ‚ú® CANCEL WINDOW';
    }
    if (animLine){
      cx.fillText(animLine, 14, 36);
    }
    // Third line: Footing values for both fighters
    const footingHud = `Player Footing: ${MOVE.footing.toFixed(1)} | NPC Footing: ${NPC_STATE.footing.toFixed(1)}${MOVE.ragdoll ? ' | üî¥ RAGDOLL ACTIVE' : ''}`;
    cx.fillText(footingHud, 14, 50);
    
    // Fourth line: Ragdoll warning when active
    if (MOVE.ragdoll) {
      cx.fillStyle = '#ff3c3c';
      cx.font = 'bold 14px system-ui, sans-serif';
      cx.fillText('‚ö†Ô∏è FULL BODY RAGDOLL - ALL JOINTS COLLAPSED!', 14, 64);
      cx.fillStyle = '#9aa6b2';
      cx.font = '12px system-ui, sans-serif';
    }
    */
    
    // Charge stage indicator when holding attack button
    if (CHARGE_STATE.active && CHARGE_STATE.stage >= 0) {
      const slot = ATTACK_INPUT.slots[ATTACK.slot];
      if (slot && slot.heavy) {
        const maxStages = slot.heavy.maxChargeStages;
        const minStages = slot.heavy.minChargeStages;
        const currentStage = CHARGE_STATE.stage;
        
        // Draw charge bar
        const barX = cv.width - 220;
        const barY = 20;
        const barWidth = 200;
        const barHeight = 30;
        
        // Background
        cx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        cx.fillRect(barX, barY, barWidth, barHeight);
        
        // Stage blocks
        const blockWidth = (barWidth - 10) / maxStages;
        for (let i = 0; i < maxStages; i++) {
          const x = barX + 5 + i * blockWidth;
          const y = barY + 5;
          const w = blockWidth - 2;
          const h = barHeight - 10;
          
          if (i < currentStage) {
            // Filled stage
            if (i < minStages) {
              cx.fillStyle = '#fbbf24'; // Yellow for minimum required
            } else {
              cx.fillStyle = '#22c55e'; // Green for bonus stages
            }
          } else if (i < minStages) {
            cx.fillStyle = '#ef4444'; // Red for unfilled required stages
          } else {
            cx.fillStyle = '#374151'; // Gray for unfilled bonus stages
          }
          
          cx.fillRect(x, y, w, h);
          
          // Border
          cx.strokeStyle = '#1f2937';
          cx.lineWidth = 1;
          cx.strokeRect(x, y, w, h);
        }
        
        // Label
        cx.fillStyle = '#ffffff';
        cx.font = 'bold 11px system-ui, sans-serif';
        cx.textAlign = 'center';
        cx.fillText(`CHARGE: ${currentStage}/${maxStages}`, barX + barWidth/2, barY + barHeight + 14);
        cx.textAlign = 'left';
      }
    }
    
    // Restore camera transformation
    cx.restore();
  }

  // ====== Sprite debug panel ======
  let debugEl = null;
  function ensureSpriteDebug(){
    if (debugEl) return;
    debugEl = document.createElement('div');
    debugEl.className = 'sprite-debug';
    debugEl.style.display = 'none';
    debugEl.innerHTML = '<h4>Sprite Loader</h4><div class="grid mono" id="spriteGrid"></div>';
    const stage = document.getElementById('gameStage'); 
    stage.appendChild(debugEl);
  }
  
  function refreshSpriteDebug(){
    ensureSpriteDebug();
    if (!debugEl) return;
    const g = debugEl.querySelector('#spriteGrid');
    const keys = Object.keys(SPRITES.cache);
    const stats = [
      '<span>loaded</span><span class="ok">'+Object.keys(SPRITES.loaded).length+'</span>',
      '<span>pending</span><span class="warn">'+SPRITES.pending.size+'</span>',
      '<span>failed</span><span class="bad">'+SPRITES.failed.size+'</span>'
    ];
    const rows = keys.map(k=>{
      const ok = !!SPRITES.loaded[k], bad = SPRITES.failed.has(k), pend = SPRITES.pending.has(k);
      const cls = ok ? 'ok' : (bad ? 'bad' : 'warn');
      return `<span>${k}</span><span class="${cls}">${ok?'‚úì':(bad?'√ó':'‚Ä¶')}</span>`;
    });
    g.innerHTML = stats.concat(rows).map(x=>`<div>${x}</div>`).join('');
  }
  
  window.addEventListener('keydown', (e)=>{
    if(e.code==='F9'){ 
      ensureSpriteDebug(); 
      debugEl.style.display = (debugEl.style.display==='none'?'block':'none'); 
    }
  });

  // ====== Start ======
  ensureSpriteCacheEl();
  applyFighter('TLETINGAN');
  resetSpriteMirrorsForPose('Stance');
  primeAnimEventsForPose('Stance');
  refreshSpriteDebug();
  // Build the combo configuration UI once presets and fighter data are loaded
  initComboUI();
  resizeCanvas();
  // Initialize parallax system
  initParallaxSystem();
  requestAnimationFrame(tick);

  // Update status
  const statusInfo = document.getElementById('statusInfo');
  if(statusInfo) {
    statusInfo.textContent = 'Game running! Use keyboard (WASD, Space, E) or on-screen buttons to control.';
  }
  </script>

<style id="controls-bottom-sot">
  /* Single Source of Truth for control bottom offsets.
     Every control cluster's bottom derives from --stage-bottom-offset,
     plus device safe area. Interact button stacks above action cluster. */
  .stage .joystick-area,
  .controls-overlay .joystick-area {
    bottom: calc(var(--stage-bottom-offset) + env(safe-area-inset-bottom, 0px)) !important;
  }
  .stage .action-buttons,
  .controls-overlay .action-buttons {
    bottom: calc(var(--stage-bottom-offset) + env(safe-area-inset-bottom, 0px)) !important;
  }
  .stage .interact-btn,
  .controls-overlay .interact-btn {
    bottom: calc(var(--stage-bottom-offset) + (var(--action-size) * var(--control-scale)) + (var(--interact-gap) * var(--control-scale)) + env(safe-area-inset-bottom, 0px)) !important;
  }
</style>

<!-- === Parallax Props: Keyframe Blend Module (v2) === -->
<script>
/* =======================================================================
   Parallax Props (Keyframed)
   - Per-prop keyframes for LEFT (t=-1), CENTER (t=0), RIGHT (t=1)
   - Blends only: scaleX, rotateZ (deg), translate (dx,dy)
   - Retains per-prop parallaxX + clamp for baseline screen X
   - Mobile debug toggle: 'üß± Props' button or 'P' key

   Authoring notes:
   - t = clamp((CAMERA.x - prop.x)/kf.radius, -1, 1)
   - We blend LEFT<->CENTER when t<=0, CENTER<->RIGHT when t>0
   - Easing: 'linear'|'smoothstep'|'quadInOut' per prop (optional)
   ======================================================================= */

(function(){
  'use strict';

  // ---------- Utilities ----------
  const _clamp = (typeof clamp === 'function') ? clamp : (v, lo, hi)=>Math.max(lo, Math.min(hi, v));
  const _rad  = (d)=>d * Math.PI / 180;

  function ease01(name, x){
    x = _clamp(x, 0, 1);
    switch(name){
      case 'smoothstep': return x*x*(3 - 2*x);
      case 'quadInOut':  return (x<0.5) ? 2*x*x : 1 - Math.pow(-2*x+2, 2)/2;
      case 'linear':
      default: return x;
    }
  }

  function lerp(a, b, t){ return a + (b - a) * t; }
  function computeScreenX(p, cameraX){
    const normal = p.x - cameraX;
    const withParallax = p.x - cameraX * (p.parallaxX ?? 1.0);
    const extra = withParallax - normal;
    const cap = Math.abs(p.parallaxClampPx ?? Infinity);
    const cappedExtra = _clamp(extra, -cap, cap);
    return normal + cappedExtra;
  }

  // ---------- Runtime ----------
  const PROPS = window.__PARALLAX_PROPS__ = window.__PARALLAX_PROPS__ || {
    current: [],
    debug: { enabled:false, drawBounds:true, drawAnchor:true, drawLabel:true, showKF:true }
  };

  // Reuse / ensure debug button
  function ensurePropsDebugButton(){
    try{
      const topUi = document.querySelector('.top-ui') || document.querySelector('#top-ui') || document.body;
      if (!topUi || topUi.querySelector('#btnPropsDebug')) return;
      const btn = document.createElement('button');
      btn.id = 'btnPropsDebug';
      btn.type = 'button';
      btn.style.cssText = 'position:fixed;right:8px;top:8px;z-index:9999;padding:6px 10px;border-radius:8px;border:1px solid #555;background:#222;color:#ddd;font:12px ui-monospace;';
      btn.textContent = 'üß± Props';
      btn.title = 'Toggle parallax props debug (P)';
      btn.addEventListener('click', ()=>{ PROPS.debug.enabled = !PROPS.debug.enabled; });
      topUi.appendChild(btn);
    }catch(e){}
  }
  window.addEventListener('keydown', (e)=>{ if (e.code === 'KeyP') PROPS.debug.enabled = !PROPS.debug.enabled; });

  // ---------- Keyframe blending ----------
  function blendKf(p, cameraX){
    const kf = p.kf;
    if (!kf) return null;

    const radius = Math.max(1, kf.radius || 600);
    const t = _clamp((cameraX - p.x) / radius, -1, 1);
    const left   = kf.left   || {dx:0,dy:0,scaleX:1,rotZdeg:0};
    const center = kf.center || {dx:0,dy:0,scaleX:1,rotZdeg:0};
    const right  = kf.right  || {dx:0,dy:0,scaleX:1,rotZdeg:0};

    const easing = (kf.ease || 'smoothstep');

    let a=0, from=center, to=center;
    if (t <= 0){
      a = ease01(easing, t + 1);   // -1..0  ->  0..1
      from = left; to = center;
    } else {
      a = ease01(easing, t);       //  0..1  ->  0..1
      from = center; to = right;
    }

    const dx = lerp(from.dx || 0, to.dx || 0, a);
    const dy = lerp(from.dy || 0, to.dy || 0, a);
    const scaleX = lerp(from.scaleX ?? 1, to.scaleX ?? 1, a);
    const rotZdeg = lerp(from.rotZdeg || 0, to.rotZdeg || 0, a);

    return { t, dx, dy, scaleX, rotZdeg, translateSpace: (kf.translateSpace || 'screen') };
  }

  // ---------- Loading ----------
  function loadParallaxProps(areaId){
    PROPS.current.length = 0;
    if (!window.PARALLAX || !PARALLAX.areas) return;
    const A = PARALLAX.areas[areaId];
    if (!A) return;

    const list = Array.isArray(A.props) ? A.props : [];
    for (const src of list){
      const p = Object.assign({
        parallaxX: 1,
        parallaxClampPx: Infinity,
        pivot: 'bottom',
        layer: 'behind',
        z: 0
      }, src, { image: new Image(), loaded:false });

      p.image.crossOrigin = 'anonymous';
      p.image.onload = ()=>{ p.loaded = true; };
      p.image.onerror = ()=>{ p.failed = true; };
      p.image.src = p.url;

      PROPS.current.push(p);
    }
    PROPS.current.sort((a,b)=> (a.layer===b.layer) ? ((a.z||0)-(b.z||0)) : (a.layer==='behind'?-1:1));
  }

  // ---------- Draw ----------
  function drawProp(ctx, p, cameraX, cameraY){
    if (!p.loaded || p.failed) return;

    const w = p.w || p.image.width;
    const h = p.h || p.image.height;
    const x = computeScreenX(p, cameraX);
    const y = (p.pivot === 'bottom') ? (p.y - h) : (p.y || 0);

    // Pivot at bottom-center or top-left
    const ox = (p.pivot === 'bottom') ? (w * 0.5) : 0;
    const oy = (p.pivot === 'bottom') ? (h) : 0;

    // Keyframed transform (preferred if present)
    const kfb = blendKf(p, cameraX);

    ctx.save();
    ctx.translate(x, y + oy);

    // If translateSpace is 'screen', apply before rotate/scale
    if (kfb && kfb.translateSpace === 'screen'){
      ctx.translate(kfb.dx || 0, kfb.dy || 0);
    }

    // Apply rotation + scaleX
    if (kfb){
      if (kfb.rotZdeg) ctx.rotate(_rad(kfb.rotZdeg));
      if (kfb.scaleX !== undefined) ctx.scale(kfb.scaleX, 1);
    } else if (p.skewMaxDeg){ // backward-compatible shear if legacy fields present
      const radius = Math.max(1, p.skewRadius || 600);
      const t = _clamp((cameraX - p.x) / radius, -1, 1);
      const shx = Math.tan(_rad((p.skewMaxDeg || 0) * t));
      ctx.transform(1, 0, shx, 1, 0, 0);
    }

    // If translateSpace is 'local', apply after rotate/scale
    if (kfb && kfb.translateSpace === 'local'){
      ctx.translate(kfb.dx || 0, kfb.dy || 0);
    }

    // Draw image with chosen pivot
    ctx.drawImage(p.image, -ox, -oy, w, h);

    if (PROPS.debug.enabled){
      // Bounds
      if (PROPS.debug.drawBounds){
        ctx.lineWidth = 1.25;
        ctx.strokeStyle = 'rgba(34,197,94,.85)';
        ctx.strokeRect(-ox, -oy, w, h);
      }
      // Anchor
      if (PROPS.debug.drawAnchor){
        ctx.fillStyle = 'rgba(59,130,246,.95)';
        ctx.beginPath(); ctx.arc(0, 0, 3.5, 0, Math.PI*2); ctx.fill();
      }
      // Label
      if (PROPS.debug.drawLabel){
        ctx.fillStyle = '#ddd';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        const tStr = kfb ? ` t:${kfb.t.toFixed(2)} sX:${(kfb.scaleX??1).toFixed(3)} rZ:${(kfb.rotZdeg??0).toFixed(1)}¬∞ d:(${(kfb.dx??0)|0},${(kfb.dy??0)|0})` : '';
        ctx.fillText(`${p.id||'prop'}  x:${p.x}|y:${p.y}  pX:${p.parallaxX}${tStr}`, -ox, -oy-6);
      }

      // KF markers (screen-space)
      if (PROPS.debug.showKF && p.kf){
        const r = Math.max(1, p.kf.radius || 600);
        const leftX   = computeScreenX({...p, x: p.x - r }, cameraX) - x;
        const rightX  = computeScreenX({...p, x: p.x + r }, cameraX) - x;
        ctx.strokeStyle = 'rgba(255,255,255,.35)';
        ctx.beginPath();
        ctx.moveTo(leftX, -oy-8); ctx.lineTo(leftX, -oy+h+8);
        ctx.moveTo(0, -oy-10); ctx.lineTo(0, -oy+h+10);
        ctx.moveTo(rightX, -oy-8); ctx.lineTo(rightX, -oy+h+8);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawParallaxPropsScreen(ctx, cameraX, cameraY, layer){
    const arr = PROPS.current;
    for (let i=0; i<arr.length; i++){
      const p = arr[i];
      if ((p.layer||'behind') !== layer) continue;
      drawProp(ctx, p, cameraX, cameraY);
    }
  }

  // ---------- Hooks ----------
  function installHooks(){
    if (typeof window.drawParallaxBackground === 'function' && !window.drawParallaxBackground.__patchedProps){
      const _bg = window.drawParallaxBackground;
      window.drawParallaxBackground = function(ctx, cameraX, cameraY){
        _bg.call(this, ctx, cameraX, cameraY);
        drawParallaxPropsScreen(ctx, cameraX, cameraY, 'behind');
      };
      window.drawParallaxBackground.__patchedProps = true;
    }

    if (typeof window.render === 'function' && !window.render.__patchedProps){
      const _render = window.render;
      window.render = function(final){
        _render.call(this, final);
        if (window.cx && window.CAMERA) drawParallaxPropsScreen(window.cx, window.CAMERA.x || 0, 0, 'front');
      };
      window.render.__patchedProps = true;
    }

    if (typeof window.transitionToArea === 'function' && !window.transitionToArea.__patchedProps){
      const _go = window.transitionToArea;
      window.transitionToArea = function(targetAreaId, spawnX, spawnY){
        _go.call(this, targetAreaId, spawnX, spawnY);
        setTimeout(()=> loadParallaxProps(targetAreaId), 0);
      };
      window.transitionToArea.__patchedProps = true;
    }
  }

  // ---------- Authoring examples ----------
  function defineParallaxProps(){
    if (!window.PARALLAX || !PARALLAX.areas) return;
    // Ensure arrays
    for (const k of Object.keys(PARALLAX.areas)){
      PARALLAX.areas[k].props = PARALLAX.areas[k].props || [];
    }

    // Example with keyframes (replace url + coords)
    (PARALLAX.areas.main_hall.props).push({
      id: 'ziggurat_kf01',
      url: 'https://i.imgur.com/placeholder_building.png',
      x: 620,
      y: (window.CONFIG ? CONFIG.groundY : 380),
      w: 360, h: 300,
      parallaxX: 0.85,
      parallaxClampPx: 64,
      pivot: 'bottom',
      layer: 'front',
      z: 1,

      // Keyframes: only X-scale, Z-rotation, XY translation
      kf: {
        radius: 600,              // world px to reach left/right states
        ease: 'smoothstep',       // 'linear'|'smoothstep'|'quadInOut'
        translateSpace: 'screen', // 'screen'|'local'

        left:   { dx: -26, dy: 0,  scaleX: 0.92, rotZdeg: -7 },
        center: { dx:   0, dy: 0,  scaleX: 1.00, rotZdeg:  0 },
        right:  { dx:  22, dy: 0,  scaleX: 0.92, rotZdeg:  6 }
      }
    });
  }

  // ---------- Boot ----------
  function tryInit(){
    if (!window.PARALLAX || !PARALLAX.areas){ requestAnimationFrame(tryInit); return; }
    ensurePropsDebugButton();
    defineParallaxProps();
    loadParallaxProps(PARALLAX.currentAreaId || Object.keys(PARALLAX.areas)[0]);
    installHooks();
  }
  tryInit();

})();
</script>

</body>
</html>
